<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>jsx-transformer-min.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../Archive/Gemfile.html">Gemfile</a>
  
    <li><a href="../../../Archive/Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../Archive/README_md.html">README</a>
  
    <li><a href="../../../Archive/config_ru.html">config.ru</a>
  
    <li><a href="../../../Archive/lib/database_sql.html">database.sql</a>
  
    <li><a href="../../../Archive/public/css/bootstrap-theme_css.html">bootstrap-theme.css</a>
  
    <li><a href="../../../Archive/public/css/bootstrap-theme_css_map.html">bootstrap-theme.css.map</a>
  
    <li><a href="../../../Archive/public/css/bootstrap-theme_min_css.html">bootstrap-theme.min.css</a>
  
    <li><a href="../../../Archive/public/css/bootstrap_css.html">bootstrap.css</a>
  
    <li><a href="../../../Archive/public/css/bootstrap_css_map.html">bootstrap.css.map</a>
  
    <li><a href="../../../Archive/public/css/bootstrap_min_css.html">bootstrap.min.css</a>
  
    <li><a href="../../../Archive/public/fonts/glyphicons-halflings-regular_svg.html">glyphicons-halflings-regular.svg</a>
  
    <li><a href="../../../Archive/public/js/bootstrap_js.html">bootstrap.js</a>
  
    <li><a href="../../../Archive/public/js/bootstrap_min_js.html">bootstrap.min.js</a>
  
    <li><a href="../../../Archive/public/js/npm_js.html">npm.js</a>
  
    <li><a href="../../../Archive/templates/add_maker_html.html">add_maker.html</a>
  
    <li><a href="../../../Archive/templates/add_review_html.html">add_review.html</a>
  
    <li><a href="../../../Archive/templates/add_wine_html.html">add_wine.html</a>
  
    <li><a href="../../../Archive/templates/edit_maker_html.html">edit_maker.html</a>
  
    <li><a href="../../../Archive/templates/edit_wine_html.html">edit_wine.html</a>
  
    <li><a href="../../../Archive/templates/feed_makers_html.html">feed_makers.html</a>
  
    <li><a href="../../../Archive/templates/feed_reviews_html.html">feed_reviews.html</a>
  
    <li><a href="../../../Archive/templates/feed_tags_html.html">feed_tags.html</a>
  
    <li><a href="../../../Archive/templates/feed_wines_html.html">feed_wines.html</a>
  
    <li><a href="../../../Archive/templates/info_maker_html.html">info_maker.html</a>
  
    <li><a href="../../../Archive/templates/info_tag_html.html">info_tag.html</a>
  
    <li><a href="../../../Archive/templates/info_wine_html.html">info_wine.html</a>
  
    <li><a href="../../../Archive/templates/main_html.html">main.html</a>
  
    <li><a href="../../../Archive/templates/nav_html.html">nav.html</a>
  
    <li><a href="../../../Archive/templates/subscribe_html.html">subscribe.html</a>
  
    <li><a href="../../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../README_rdoc.html">README</a>
  
    <li><a href="../../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
  
    <li><a href="../../../config_ru.html">config.ru</a>
  
    <li><a href="../../../lib/assets/javascripts/backbone-min_js.html">backbone-min.js</a>
  
    <li><a href="../../../lib/assets/javascripts/jquery2_js.html">jquery2.js</a>
  
    <li><a href="../../../lib/assets/javascripts/jsx-transformer-min_js.html">jsx-transformer-min.js</a>
  
    <li><a href="../../../lib/assets/javascripts/react-min_js.html">react-min.js</a>
  
    <li><a href="../../../lib/assets/javascripts/underscore-min_js.html">underscore-min.js</a>
  
    <li><a href="../../../log/development_log.html">development.log</a>
  
    <li><a href="../../../log/production_log.html">production.log</a>
  
    <li><a href="../../../public/404_html.html">404.html</a>
  
    <li><a href="../../../public/422_html.html">422.html</a>
  
    <li><a href="../../../public/500_html.html">500.html</a>
  
    <li><a href="../../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../../public/robots_txt.html">robots</a>
  
    <li><a href="../../../tmp/pids/server_pid.html">server.pid</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page lib/assets/javascripts/jsx-transformer-min.js">

<pre>JSXTransformer v0.12.2</pre>

<p>!function(e){if(“object”==typeof exports&amp;&amp;“undefined”!=typeof
module)module.exports=e();else if(“function”==typeof
define&amp;&amp;define.amd)define([],e);else{var f;“undefined”!=typeof
window?f=window:“undefined”!=typeof global?f=global:“undefined”!=typeof
self&amp;&amp;(f=self),f.JSXTransformer=e()}}(function(){var
define,module,exports;return (function e(t,n,r){function s(o,u){<a
href="o">if(!n</a>){<a href="o">if(!t</a>){var a=typeof
require==“function”&amp;&amp;require;if(!u&amp;&amp;a)return
a(o,!0);if(i)return i(o,!0);var f=new Error(“Cannot find module
&#39;”<code>o</code>“&#39;”);throw f.code=“MODULE_NOT_FOUND”,f}var <a
href="o">l=n</a>={exports:{}};<a
href="o">t</a>[0].call(l.exports,function(e){var <a href="o">n=t</a>[<a
href="e">1]</a>;return s(n?n:e)},l,l.exports,e,t,n,r)}return <a
href="o">n</a>.exports}var i=typeof
require==“function”&amp;&amp;require;for(var <a
href="o">o=0;o<r.length;o++)s(r</a>);return
s})({1:[function(<em>dereq</em>,module,exports){</p>

<pre> Copyright 2013-2014, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
/</pre>

<p>/* jshint browser: true</p>

<p>/* jslint evil: true */</p>

<p>&#39;use strict&#39;;</p>

<p>var buffer = <em>dereq</em>(&#39;buffer&#39;); var transform =
<em>dereq</em>(&#39;jstransform&#39;).transform; var typesSyntax =
<em>dereq</em>(&#39;jstransform/visitors/type-syntax&#39;); var visitors =
<em>dereq</em>(&#39;./fbtransform/visitors&#39;);</p>

<p>var headEl; var dummyAnchor; var inlineScriptCount = 0;</p>

<p>// The source-map library relies on Object.defineProperty, but IE8
doesn&#39;t // support it fully even with es5-sham. Indeed, es5-sham&#39;s
defineProperty // throws when Object.prototype.__defineGetter__ is missing,
so we skip building // the source map in that case. var supportsAccessors =
Object.prototype.hasOwnProperty(&#39;__defineGetter__&#39;);</p>

<p>/**</p>

<pre> Run provided code through jstransform.

 @param {string} source Original source code
 @param {object?} options Options to pass to jstransform
 @return {object} object as returned from jstransform
/</pre>

<p>function transformReact(source, options) {</p>

<pre>// TODO: just use react-tools
options = options || {};
var visitorList;
if (options.harmony) {
  visitorList = visitors.getAllVisitors();
} else {
  visitorList = visitors.transformVisitors.react;
}

if (options.stripTypes) {
  // Stripping types needs to happen before the other transforms
  // unfortunately, due to bad interactions. For example,
  // es6-rest-param-visitors conflict with stripping rest param type
  // annotation
  source = transform(typesSyntax.visitorList, source, options).code;
}

return transform(visitorList, source, {
  sourceMap: supportsAccessors &amp;&amp; options.sourceMap
});</pre>

<p>}</p>

<p>/**</p>

<pre> Eval provided source after transforming it.

 @param {string} source Original source code
 @param {object?} options Options to pass to jstransform
/</pre>

<p>function exec(source, options) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">eval</span>(<span class="ruby-identifier">transformReact</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">options</span>).<span class="ruby-identifier">code</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> This method returns a nicely formated line of code pointing to the exact
 location of the error `e`. The line is limited in size so big lines of code
 are also shown in a readable way.

 Example:
 ... x&#39;, overflow:&#39;scroll&#39;}} id={} onScroll={this.scroll} class=&quot; ...
 ^

 @param {string} code The full string of code
 @param {Error} e The error being thrown
 @return {string} formatted message
 @internal
/</pre>

<p>function createSourceCodeErrorMessage(code, e) {</p>

<pre>var sourceLines = code.split(&#39;\n&#39;);
var erroneousLine = sourceLines[e.lineNumber - 1];

// Removes any leading indenting spaces and gets the number of
// chars indenting the `erroneousLine`
var indentation = 0;
erroneousLine = erroneousLine.replace(/^\s+/, function(leadingSpaces) {
  indentation = leadingSpaces.length;
  return &#39;&#39;;
});

// Defines the number of characters that are going to show
// before and after the erroneous code
var LIMIT = 30;
var errorColumn = e.column - indentation;

if (errorColumn &gt; LIMIT) {
  erroneousLine = &#39;... &#39; + erroneousLine.slice(errorColumn - LIMIT);
  errorColumn = 4 + LIMIT;
}
if (erroneousLine.length - errorColumn &gt; LIMIT) {
  erroneousLine = erroneousLine.slice(0, errorColumn + LIMIT) + &#39; ...&#39;;
}
var message = &#39;\n\n&#39; + erroneousLine + &#39;\n&#39;;
message += new Array(errorColumn - 1).join(&#39; &#39;) + &#39;^&#39;;
return message;</pre>

<p>}</p>

<p>/**</p>

<pre> Actually transform the code.

 @param {string} code
 @param {string?} url
 @param {object?} options
 @return {string} The transformed code.
 @internal
/</pre>

<p>function transformCode(code, url, options) {</p>

<pre>try {
  var transformed = transformReact(code, options);
} catch(e) {
  e.message += &#39;\n    at &#39;;
  if (url) {
    if (&#39;fileName&#39; in e) {
      // We set `fileName` if it&#39;s supported by this error object and
      // a `url` was provided.
      // The error will correctly point to `url` in Firefox.
      e.fileName = url;
    }
    e.message += url + &#39;:&#39; + e.lineNumber + &#39;:&#39; + e.column;
  } else {
    e.message += location.href;
  }
  e.message += createSourceCodeErrorMessage(code, e);
  throw e;
}

if (!transformed.sourceMap) {
  return transformed.code;
}

var map = transformed.sourceMap.toJSON();
var source;
if (url == null) {
  source = &quot;Inline JSX script&quot;;
  inlineScriptCount++;
  if (inlineScriptCount &gt; 1) {
    source += &#39; (&#39; + inlineScriptCount + &#39;)&#39;;
  }
} else if (dummyAnchor) {
  // Firefox has problems when the sourcemap source is a proper URL with a
  // protocol and hostname, so use the pathname. We could use just the
  // filename, but hopefully using the full path will prevent potential
  // issues where the same filename exists in multiple directories.
  dummyAnchor.href = url;
  source = dummyAnchor.pathname.substr(1);
}
map.sources = [source];
map.sourcesContent = [code];

return (
  transformed.code +
  &#39;\n//# sourceMappingURL=data:application/json;base64,&#39; +
  buffer.Buffer(JSON.stringify(map)).toString(&#39;base64&#39;)
);</pre>

<p>}</p>

<p>/**</p>

<pre> Appends a script element at the end of the &lt;head&gt; with the content of code,
 after transforming it.

 @param {string} code The original source code
 @param {string?} url Where the code came from. null if inline
 @param {object?} options Options to pass to jstransform
 @internal
/</pre>

<p>function run(code, url, options) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">scriptEl</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">createElement</span>(<span class="ruby-string">&#39;script&#39;</span>);
<span class="ruby-identifier">scriptEl</span>.<span class="ruby-identifier">text</span> = <span class="ruby-identifier">transformCode</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">url</span>, <span class="ruby-identifier">options</span>);
<span class="ruby-identifier">headEl</span>.<span class="ruby-identifier">appendChild</span>(<span class="ruby-identifier">scriptEl</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> Load script from the provided url and pass the content to the callback.

 @param {string} url The location of the script src
 @param {function} callback Function to call with the content of url
 @internal
/</pre>

<p>function load(url, successCallback, errorCallback) {</p>

<pre>var xhr;
xhr = window.ActiveXObject ? new window.ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
                           : new XMLHttpRequest();

// async, however scripts will be executed in the order they are in the
// DOM to mirror normal script loading.
xhr.open(&#39;GET&#39;, url, true);
if (&#39;overrideMimeType&#39; in xhr) {
  xhr.overrideMimeType(&#39;text/plain&#39;);
}
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if (xhr.status === 0 || xhr.status === 200) {
      successCallback(xhr.responseText);
    } else {
      errorCallback();
      throw new Error(&quot;Could not load &quot; + url);
    }
  }
};
return xhr.send(null);</pre>

<p>}</p>

<p>/**</p>

<pre> Loop over provided script tags and get the content, via innerHTML if an
 inline script, or by using XHR. Transforms are applied if needed. The scripts
 are executed in the order they are found on the page.

 @param {array} scripts The &lt;script&gt; elements to load and run.
 @internal
/</pre>

<p>function loadScripts(scripts) {</p>

<pre>var result = [];
var count = scripts.length;

function check() {
  var script, i;

  for (i = 0; i &lt; count; i++) {
    script = result[i];

    if (script.loaded &amp;&amp; !script.executed) {
      script.executed = true;
      run(script.content, script.url, script.options);
    } else if (!script.loaded &amp;&amp; !script.error &amp;&amp; !script.async) {
      break;
    }
  }
}

scripts.forEach(function(script, i) {
  var options = {
    sourceMap: true
  };
  if (/;harmony=true(;|$)/.test(script.type)) {
    options.harmony = true
  }
  if (/;stripTypes=true(;|$)/.test(script.type)) {
    options.stripTypes = true;
  }

  // script.async is always true for non-javascript script tags
  var async = script.hasAttribute(&#39;async&#39;);

  if (script.src) {
    result[i] = {
      async: async,
      error: false,
      executed: false,
      content: null,
      loaded: false,
      url: script.src,
      options: options
    };

    load(script.src, function(content) {
      result[i].loaded = true;
      result[i].content = content;
      check();
    }, function() {
      result[i].error = true;
      check();
    });
  } else {
    result[i] = {
      async: async,
      error: false,
      executed: false,
      content: script.innerHTML,
      loaded: true,
      url: null,
      options: options
    };
  }
});

check();</pre>

<p>}</p>

<p>/**</p>

<pre> Find and run all script tags with type=&quot;text/jsx&quot;.

 @internal
/</pre>

<p>function runScripts() {</p>

<pre>var scripts = document.getElementsByTagName(&#39;script&#39;);

// Array.prototype.slice cannot be used on NodeList on IE8
var jsxScripts = [];
for (var i = 0; i &lt; scripts.length; i++) {
  if (/^text\/jsx(;|$)/.test(scripts.item(i).type)) {
    jsxScripts.push(scripts.item(i));
  }
}

if (jsxScripts.length &lt; 1) {
  return;
}

console.warn(
  &#39;You are using the in-browser JSX transformer. Be sure to precompile &#39; +
  &#39;your JSX for production - &#39; +
  &#39;http://facebook.github.io/react/docs/tooling-integration.html#jsx&#39;
);

loadScripts(jsxScripts);</pre>

<p>}</p>

<p>// Listen for load event if we&#39;re in a browser and then kick off
finding and // running of scripts. if (typeof window !== “undefined”
&amp;&amp; window !== null) {</p>

<pre>headEl = document.getElementsByTagName(&#39;head&#39;)[0];
dummyAnchor = document.createElement(&#39;a&#39;);

if (window.addEventListener) {
  window.addEventListener(&#39;DOMContentLoaded&#39;, runScripts, false);
} else {
  window.attachEvent(&#39;onload&#39;, runScripts);
}</pre>

<p>}</p>

<p>module.exports = {</p>

<pre>transform: transformReact,
exec: exec</pre>

<p>};</p>

<p>},{“./fbtransform/visitors”:37,“buffer”:2,“jstransform”:21,“jstransform/visitors/type-syntax”:33}],2:[function(<em>dereq</em>,module,exports){
/*!</p>

<pre> The buffer module from node.js, for the browser.

 @author   Feross Aboukhadijeh &lt;feross@feross.org&gt; &lt;http://feross.org&gt;
 @license  MIT
/</pre>

<p>var base64 = <em>dereq</em>(&#39;base64-js&#39;) var ieee754 =
<em>dereq</em>(&#39;ieee754&#39;) var isArray =
<em>dereq</em>(&#39;is-array&#39;)</p>

<p>exports.Buffer = Buffer exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50 Buffer.poolSize = 8192 // not used by this
implementation</p>

<p>var kMaxLength = 0x3fffffff</p>

<p>/**</p>

<pre> If `Buffer.TYPED_ARRAY_SUPPORT`:
   === true    Use Uint8Array implementation (fastest)
   === false   Use Object implementation (most compatible, even IE6)

 Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 Opera 11.6+, iOS 4.2+.

 Note:

 - Implementation must support adding new properties to `Uint8Array` instances.
   Firefox 4-29 lacked support, fixed in Firefox 30+.
   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.

  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.

  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
    incorrect length in some situations.

 We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 get the Object implementation, which is slower but will work correctly.
/</pre>

<p>Buffer.TYPED_ARRAY_SUPPORT = (function () {</p>

<pre>try {
  var buf = new ArrayBuffer(0)
  var arr = new Uint8Array(buf)
  arr.foo = function () { return 42 }
  return 42 === arr.foo() &amp;&amp; // typed array instances can be augmented
      typeof arr.subarray === &#39;function&#39; &amp;&amp; // chrome 9-10 lack `subarray`
      new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
} catch (e) {
  return false
}</pre>

<p>})()</p>

<p>/**</p>

<pre> Class: Buffer
 =============

 The Buffer constructor returns instances of `Uint8Array` that are augmented
 with function properties for all the node `Buffer` API functions. We use
 `Uint8Array` so that square bracket notation works as expected -- it returns
 a single octet.

 By augmenting the instances, we can avoid modifying the `Uint8Array`
 prototype.
/</pre>

<p>function Buffer (subject, encoding, noZero) {</p>

<pre>if (!(this instanceof Buffer))
  return new Buffer(subject, encoding, noZero)

var type = typeof subject

// Find the length
var length
if (type === &#39;number&#39;)
  length = subject &gt; 0 ? subject &gt;&gt;&gt; 0 : 0
else if (type === &#39;string&#39;) {
  if (encoding === &#39;base64&#39;)
    subject = base64clean(subject)
  length = Buffer.byteLength(subject, encoding)
} else if (type === &#39;object&#39; &amp;&amp; subject !== null) { // assume object is array-like
  if (subject.type === &#39;Buffer&#39; &amp;&amp; isArray(subject.data))
    subject = subject.data
  length = +subject.length &gt; 0 ? Math.floor(+subject.length) : 0
} else
  throw new TypeError(&#39;must start with number, buffer, array or string&#39;)

if (this.length &gt; kMaxLength)
  throw new RangeError(&#39;Attempt to allocate Buffer larger than maximum &#39; +
    &#39;size: 0x&#39; + kMaxLength.toString(16) + &#39; bytes&#39;)

var buf
if (Buffer.TYPED_ARRAY_SUPPORT) {
  // Preferred: Return an augmented `Uint8Array` instance for best performance
  buf = Buffer._augment(new Uint8Array(length))
} else {
  // Fallback: Return THIS instance of Buffer (created by `new`)
  buf = this
  buf.length = length
  buf._isBuffer = true
}

var i
if (Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; typeof subject.byteLength === &#39;number&#39;) {
  // Speed optimization -- use set if we&#39;re copying from a typed array
  buf._set(subject)
} else if (isArrayish(subject)) {
  // Treat array-ish objects as a byte array
  if (Buffer.isBuffer(subject)) {
    for (i = 0; i &lt; length; i++)
      buf[i] = subject.readUInt8(i)
  } else {
    for (i = 0; i &lt; length; i++)
      buf[i] = ((subject[i] % 256) + 256) % 256
  }
} else if (type === &#39;string&#39;) {
  buf.write(subject, 0, encoding)
} else if (type === &#39;number&#39; &amp;&amp; !Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; !noZero) {
  for (i = 0; i &lt; length; i++) {
    buf[i] = 0
  }
}

return buf</pre>

<p>}</p>

<p>Buffer.isBuffer = function (b) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span>(<span class="ruby-identifier">b</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">_isBuffer</span>)
</pre>

<p>}</p>

<p>Buffer.compare = function (a, b) {</p>

<pre>if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
  throw new TypeError(&#39;Arguments must be Buffers&#39;)

var x = a.length
var y = b.length
for (var i = 0, len = Math.min(x, y); i &lt; len &amp;&amp; a[i] === b[i]; i++) {}
if (i !== len) {
  x = a[i]
  y = b[i]
}
if (x &lt; y) return -1
if (y &lt; x) return 1
return 0</pre>

<p>}</p>

<p>Buffer.isEncoding = function (encoding) {</p>

<pre>switch (String(encoding).toLowerCase()) {
  case &#39;hex&#39;:
  case &#39;utf8&#39;:
  case &#39;utf-8&#39;:
  case &#39;ascii&#39;:
  case &#39;binary&#39;:
  case &#39;base64&#39;:
  case &#39;raw&#39;:
  case &#39;ucs2&#39;:
  case &#39;ucs-2&#39;:
  case &#39;utf16le&#39;:
  case &#39;utf-16le&#39;:
    return true
  default:
    return false
}</pre>

<p>}</p>

<p>Buffer.concat = function (list, totalLength) {</p>

<pre>if (!isArray(list)) throw new TypeError(&#39;Usage: Buffer.concat(list[, length])&#39;)

if (list.length === 0) {
  return new Buffer(0)
} else if (list.length === 1) {
  return list[0]
}

var i
if (totalLength === undefined) {
  totalLength = 0
  for (i = 0; i &lt; list.length; i++) {
    totalLength += list[i].length
  }
}

var buf = new Buffer(totalLength)
var pos = 0
for (i = 0; i &lt; list.length; i++) {
  var item = list[i]
  item.copy(buf, pos)
  pos += item.length
}
return buf</pre>

<p>}</p>

<p>Buffer.byteLength = function (str, encoding) {</p>

<pre>var ret
str = str + &#39;&#39;
switch (encoding || &#39;utf8&#39;) {
  case &#39;ascii&#39;:
  case &#39;binary&#39;:
  case &#39;raw&#39;:
    ret = str.length
    break
  case &#39;ucs2&#39;:
  case &#39;ucs-2&#39;:
  case &#39;utf16le&#39;:
  case &#39;utf-16le&#39;:
    ret = str.length * 2
    break
  case &#39;hex&#39;:
    ret = str.length &gt;&gt;&gt; 1
    break
  case &#39;utf8&#39;:
  case &#39;utf-8&#39;:
    ret = utf8ToBytes(str).length
    break
  case &#39;base64&#39;:
    ret = base64ToBytes(str).length
    break
  default:
    ret = str.length
}
return ret</pre>

<p>}</p>

<p>// pre-set for values that may exist in the future Buffer.prototype.length
= undefined Buffer.prototype.parent = undefined</p>

<p>// toString(encoding, start=0, end=buffer.length) Buffer.prototype.toString
= function (encoding, start, end) {</p>

<pre>var loweredCase = false

start = start &gt;&gt;&gt; 0
end = end === undefined || end === Infinity ? this.length : end &gt;&gt;&gt; 0

if (!encoding) encoding = &#39;utf8&#39;
if (start &lt; 0) start = 0
if (end &gt; this.length) end = this.length
if (end &lt;= start) return &#39;&#39;

while (true) {
  switch (encoding) {
    case &#39;hex&#39;:
      return hexSlice(this, start, end)

    case &#39;utf8&#39;:
    case &#39;utf-8&#39;:
      return utf8Slice(this, start, end)

    case &#39;ascii&#39;:
      return asciiSlice(this, start, end)

    case &#39;binary&#39;:
      return binarySlice(this, start, end)

    case &#39;base64&#39;:
      return base64Slice(this, start, end)

    case &#39;ucs2&#39;:
    case &#39;ucs-2&#39;:
    case &#39;utf16le&#39;:
    case &#39;utf-16le&#39;:
      return utf16leSlice(this, start, end)

    default:
      if (loweredCase)
        throw new TypeError(&#39;Unknown encoding: &#39; + encoding)
      encoding = (encoding + &#39;&#39;).toLowerCase()
      loweredCase = true
  }
}</pre>

<p>}</p>

<p>Buffer.prototype.equals = function (b) {</p>

<pre>if(!Buffer.isBuffer(b)) throw new TypeError(&#39;Argument must be a Buffer&#39;)
return Buffer.compare(this, b) === 0</pre>

<p>}</p>

<p>Buffer.prototype.inspect = function () {</p>

<pre>var str = &#39;&#39;
var max = exports.INSPECT_MAX_BYTES
if (this.length &gt; 0) {
  str = this.toString(&#39;hex&#39;, 0, max).match(/.{2}/g).join(&#39; &#39;)
  if (this.length &gt; max)
    str += &#39; ... &#39;
}
return &#39;&lt;Buffer &#39; + str + &#39;&gt;&#39;</pre>

<p>}</p>

<p>Buffer.prototype.compare = function (b) {</p>

<pre>if (!Buffer.isBuffer(b)) throw new TypeError(&#39;Argument must be a Buffer&#39;)
return Buffer.compare(this, b)</pre>

<p>}</p>

<p>// `get` will be removed in Node 0.13+ Buffer.prototype.get = function
(offset) {</p>

<pre class="ruby"><span class="ruby-identifier">console</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&#39;.get() is deprecated. Access using array indexes instead.&#39;</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">readUInt8</span>(<span class="ruby-identifier">offset</span>)
</pre>

<p>}</p>

<p>// `set` will be removed in Node 0.13+ Buffer.prototype.set = function (v,
offset) {</p>

<pre class="ruby"><span class="ruby-identifier">console</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&#39;.set() is deprecated. Access using array indexes instead.&#39;</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">writeUInt8</span>(<span class="ruby-identifier">v</span>, <span class="ruby-identifier">offset</span>)
</pre>

<p>}</p>

<p>function hexWrite (buf, string, offset, length) {</p>

<pre>offset = Number(offset) || 0
var remaining = buf.length - offset
if (!length) {
  length = remaining
} else {
  length = Number(length)
  if (length &gt; remaining) {
    length = remaining
  }
}

// must be an even number of digits
var strLen = string.length
if (strLen % 2 !== 0) throw new Error(&#39;Invalid hex string&#39;)

if (length &gt; strLen / 2) {
  length = strLen / 2
}
for (var i = 0; i &lt; length; i++) {
  var byte = parseInt(string.substr(i * 2, 2), 16)
  if (isNaN(byte)) throw new Error(&#39;Invalid hex string&#39;)
  buf[offset + i] = byte
}
return i</pre>

<p>}</p>

<p>function utf8Write (buf, string, offset, length) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">charsWritten</span> = <span class="ruby-identifier">blitBuffer</span>(<span class="ruby-identifier">utf8ToBytes</span>(<span class="ruby-identifier">string</span>), <span class="ruby-identifier">buf</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">length</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">charsWritten</span>
</pre>

<p>}</p>

<p>function asciiWrite (buf, string, offset, length) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">charsWritten</span> = <span class="ruby-identifier">blitBuffer</span>(<span class="ruby-identifier">asciiToBytes</span>(<span class="ruby-identifier">string</span>), <span class="ruby-identifier">buf</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">length</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">charsWritten</span>
</pre>

<p>}</p>

<p>function binaryWrite (buf, string, offset, length) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">asciiWrite</span>(<span class="ruby-identifier">buf</span>, <span class="ruby-identifier">string</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">length</span>)
</pre>

<p>}</p>

<p>function base64Write (buf, string, offset, length) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">charsWritten</span> = <span class="ruby-identifier">blitBuffer</span>(<span class="ruby-identifier">base64ToBytes</span>(<span class="ruby-identifier">string</span>), <span class="ruby-identifier">buf</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">length</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">charsWritten</span>
</pre>

<p>}</p>

<p>function utf16leWrite (buf, string, offset, length) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">charsWritten</span> = <span class="ruby-identifier">blitBuffer</span>(<span class="ruby-identifier">utf16leToBytes</span>(<span class="ruby-identifier">string</span>), <span class="ruby-identifier">buf</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">length</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">charsWritten</span>
</pre>

<p>}</p>

<p>Buffer.prototype.write = function (string, offset, length, encoding) {</p>

<pre>// Support both (string, offset, length, encoding)
// and the legacy (string, encoding, offset, length)
if (isFinite(offset)) {
  if (!isFinite(length)) {
    encoding = length
    length = undefined
  }
} else {  // legacy
  var swap = encoding
  encoding = offset
  offset = length
  length = swap
}

offset = Number(offset) || 0
var remaining = this.length - offset
if (!length) {
  length = remaining
} else {
  length = Number(length)
  if (length &gt; remaining) {
    length = remaining
  }
}
encoding = String(encoding || &#39;utf8&#39;).toLowerCase()

var ret
switch (encoding) {
  case &#39;hex&#39;:
    ret = hexWrite(this, string, offset, length)
    break
  case &#39;utf8&#39;:
  case &#39;utf-8&#39;:
    ret = utf8Write(this, string, offset, length)
    break
  case &#39;ascii&#39;:
    ret = asciiWrite(this, string, offset, length)
    break
  case &#39;binary&#39;:
    ret = binaryWrite(this, string, offset, length)
    break
  case &#39;base64&#39;:
    ret = base64Write(this, string, offset, length)
    break
  case &#39;ucs2&#39;:
  case &#39;ucs-2&#39;:
  case &#39;utf16le&#39;:
  case &#39;utf-16le&#39;:
    ret = utf16leWrite(this, string, offset, length)
    break
  default:
    throw new TypeError(&#39;Unknown encoding: &#39; + encoding)
}
return ret</pre>

<p>}</p>

<p>Buffer.prototype.toJSON = function () {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
  <span class="ruby-identifier">type</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Buffer&#39;</span>,
  <span class="ruby-identifier">data</span><span class="ruby-operator">:</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_arr</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>, <span class="ruby-value">0</span>)
}
</pre>

<p>}</p>

<p>function base64Slice (buf, start, end) {</p>

<pre>if (start === 0 &amp;&amp; end === buf.length) {
  return base64.fromByteArray(buf)
} else {
  return base64.fromByteArray(buf.slice(start, end))
}</pre>

<p>}</p>

<p>function utf8Slice (buf, start, end) {</p>

<pre>var res = &#39;&#39;
var tmp = &#39;&#39;
end = Math.min(buf.length, end)

for (var i = start; i &lt; end; i++) {
  if (buf[i] &lt;= 0x7F) {
    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
    tmp = &#39;&#39;
  } else {
    tmp += &#39;%&#39; + buf[i].toString(16)
  }
}

return res + decodeUtf8Char(tmp)</pre>

<p>}</p>

<p>function asciiSlice (buf, start, end) {</p>

<pre>var ret = &#39;&#39;
end = Math.min(buf.length, end)

for (var i = start; i &lt; end; i++) {
  ret += String.fromCharCode(buf[i])
}
return ret</pre>

<p>}</p>

<p>function binarySlice (buf, start, end) {</p>

<pre>return asciiSlice(buf, start, end)</pre>

<p>}</p>

<p>function hexSlice (buf, start, end) {</p>

<pre>var len = buf.length

if (!start || start &lt; 0) start = 0
if (!end || end &lt; 0 || end &gt; len) end = len

var out = &#39;&#39;
for (var i = start; i &lt; end; i++) {
  out += toHex(buf[i])
}
return out</pre>

<p>}</p>

<p>function utf16leSlice (buf, start, end) {</p>

<pre>var bytes = buf.slice(start, end)
var res = &#39;&#39;
for (var i = 0; i &lt; bytes.length; i += 2) {
  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
}
return res</pre>

<p>}</p>

<p>Buffer.prototype.slice = function (start, end) {</p>

<pre>var len = this.length
start = ~~start
end = end === undefined ? len : ~~end

if (start &lt; 0) {
  start += len;
  if (start &lt; 0)
    start = 0
} else if (start &gt; len) {
  start = len
}

if (end &lt; 0) {
  end += len
  if (end &lt; 0)
    end = 0
} else if (end &gt; len) {
  end = len
}

if (end &lt; start)
  end = start

if (Buffer.TYPED_ARRAY_SUPPORT) {
  return Buffer._augment(this.subarray(start, end))
} else {
  var sliceLen = end - start
  var newBuf = new Buffer(sliceLen, undefined, true)
  for (var i = 0; i &lt; sliceLen; i++) {
    newBuf[i] = this[i + start]
  }
  return newBuf
}</pre>

<p>}</p>

<p>/*</p>

<pre> Need to make sure that buffer isn&#39;t trying to write out of bounds.
/</pre>

<p>function checkOffset (offset, ext, length) {</p>

<pre>if ((offset % 1) !== 0 || offset &lt; 0)
  throw new RangeError(&#39;offset is not uint&#39;)
if (offset + ext &gt; length)
  throw new RangeError(&#39;Trying to access beyond buffer length&#39;)</pre>

<p>}</p>

<p>Buffer.prototype.readUInt8 = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 1, this.length)
return this[offset]</pre>

<p>}</p>

<p>Buffer.prototype.readUInt16LE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 2, this.length)
return this[offset] | (this[offset + 1] &lt;&lt; 8)</pre>

<p>}</p>

<p>Buffer.prototype.readUInt16BE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 2, this.length)
return (this[offset] &lt;&lt; 8) | this[offset + 1]</pre>

<p>}</p>

<p>Buffer.prototype.readUInt32LE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)

return ((this[offset]) |
    (this[offset + 1] &lt;&lt; 8) |
    (this[offset + 2] &lt;&lt; 16)) +
    (this[offset + 3] * 0x1000000)</pre>

<p>}</p>

<p>Buffer.prototype.readUInt32BE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)

return (this[offset] * 0x1000000) +
    ((this[offset + 1] &lt;&lt; 16) |
    (this[offset + 2] &lt;&lt; 8) |
    this[offset + 3])</pre>

<p>}</p>

<p>Buffer.prototype.readInt8 = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 1, this.length)
if (!(this[offset] &amp; 0x80))
  return (this[offset])
return ((0xff - this[offset] + 1) * -1)</pre>

<p>}</p>

<p>Buffer.prototype.readInt16LE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 2, this.length)
var val = this[offset] | (this[offset + 1] &lt;&lt; 8)
return (val &amp; 0x8000) ? val | 0xFFFF0000 : val</pre>

<p>}</p>

<p>Buffer.prototype.readInt16BE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 2, this.length)
var val = this[offset + 1] | (this[offset] &lt;&lt; 8)
return (val &amp; 0x8000) ? val | 0xFFFF0000 : val</pre>

<p>}</p>

<p>Buffer.prototype.readInt32LE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)

return (this[offset]) |
    (this[offset + 1] &lt;&lt; 8) |
    (this[offset + 2] &lt;&lt; 16) |
    (this[offset + 3] &lt;&lt; 24)</pre>

<p>}</p>

<p>Buffer.prototype.readInt32BE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)

return (this[offset] &lt;&lt; 24) |
    (this[offset + 1] &lt;&lt; 16) |
    (this[offset + 2] &lt;&lt; 8) |
    (this[offset + 3])</pre>

<p>}</p>

<p>Buffer.prototype.readFloatLE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)
return ieee754.read(this, offset, true, 23, 4)</pre>

<p>}</p>

<p>Buffer.prototype.readFloatBE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 4, this.length)
return ieee754.read(this, offset, false, 23, 4)</pre>

<p>}</p>

<p>Buffer.prototype.readDoubleLE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 8, this.length)
return ieee754.read(this, offset, true, 52, 8)</pre>

<p>}</p>

<p>Buffer.prototype.readDoubleBE = function (offset, noAssert) {</p>

<pre>if (!noAssert)
  checkOffset(offset, 8, this.length)
return ieee754.read(this, offset, false, 52, 8)</pre>

<p>}</p>

<p>function checkInt (buf, value, offset, ext, max, min) {</p>

<pre>if (!Buffer.isBuffer(buf)) throw new TypeError(&#39;buffer must be a Buffer instance&#39;)
if (value &gt; max || value &lt; min) throw new TypeError(&#39;value is out of bounds&#39;)
if (offset + ext &gt; buf.length) throw new TypeError(&#39;index out of range&#39;)</pre>

<p>}</p>

<p>Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 1, 0xff, 0)
if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
this[offset] = value
return offset + 1</pre>

<p>}</p>

<p>function objectWriteUInt16 (buf, value, offset, littleEndian) {</p>

<pre>if (value &lt; 0) value = 0xffff + value + 1
for (var i = 0, j = Math.min(buf.length - offset, 2); i &lt; j; i++) {
  buf[offset + i] = (value &amp; (0xff &lt;&lt; (8 * (littleEndian ? i : 1 - i)))) &gt;&gt;&gt;
    (littleEndian ? i : 1 - i) * 8
}</pre>

<p>}</p>

<p>Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 2, 0xffff, 0)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = value
  this[offset + 1] = (value &gt;&gt;&gt; 8)
} else objectWriteUInt16(this, value, offset, true)
return offset + 2</pre>

<p>}</p>

<p>Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 2, 0xffff, 0)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = (value &gt;&gt;&gt; 8)
  this[offset + 1] = value
} else objectWriteUInt16(this, value, offset, false)
return offset + 2</pre>

<p>}</p>

<p>function objectWriteUInt32 (buf, value, offset, littleEndian) {</p>

<pre>if (value &lt; 0) value = 0xffffffff + value + 1
for (var i = 0, j = Math.min(buf.length - offset, 4); i &lt; j; i++) {
  buf[offset + i] = (value &gt;&gt;&gt; (littleEndian ? i : 3 - i) * 8) &amp; 0xff
}</pre>

<p>}</p>

<p>Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 4, 0xffffffff, 0)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset + 3] = (value &gt;&gt;&gt; 24)
  this[offset + 2] = (value &gt;&gt;&gt; 16)
  this[offset + 1] = (value &gt;&gt;&gt; 8)
  this[offset] = value
} else objectWriteUInt32(this, value, offset, true)
return offset + 4</pre>

<p>}</p>

<p>Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 4, 0xffffffff, 0)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = (value &gt;&gt;&gt; 24)
  this[offset + 1] = (value &gt;&gt;&gt; 16)
  this[offset + 2] = (value &gt;&gt;&gt; 8)
  this[offset + 3] = value
} else objectWriteUInt32(this, value, offset, false)
return offset + 4</pre>

<p>}</p>

<p>Buffer.prototype.writeInt8 = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 1, 0x7f, -0x80)
if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
if (value &lt; 0) value = 0xff + value + 1
this[offset] = value
return offset + 1</pre>

<p>}</p>

<p>Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 2, 0x7fff, -0x8000)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = value
  this[offset + 1] = (value &gt;&gt;&gt; 8)
} else objectWriteUInt16(this, value, offset, true)
return offset + 2</pre>

<p>}</p>

<p>Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 2, 0x7fff, -0x8000)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = (value &gt;&gt;&gt; 8)
  this[offset + 1] = value
} else objectWriteUInt16(this, value, offset, false)
return offset + 2</pre>

<p>}</p>

<p>Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = value
  this[offset + 1] = (value &gt;&gt;&gt; 8)
  this[offset + 2] = (value &gt;&gt;&gt; 16)
  this[offset + 3] = (value &gt;&gt;&gt; 24)
} else objectWriteUInt32(this, value, offset, true)
return offset + 4</pre>

<p>}</p>

<p>Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {</p>

<pre>value = +value
offset = offset &gt;&gt;&gt; 0
if (!noAssert)
  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
if (value &lt; 0) value = 0xffffffff + value + 1
if (Buffer.TYPED_ARRAY_SUPPORT) {
  this[offset] = (value &gt;&gt;&gt; 24)
  this[offset + 1] = (value &gt;&gt;&gt; 16)
  this[offset + 2] = (value &gt;&gt;&gt; 8)
  this[offset + 3] = value
} else objectWriteUInt32(this, value, offset, false)
return offset + 4</pre>

<p>}</p>

<p>function checkIEEE754 (buf, value, offset, ext, max, min) {</p>

<pre>if (value &gt; max || value &lt; min) throw new TypeError(&#39;value is out of bounds&#39;)
if (offset + ext &gt; buf.length) throw new TypeError(&#39;index out of range&#39;)</pre>

<p>}</p>

<p>function writeFloat (buf, value, offset, littleEndian, noAssert) {</p>

<pre>if (!noAssert)
  checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
ieee754.write(buf, value, offset, littleEndian, 23, 4)
return offset + 4</pre>

<p>}</p>

<p>Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">writeFloat</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-keyword">true</span>, <span class="ruby-identifier">noAssert</span>)
</pre>

<p>}</p>

<p>Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">writeFloat</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-keyword">false</span>, <span class="ruby-identifier">noAssert</span>)
</pre>

<p>}</p>

<p>function writeDouble (buf, value, offset, littleEndian, noAssert) {</p>

<pre>if (!noAssert)
  checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
ieee754.write(buf, value, offset, littleEndian, 52, 8)
return offset + 8</pre>

<p>}</p>

<p>Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">writeDouble</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-keyword">true</span>, <span class="ruby-identifier">noAssert</span>)
</pre>

<p>}</p>

<p>Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">writeDouble</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-keyword">false</span>, <span class="ruby-identifier">noAssert</span>)
</pre>

<p>}</p>

<p>// copy(targetBuffer, targetStart=0, sourceStart=0,
sourceEnd=buffer.length) Buffer.prototype.copy = function (target,
target_start, start, end) {</p>

<pre>var source = this

if (!start) start = 0
if (!end &amp;&amp; end !== 0) end = this.length
if (!target_start) target_start = 0

// Copy 0 bytes; we&#39;re done
if (end === start) return
if (target.length === 0 || source.length === 0) return

// Fatal error conditions
if (end &lt; start) throw new TypeError(&#39;sourceEnd &lt; sourceStart&#39;)
if (target_start &lt; 0 || target_start &gt;= target.length)
  throw new TypeError(&#39;targetStart out of bounds&#39;)
if (start &lt; 0 || start &gt;= source.length) throw new TypeError(&#39;sourceStart out of bounds&#39;)
if (end &lt; 0 || end &gt; source.length) throw new TypeError(&#39;sourceEnd out of bounds&#39;)

// Are we oob?
if (end &gt; this.length)
  end = this.length
if (target.length - target_start &lt; end - start)
  end = target.length - target_start + start

var len = end - start

if (len &lt; 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
  for (var i = 0; i &lt; len; i++) {
    target[i + target_start] = this[i + start]
  }
} else {
  target._set(this.subarray(start, start + len), target_start)
}</pre>

<p>}</p>

<p>// fill(value, start=0, end=buffer.length) Buffer.prototype.fill = function
(value, start, end) {</p>

<pre>if (!value) value = 0
if (!start) start = 0
if (!end) end = this.length

if (end &lt; start) throw new TypeError(&#39;end &lt; start&#39;)

// Fill 0 bytes; we&#39;re done
if (end === start) return
if (this.length === 0) return

if (start &lt; 0 || start &gt;= this.length) throw new TypeError(&#39;start out of bounds&#39;)
if (end &lt; 0 || end &gt; this.length) throw new TypeError(&#39;end out of bounds&#39;)

var i
if (typeof value === &#39;number&#39;) {
  for (i = start; i &lt; end; i++) {
    this[i] = value
  }
} else {
  var bytes = utf8ToBytes(value.toString())
  var len = bytes.length
  for (i = start; i &lt; end; i++) {
    this[i] = bytes[i % len]
  }
}

return this</pre>

<p>}</p>

<p>/**</p>

<pre> Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 Added in Node 0.12. Only available in browsers that support ArrayBuffer.
/</pre>

<p>Buffer.prototype.toArrayBuffer = function () {</p>

<pre>if (typeof Uint8Array !== &#39;undefined&#39;) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return (new Buffer(this)).buffer
  } else {
    var buf = new Uint8Array(this.length)
    for (var i = 0, len = buf.length; i &lt; len; i += 1) {
      buf[i] = this[i]
    }
    return buf.buffer
  }
} else {
  throw new TypeError(&#39;Buffer.toArrayBuffer not supported in this browser&#39;)
}</pre>

<p>}</p>

<p>// HELPER FUNCTIONS // ================</p>

<p>var BP = Buffer.prototype</p>

<p>/**</p>

<pre> Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
/</pre>

<p>Buffer._augment = function (arr) {</p>

<pre>arr.constructor = Buffer
arr._isBuffer = true

// save reference to original Uint8Array get/set methods before overwriting
arr._get = arr.get
arr._set = arr.set

// deprecated, will be removed in node 0.13+
arr.get = BP.get
arr.set = BP.set

arr.write = BP.write
arr.toString = BP.toString
arr.toLocaleString = BP.toString
arr.toJSON = BP.toJSON
arr.equals = BP.equals
arr.compare = BP.compare
arr.copy = BP.copy
arr.slice = BP.slice
arr.readUInt8 = BP.readUInt8
arr.readUInt16LE = BP.readUInt16LE
arr.readUInt16BE = BP.readUInt16BE
arr.readUInt32LE = BP.readUInt32LE
arr.readUInt32BE = BP.readUInt32BE
arr.readInt8 = BP.readInt8
arr.readInt16LE = BP.readInt16LE
arr.readInt16BE = BP.readInt16BE
arr.readInt32LE = BP.readInt32LE
arr.readInt32BE = BP.readInt32BE
arr.readFloatLE = BP.readFloatLE
arr.readFloatBE = BP.readFloatBE
arr.readDoubleLE = BP.readDoubleLE
arr.readDoubleBE = BP.readDoubleBE
arr.writeUInt8 = BP.writeUInt8
arr.writeUInt16LE = BP.writeUInt16LE
arr.writeUInt16BE = BP.writeUInt16BE
arr.writeUInt32LE = BP.writeUInt32LE
arr.writeUInt32BE = BP.writeUInt32BE
arr.writeInt8 = BP.writeInt8
arr.writeInt16LE = BP.writeInt16LE
arr.writeInt16BE = BP.writeInt16BE
arr.writeInt32LE = BP.writeInt32LE
arr.writeInt32BE = BP.writeInt32BE
arr.writeFloatLE = BP.writeFloatLE
arr.writeFloatBE = BP.writeFloatBE
arr.writeDoubleLE = BP.writeDoubleLE
arr.writeDoubleBE = BP.writeDoubleBE
arr.fill = BP.fill
arr.inspect = BP.inspect
arr.toArrayBuffer = BP.toArrayBuffer

return arr</pre>

<p>}</p>

<p>var INVALID_BASE64_RE = /[^+/0-9A-z]/g</p>

<p>function base64clean (str) {</p>

<pre>// Node strips out invalid characters like \n and \t from the string, base64-js does not
str = stringtrim(str).replace(INVALID_BASE64_RE, &#39;&#39;)
// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while (str.length % 4 !== 0) {
  str = str + &#39;=&#39;
}
return str</pre>

<p>}</p>

<p>function stringtrim (str) {</p>

<pre>if (str.trim) return str.trim()
return str.replace(/^\s+|\s+$/g, &#39;&#39;)</pre>

<p>}</p>

<p>function isArrayish (subject) {</p>

<pre>return isArray(subject) || Buffer.isBuffer(subject) ||
    subject &amp;&amp; typeof subject === &#39;object&#39; &amp;&amp;
    typeof subject.length === &#39;number&#39;</pre>

<p>}</p>

<p>function toHex (n) {</p>

<pre>if (n &lt; 16) return &#39;0&#39; + n.toString(16)
return n.toString(16)</pre>

<p>}</p>

<p>function utf8ToBytes (str) {</p>

<pre>var byteArray = []
for (var i = 0; i &lt; str.length; i++) {
  var b = str.charCodeAt(i)
  if (b &lt;= 0x7F) {
    byteArray.push(b)
  } else {
    var start = i
    if (b &gt;= 0xD800 &amp;&amp; b &lt;= 0xDFFF) i++
    var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split(&#39;%&#39;)
    for (var j = 0; j &lt; h.length; j++) {
      byteArray.push(parseInt(h[j], 16))
    }
  }
}
return byteArray</pre>

<p>}</p>

<p>function asciiToBytes (str) {</p>

<pre>var byteArray = []
for (var i = 0; i &lt; str.length; i++) {
  // Node&#39;s code seems to be doing this and not &amp; 0x7F..
  byteArray.push(str.charCodeAt(i) &amp; 0xFF)
}
return byteArray</pre>

<p>}</p>

<p>function utf16leToBytes (str) {</p>

<pre>var c, hi, lo
var byteArray = []
for (var i = 0; i &lt; str.length; i++) {
  c = str.charCodeAt(i)
  hi = c &gt;&gt; 8
  lo = c % 256
  byteArray.push(lo)
  byteArray.push(hi)
}

return byteArray</pre>

<p>}</p>

<p>function base64ToBytes (str) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">base64</span>.<span class="ruby-identifier">toByteArray</span>(<span class="ruby-identifier">str</span>)
</pre>

<p>}</p>

<p>function blitBuffer (src, dst, offset, length) {</p>

<pre>for (var i = 0; i &lt; length; i++) {
  if ((i + offset &gt;= dst.length) || (i &gt;= src.length))
    break
  dst[i + offset] = src[i]
}
return i</pre>

<p>}</p>

<p>function decodeUtf8Char (str) {</p>

<pre>try {
  return decodeURIComponent(str)
} catch (err) {
  return String.fromCharCode(0xFFFD) // UTF 8 invalid char
}</pre>

<p>}</p>

<p>},{“base64-js”:3,“ieee754”:4,“is-array”:5}],3:[function(<em>dereq</em>,module,exports){
var lookup =
&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;;</p>

<p>;(function (exports) {</p>

<pre>      &#39;use strict&#39;;

var Arr = (typeof Uint8Array !== &#39;undefined&#39;)
  ? Uint8Array
  : Array

      var PLUS   = &#39;+&#39;.charCodeAt(0)
      var SLASH  = &#39;/&#39;.charCodeAt(0)
      var NUMBER = &#39;0&#39;.charCodeAt(0)
      var LOWER  = &#39;a&#39;.charCodeAt(0)
      var UPPER  = &#39;A&#39;.charCodeAt(0)

      function decode (elt) {
              var code = elt.charCodeAt(0)
              if (code === PLUS)
                      return 62 // &#39;+&#39;
              if (code === SLASH)
                      return 63 // &#39;/&#39;
              if (code &lt; NUMBER)
                      return -1 //no match
              if (code &lt; NUMBER + 10)
                      return code - NUMBER + 26 + 26
              if (code &lt; UPPER + 26)
                      return code - UPPER
              if (code &lt; LOWER + 26)
                      return code - LOWER + 26
      }

      function b64ToByteArray (b64) {
              var i, j, l, tmp, placeHolders, arr

              if (b64.length % 4 &gt; 0) {
                      throw new Error(&#39;Invalid string. Length must be a multiple of 4&#39;)
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              var len = b64.length
              placeHolders = &#39;=&#39; === b64.charAt(len - 2) ? 2 : &#39;=&#39; === b64.charAt(len - 1) ? 1 : 0

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr(b64.length * 3 / 4 - placeHolders)

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders &gt; 0 ? b64.length - 4 : b64.length

              var L = 0

              function push (v) {
                      arr[L++] = v
              }

              for (i = 0, j = 0; i &lt; l; i += 4, j += 3) {
                      tmp = (decode(b64.charAt(i)) &lt;&lt; 18) | (decode(b64.charAt(i + 1)) &lt;&lt; 12) | (decode(b64.charAt(i + 2)) &lt;&lt; 6) | decode(b64.charAt(i + 3))
                      push((tmp &amp; 0xFF0000) &gt;&gt; 16)
                      push((tmp &amp; 0xFF00) &gt;&gt; 8)
                      push(tmp &amp; 0xFF)
              }

              if (placeHolders === 2) {
                      tmp = (decode(b64.charAt(i)) &lt;&lt; 2) | (decode(b64.charAt(i + 1)) &gt;&gt; 4)
                      push(tmp &amp; 0xFF)
              } else if (placeHolders === 1) {
                      tmp = (decode(b64.charAt(i)) &lt;&lt; 10) | (decode(b64.charAt(i + 1)) &lt;&lt; 4) | (decode(b64.charAt(i + 2)) &gt;&gt; 2)
                      push((tmp &gt;&gt; 8) &amp; 0xFF)
                      push(tmp &amp; 0xFF)
              }

              return arr
      }

      function uint8ToBase64 (uint8) {
              var i,
                      extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                      output = &quot;&quot;,
                      temp, length

              function encode (num) {
                      return lookup.charAt(num)
              }

              function tripletToBase64 (num) {
                      return encode(num &gt;&gt; 18 &amp; 0x3F) + encode(num &gt;&gt; 12 &amp; 0x3F) + encode(num &gt;&gt; 6 &amp; 0x3F) + encode(num &amp; 0x3F)
              }

              // go through the array every three bytes, we&#39;ll deal with trailing stuff later
              for (i = 0, length = uint8.length - extraBytes; i &lt; length; i += 3) {
                      temp = (uint8[i] &lt;&lt; 16) + (uint8[i + 1] &lt;&lt; 8) + (uint8[i + 2])
                      output += tripletToBase64(temp)
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              switch (extraBytes) {
                      case 1:
                              temp = uint8[uint8.length - 1]
                              output += encode(temp &gt;&gt; 2)
                              output += encode((temp &lt;&lt; 4) &amp; 0x3F)
                              output += &#39;==&#39;
                              break
                      case 2:
                              temp = (uint8[uint8.length - 2] &lt;&lt; 8) + (uint8[uint8.length - 1])
                              output += encode(temp &gt;&gt; 10)
                              output += encode((temp &gt;&gt; 4) &amp; 0x3F)
                              output += encode((temp &lt;&lt; 2) &amp; 0x3F)
                              output += &#39;=&#39;
                              break
              }

              return output
      }

      exports.toByteArray = b64ToByteArray
      exports.fromByteArray = uint8ToBase64</pre>

<p>}(typeof exports === &#39;undefined&#39; ? (this.base64js = {}) : exports))</p>

<p>},{}],4:[function(<em>dereq</em>,module,exports){ exports.read =
function(buffer, offset, isLE, mLen, nBytes) {</p>

<pre>var e, m,
    eLen = nBytes * 8 - mLen - 1,
    eMax = (1 &lt;&lt; eLen) - 1,
    eBias = eMax &gt;&gt; 1,
    nBits = -7,
    i = isLE ? (nBytes - 1) : 0,
    d = isLE ? -1 : 1,
    s = buffer[offset + i];

i += d;

e = s &amp; ((1 &lt;&lt; (-nBits)) - 1);
s &gt;&gt;= (-nBits);
nBits += eLen;
for (; nBits &gt; 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

m = e &amp; ((1 &lt;&lt; (-nBits)) - 1);
e &gt;&gt;= (-nBits);
nBits += mLen;
for (; nBits &gt; 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

if (e === 0) {
  e = 1 - eBias;
} else if (e === eMax) {
  return m ? NaN : ((s ? -1 : 1) * Infinity);
} else {
  m = m + Math.pow(2, mLen);
  e = e - eBias;
}
return (s ? -1 : 1) * m * Math.pow(2, e - mLen);</pre>

<p>};</p>

<p>exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {</p>

<pre>var e, m, c,
    eLen = nBytes * 8 - mLen - 1,
    eMax = (1 &lt;&lt; eLen) - 1,
    eBias = eMax &gt;&gt; 1,
    rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
    i = isLE ? 0 : (nBytes - 1),
    d = isLE ? 1 : -1,
    s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0;

value = Math.abs(value);

if (isNaN(value) || value === Infinity) {
  m = isNaN(value) ? 1 : 0;
  e = eMax;
} else {
  e = Math.floor(Math.log(value) / Math.LN2);
  if (value * (c = Math.pow(2, -e)) &lt; 1) {
    e--;
    c *= 2;
  }
  if (e + eBias &gt;= 1) {
    value += rt / c;
  } else {
    value += rt * Math.pow(2, 1 - eBias);
  }
  if (value * c &gt;= 2) {
    e++;
    c /= 2;
  }

  if (e + eBias &gt;= eMax) {
    m = 0;
    e = eMax;
  } else if (e + eBias &gt;= 1) {
    m = (value * c - 1) * Math.pow(2, mLen);
    e = e + eBias;
  } else {
    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
    e = 0;
  }
}

for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8);

e = (e &lt;&lt; mLen) | m;
eLen += mLen;
for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8);

buffer[offset + i - d] |= s * 128;</pre>

<p>};</p>

<p>},{}],5:[function(<em>dereq</em>,module,exports){</p>

<p>/**</p>

<pre> isArray
/</pre>

<p>var isArray = Array.isArray;</p>

<p>/**</p>

<pre> toString
/</pre>

<p>var str = Object.prototype.toString;</p>

<p>/**</p>

<pre> Whether or not the given `val`
 is an array.

 example:

        isArray([]);
        // &gt; true
        isArray(arguments);
        // &gt; false
        isArray(&#39;&#39;);
        // &gt; false

 @param {mixed} val
 @return {bool}
/</pre>

<p>module.exports = isArray || function (val) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-string">&#39;[object Array]&#39;</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">val</span>);
</pre>

<p>};</p>

<p>},{}],6:[function(<em>dereq</em>,module,exports){ (function (process){ //
Copyright Joyent, Inc. and other Node contributors. // // Permission is
hereby granted, free of charge, to any person obtaining a // copy of this
software and associated documentation files (the // “Software”), to deal in
the Software without restriction, including // without limitation the
rights to use, copy, modify, merge, publish, // distribute, sublicense,
and/or sell copies of the Software, and to permit // persons to whom the
Software is furnished to do so, subject to the // following conditions: //
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software. // // THE
SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR
OTHER DEALINGS IN THE SOFTWARE.</p>

<p>// resolves . and .. elements in a path array with directory names there //
must be no slashes, empty elements, or device names (c:) in the array //
(so also no leading and trailing slashes - it does not distinguish //
relative and absolute paths) function normalizeArray(parts, allowAboveRoot)
{</p>

<pre>// if the path tries to go above the root, `up` ends up &gt; 0
var up = 0;
for (var i = parts.length - 1; i &gt;= 0; i--) {
  var last = parts[i];
  if (last === &#39;.&#39;) {
    parts.splice(i, 1);
  } else if (last === &#39;..&#39;) {
    parts.splice(i, 1);
    up++;
  } else if (up) {
    parts.splice(i, 1);
    up--;
  }
}

// if the path is allowed to go above the root, restore leading ..s
if (allowAboveRoot) {
  for (; up--; up) {
    parts.unshift(&#39;..&#39;);
  }
}

return parts;</pre>

<p>}</p>

<p>// Split a filename into [root, dir, basename, ext], unix version //
&#39;root&#39; is just a slash, or nothing. var splitPathRe =</p>

<pre class="ruby"><span class="ruby-regexp">/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/</span>;
</pre>

<p>var splitPath = function(filename) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">splitPathRe</span>.<span class="ruby-identifier">exec</span>(<span class="ruby-identifier">filename</span>).<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>);
</pre>

<p>};</p>

<p>// path.resolve([from …], to) // posix version exports.resolve = function()
{</p>

<pre>var resolvedPath = &#39;&#39;,
    resolvedAbsolute = false;

for (var i = arguments.length - 1; i &gt;= -1 &amp;&amp; !resolvedAbsolute; i--) {
  var path = (i &gt;= 0) ? arguments[i] : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== &#39;string&#39;) {
    throw new TypeError(&#39;Arguments to path.resolve must be strings&#39;);
  } else if (!path) {
    continue;
  }

  resolvedPath = path + &#39;/&#39; + resolvedPath;
  resolvedAbsolute = path.charAt(0) === &#39;/&#39;;
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split(&#39;/&#39;), function(p) {
  return !!p;
}), !resolvedAbsolute).join(&#39;/&#39;);

return ((resolvedAbsolute ? &#39;/&#39; : &#39;&#39;) + resolvedPath) || &#39;.&#39;;</pre>

<p>};</p>

<p>// path.normalize(path) // posix version exports.normalize = function(path)
{</p>

<pre>var isAbsolute = exports.isAbsolute(path),
    trailingSlash = substr(path, -1) === &#39;/&#39;;

// Normalize the path
path = normalizeArray(filter(path.split(&#39;/&#39;), function(p) {
  return !!p;
}), !isAbsolute).join(&#39;/&#39;);

if (!path &amp;&amp; !isAbsolute) {
  path = &#39;.&#39;;
}
if (path &amp;&amp; trailingSlash) {
  path += &#39;/&#39;;
}

return (isAbsolute ? &#39;/&#39; : &#39;&#39;) + path;</pre>

<p>};</p>

<p>// posix version exports.isAbsolute = function(path) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">path</span>.<span class="ruby-identifier">charAt</span>(<span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;/&#39;</span>;
</pre>

<p>};</p>

<p>// posix version exports.join = function() {</p>

<pre>var paths = Array.prototype.slice.call(arguments, 0);
return exports.normalize(filter(paths, function(p, index) {
  if (typeof p !== &#39;string&#39;) {
    throw new TypeError(&#39;Arguments to path.join must be strings&#39;);
  }
  return p;
}).join(&#39;/&#39;));</pre>

<p>};</p>

<p>// path.relative(from, to) // posix version exports.relative =
function(from, to) {</p>

<pre>from = exports.resolve(from).substr(1);
to = exports.resolve(to).substr(1);

function trim(arr) {
  var start = 0;
  for (; start &lt; arr.length; start++) {
    if (arr[start] !== &#39;&#39;) break;
  }

  var end = arr.length - 1;
  for (; end &gt;= 0; end--) {
    if (arr[end] !== &#39;&#39;) break;
  }

  if (start &gt; end) return [];
  return arr.slice(start, end - start + 1);
}

var fromParts = trim(from.split(&#39;/&#39;));
var toParts = trim(to.split(&#39;/&#39;));

var length = Math.min(fromParts.length, toParts.length);
var samePartsLength = length;
for (var i = 0; i &lt; length; i++) {
  if (fromParts[i] !== toParts[i]) {
    samePartsLength = i;
    break;
  }
}

var outputParts = [];
for (var i = samePartsLength; i &lt; fromParts.length; i++) {
  outputParts.push(&#39;..&#39;);
}

outputParts = outputParts.concat(toParts.slice(samePartsLength));

return outputParts.join(&#39;/&#39;);</pre>

<p>};</p>

<p>exports.sep = &#39;/&#39;; exports.delimiter = &#39;:&#39;;</p>

<p>exports.dirname = function(path) {</p>

<pre>var result = splitPath(path),
    root = result[0],
    dir = result[1];

if (!root &amp;&amp; !dir) {
  // No dirname whatsoever
  return &#39;.&#39;;
}

if (dir) {
  // It has a dirname, strip trailing slash
  dir = dir.substr(0, dir.length - 1);
}

return root + dir;</pre>

<p>};</p>

<p>exports.basename = function(path, ext) {</p>

<pre>var f = splitPath(path)[2];
// TODO: make this comparison case-insensitive on windows?
if (ext &amp;&amp; f.substr(-1 * ext.length) === ext) {
  f = f.substr(0, f.length - ext.length);
}
return f;</pre>

<p>};</p>

<p>exports.extname = function(path) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">splitPath</span>(<span class="ruby-identifier">path</span>)[<span class="ruby-value">3</span>];
</pre>

<p>};</p>

<p>function filter (xs, f) {</p>

<pre>if (xs.filter) return xs.filter(f);
var res = [];
for (var i = 0; i &lt; xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
}
return res;</pre>

<p>}</p>

<p>// String.prototype.substr - negative index don&#39;t work in IE8 var
substr = &#39;ab&#39;.substr(-1) === &#39;b&#39;</p>

<pre>? function (str, start, len) { return str.substr(start, len) }
: function (str, start, len) {
    if (start &lt; 0) start = str.length + start;
    return str.substr(start, len);
}</pre>

<p>;</p>

<p>}).call(this,<em>dereq</em>(&#39;_process&#39;))
},{“_process”:7}],7:[function(<em>dereq</em>,module,exports){ // shim for
using process in browser</p>

<p>var process = module.exports = {};</p>

<p>process.nextTick = (function () {</p>

<pre>var canSetImmediate = typeof window !== &#39;undefined&#39;
&amp;&amp; window.setImmediate;
var canMutationObserver = typeof window !== &#39;undefined&#39;
&amp;&amp; window.MutationObserver;
var canPost = typeof window !== &#39;undefined&#39;
&amp;&amp; window.postMessage &amp;&amp; window.addEventListener
;

if (canSetImmediate) {
    return function (f) { return window.setImmediate(f) };
}

var queue = [];

if (canMutationObserver) {
    var hiddenDiv = document.createElement(&quot;div&quot;);
    var observer = new MutationObserver(function () {
        var queueList = queue.slice();
        queue.length = 0;
        queueList.forEach(function (fn) {
            fn();
        });
    });

    observer.observe(hiddenDiv, { attributes: true });

    return function nextTick(fn) {
        if (!queue.length) {
            hiddenDiv.setAttribute(&#39;yes&#39;, &#39;no&#39;);
        }
        queue.push(fn);
    };
}

if (canPost) {
    window.addEventListener(&#39;message&#39;, function (ev) {
        var source = ev.source;
        if ((source === window || source === null) &amp;&amp; ev.data === &#39;process-tick&#39;) {
            ev.stopPropagation();
            if (queue.length &gt; 0) {
                var fn = queue.shift();
                fn();
            }
        }
    }, true);

    return function nextTick(fn) {
        queue.push(fn);
        window.postMessage(&#39;process-tick&#39;, &#39;*&#39;);
    };
}

return function nextTick(fn) {
    setTimeout(fn, 0);
};</pre>

<p>})();</p>

<p>process.title = &#39;browser&#39;; process.browser = true; process.env =
{}; process.argv = [];</p>

<p>function noop() {}</p>

<p>process.on = noop; process.addListener = noop; process.once = noop;
process.off = noop; process.removeListener = noop;
process.removeAllListeners = noop; process.emit = noop;</p>

<p>process.binding = function (name) {</p>

<pre class="ruby"><span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-string">&#39;process.binding is not supported&#39;</span>);
</pre>

<p>};</p>

<p>// TODO(shtylman) process.cwd = function () { return &#39;/&#39; };
process.chdir = function (dir) {</p>

<pre class="ruby"><span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-string">&#39;process.chdir is not supported&#39;</span>);
</pre>

<p>};</p>

<p>},{}],8:[function(<em>dereq</em>,module,exports){ var Base62 = (function
(my) {</p>

<pre>my.chars = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]

my.encode = function(i){
  if (i === 0) {return &#39;0&#39;}
  var s = &#39;&#39;
  while (i &gt; 0) {
    s = this.chars[i % 62] + s
    i = Math.floor(i/62)
  }
  return s
};
my.decode = function(a,b,c,d){
  for (
    b = c = (
      a === (/\W|_|^$/.test(a += &quot;&quot;) || a)
    ) - 1;
    d = a.charCodeAt(c++);
  )
  b = b * 62 + d - [, 48, 29, 87][d &gt;&gt; 5];
  return b
};

return my;</pre>

<p>}({}));</p>

<p>module.exports = Base62 },{}],9:[function(<em>dereq</em>,module,exports){
/*</p>

<pre> Copyright (C) 2013 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;
 Copyright (C) 2013 Thaddee Tyl &lt;thaddee.tyl@gmail.com&gt;
 Copyright (C) 2012 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;
 Copyright (C) 2012 Mathias Bynens &lt;mathias@qiwi.be&gt;
 Copyright (C) 2012 Joost-Wim Boekesteijn &lt;joost-wim@boekesteijn.nl&gt;
 Copyright (C) 2012 Kris Kowal &lt;kris.kowal@cixar.com&gt;
 Copyright (C) 2012 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
 Copyright (C) 2012 Arpad Borsos &lt;arpad.borsos@googlemail.com&gt;
 Copyright (C) 2011 Ariya Hidayat &lt;ariya.hidayat@gmail.com&gt;

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
     Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/</pre>

<p>/*jslint bitwise:true plusplus:true */ /*global esprima:true, define:true,
exports:true, window: true, throwError: true, generateStatement: true,
peek: true, parseAssignmentExpression: true, parseBlock: true,
parseClassExpression: true, parseClassDeclaration: true, parseExpression:
true, parseDeclareClass: true, parseDeclareFunction: true,
parseDeclareModule: true, parseDeclareVariable: true, parseForStatement:
true, parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseImportSpecifier: true, parseInterface: true,
parseLeftHandSideExpression: true, parseParams: true, validateParam: true,
parseSpreadOrAssignmentExpression: true, parseStatement: true,
parseSourceElement: true, parseConciseBody: true, advanceXJSChild: true,
isXJSIdentifierStart: true, isXJSIdentifierPart: true,
scanXJSStringLiteral: true, scanXJSIdentifier: true,
parseXJSAttributeValue: true, parseXJSChild: true, parseXJSElement: true,
parseXJSExpressionContainer: true, parseXJSEmptyExpression: true,
parseFunctionTypeParam: true, parsePrimaryType: true, parseTypeAlias: true,
parseType: true, parseTypeAnnotatableIdentifier: true, parseTypeAnnotation:
true, parseYieldExpression: true, parseAwaitExpression: true</p>

<pre>/</pre>

<p>(function (root, factory) {</p>

<pre>&#39;use strict&#39;;

// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
// Rhino, and plain browser loading.
if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
    define([&#39;exports&#39;], factory);
} else if (typeof exports !== &#39;undefined&#39;) {
    factory(exports);
} else {
    factory((root.esprima = {}));
}</pre>

<p>}(this, function (exports) {</p>

<pre>&#39;use strict&#39;;

var Token,
    TokenName,
    FnExprTokens,
    Syntax,
    PropertyKind,
    Messages,
    Regex,
    SyntaxTreeDelegate,
    XHTMLEntities,
    ClassPropertyType,
    source,
    strict,
    index,
    lineNumber,
    lineStart,
    length,
    delegate,
    lookahead,
    state,
    extra;

Token = {
    BooleanLiteral: 1,
    EOF: 2,
    Identifier: 3,
    Keyword: 4,
    NullLiteral: 5,
    NumericLiteral: 6,
    Punctuator: 7,
    StringLiteral: 8,
    RegularExpression: 9,
    Template: 10,
    XJSIdentifier: 11,
    XJSText: 12
};

TokenName = {};
TokenName[Token.BooleanLiteral] = &#39;Boolean&#39;;
TokenName[Token.EOF] = &#39;&lt;end&gt;&#39;;
TokenName[Token.Identifier] = &#39;Identifier&#39;;
TokenName[Token.Keyword] = &#39;Keyword&#39;;
TokenName[Token.NullLiteral] = &#39;Null&#39;;
TokenName[Token.NumericLiteral] = &#39;Numeric&#39;;
TokenName[Token.Punctuator] = &#39;Punctuator&#39;;
TokenName[Token.StringLiteral] = &#39;String&#39;;
TokenName[Token.XJSIdentifier] = &#39;XJSIdentifier&#39;;
TokenName[Token.XJSText] = &#39;XJSText&#39;;
TokenName[Token.RegularExpression] = &#39;RegularExpression&#39;;

// A function following one of those tokens is an expression.
FnExprTokens = [&#39;(&#39;, &#39;{&#39;, &#39;[&#39;, &#39;in&#39;, &#39;typeof&#39;, &#39;instanceof&#39;, &#39;new&#39;,
                &#39;return&#39;, &#39;case&#39;, &#39;delete&#39;, &#39;throw&#39;, &#39;void&#39;,
                // assignment operators
                &#39;=&#39;, &#39;+=&#39;, &#39;-=&#39;, &#39;*=&#39;, &#39;/=&#39;, &#39;%=&#39;, &#39;&lt;&lt;=&#39;, &#39;&gt;&gt;=&#39;, &#39;&gt;&gt;&gt;=&#39;,
                &#39;&amp;=&#39;, &#39;|=&#39;, &#39;^=&#39;, &#39;,&#39;,
                // binary/unary operators
                &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;++&#39;, &#39;--&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&gt;&gt;&gt;&#39;, &#39;&amp;&#39;,
                &#39;|&#39;, &#39;^&#39;, &#39;!&#39;, &#39;~&#39;, &#39;&amp;&amp;&#39;, &#39;||&#39;, &#39;?&#39;, &#39;:&#39;, &#39;===&#39;, &#39;==&#39;, &#39;&gt;=&#39;,
                &#39;&lt;=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;!=&#39;, &#39;!==&#39;];

Syntax = {
    AnyTypeAnnotation: &#39;AnyTypeAnnotation&#39;,
    ArrayExpression: &#39;ArrayExpression&#39;,
    ArrayPattern: &#39;ArrayPattern&#39;,
    ArrayTypeAnnotation: &#39;ArrayTypeAnnotation&#39;,
    ArrowFunctionExpression: &#39;ArrowFunctionExpression&#39;,
    AssignmentExpression: &#39;AssignmentExpression&#39;,
    BinaryExpression: &#39;BinaryExpression&#39;,
    BlockStatement: &#39;BlockStatement&#39;,
    BooleanTypeAnnotation: &#39;BooleanTypeAnnotation&#39;,
    BreakStatement: &#39;BreakStatement&#39;,
    CallExpression: &#39;CallExpression&#39;,
    CatchClause: &#39;CatchClause&#39;,
    ClassBody: &#39;ClassBody&#39;,
    ClassDeclaration: &#39;ClassDeclaration&#39;,
    ClassExpression: &#39;ClassExpression&#39;,
    ClassImplements: &#39;ClassImplements&#39;,
    ClassProperty: &#39;ClassProperty&#39;,
    ComprehensionBlock: &#39;ComprehensionBlock&#39;,
    ComprehensionExpression: &#39;ComprehensionExpression&#39;,
    ConditionalExpression: &#39;ConditionalExpression&#39;,
    ContinueStatement: &#39;ContinueStatement&#39;,
    DebuggerStatement: &#39;DebuggerStatement&#39;,
    DeclareClass: &#39;DeclareClass&#39;,
    DeclareFunction: &#39;DeclareFunction&#39;,
    DeclareModule: &#39;DeclareModule&#39;,
    DeclareVariable: &#39;DeclareVariable&#39;,
    DoWhileStatement: &#39;DoWhileStatement&#39;,
    EmptyStatement: &#39;EmptyStatement&#39;,
    ExportDeclaration: &#39;ExportDeclaration&#39;,
    ExportBatchSpecifier: &#39;ExportBatchSpecifier&#39;,
    ExportSpecifier: &#39;ExportSpecifier&#39;,
    ExpressionStatement: &#39;ExpressionStatement&#39;,
    ForInStatement: &#39;ForInStatement&#39;,
    ForOfStatement: &#39;ForOfStatement&#39;,
    ForStatement: &#39;ForStatement&#39;,
    FunctionDeclaration: &#39;FunctionDeclaration&#39;,
    FunctionExpression: &#39;FunctionExpression&#39;,
    FunctionTypeAnnotation: &#39;FunctionTypeAnnotation&#39;,
    FunctionTypeParam: &#39;FunctionTypeParam&#39;,
    GenericTypeAnnotation: &#39;GenericTypeAnnotation&#39;,
    Identifier: &#39;Identifier&#39;,
    IfStatement: &#39;IfStatement&#39;,
    ImportDeclaration: &#39;ImportDeclaration&#39;,
    ImportDefaultSpecifier: &#39;ImportDefaultSpecifier&#39;,
    ImportNamespaceSpecifier: &#39;ImportNamespaceSpecifier&#39;,
    ImportSpecifier: &#39;ImportSpecifier&#39;,
    InterfaceDeclaration: &#39;InterfaceDeclaration&#39;,
    InterfaceExtends: &#39;InterfaceExtends&#39;,
    IntersectionTypeAnnotation: &#39;IntersectionTypeAnnotation&#39;,
    LabeledStatement: &#39;LabeledStatement&#39;,
    Literal: &#39;Literal&#39;,
    LogicalExpression: &#39;LogicalExpression&#39;,
    MemberExpression: &#39;MemberExpression&#39;,
    MethodDefinition: &#39;MethodDefinition&#39;,
    ModuleSpecifier: &#39;ModuleSpecifier&#39;,
    NewExpression: &#39;NewExpression&#39;,
    NullableTypeAnnotation: &#39;NullableTypeAnnotation&#39;,
    NumberTypeAnnotation: &#39;NumberTypeAnnotation&#39;,
    ObjectExpression: &#39;ObjectExpression&#39;,
    ObjectPattern: &#39;ObjectPattern&#39;,
    ObjectTypeAnnotation: &#39;ObjectTypeAnnotation&#39;,
    ObjectTypeCallProperty: &#39;ObjectTypeCallProperty&#39;,
    ObjectTypeIndexer: &#39;ObjectTypeIndexer&#39;,
    ObjectTypeProperty: &#39;ObjectTypeProperty&#39;,
    Program: &#39;Program&#39;,
    Property: &#39;Property&#39;,
    QualifiedTypeIdentifier: &#39;QualifiedTypeIdentifier&#39;,
    ReturnStatement: &#39;ReturnStatement&#39;,
    SequenceExpression: &#39;SequenceExpression&#39;,
    SpreadElement: &#39;SpreadElement&#39;,
    SpreadProperty: &#39;SpreadProperty&#39;,
    StringLiteralTypeAnnotation: &#39;StringLiteralTypeAnnotation&#39;,
    StringTypeAnnotation: &#39;StringTypeAnnotation&#39;,
    SwitchCase: &#39;SwitchCase&#39;,
    SwitchStatement: &#39;SwitchStatement&#39;,
    TaggedTemplateExpression: &#39;TaggedTemplateExpression&#39;,
    TemplateElement: &#39;TemplateElement&#39;,
    TemplateLiteral: &#39;TemplateLiteral&#39;,
    ThisExpression: &#39;ThisExpression&#39;,
    ThrowStatement: &#39;ThrowStatement&#39;,
    TupleTypeAnnotation: &#39;TupleTypeAnnotation&#39;,
    TryStatement: &#39;TryStatement&#39;,
    TypeAlias: &#39;TypeAlias&#39;,
    TypeAnnotation: &#39;TypeAnnotation&#39;,
    TypeofTypeAnnotation: &#39;TypeofTypeAnnotation&#39;,
    TypeParameterDeclaration: &#39;TypeParameterDeclaration&#39;,
    TypeParameterInstantiation: &#39;TypeParameterInstantiation&#39;,
    UnaryExpression: &#39;UnaryExpression&#39;,
    UnionTypeAnnotation: &#39;UnionTypeAnnotation&#39;,
    UpdateExpression: &#39;UpdateExpression&#39;,
    VariableDeclaration: &#39;VariableDeclaration&#39;,
    VariableDeclarator: &#39;VariableDeclarator&#39;,
    VoidTypeAnnotation: &#39;VoidTypeAnnotation&#39;,
    WhileStatement: &#39;WhileStatement&#39;,
    WithStatement: &#39;WithStatement&#39;,
    XJSIdentifier: &#39;XJSIdentifier&#39;,
    XJSNamespacedName: &#39;XJSNamespacedName&#39;,
    XJSMemberExpression: &#39;XJSMemberExpression&#39;,
    XJSEmptyExpression: &#39;XJSEmptyExpression&#39;,
    XJSExpressionContainer: &#39;XJSExpressionContainer&#39;,
    XJSElement: &#39;XJSElement&#39;,
    XJSClosingElement: &#39;XJSClosingElement&#39;,
    XJSOpeningElement: &#39;XJSOpeningElement&#39;,
    XJSAttribute: &#39;XJSAttribute&#39;,
    XJSSpreadAttribute: &#39;XJSSpreadAttribute&#39;,
    XJSText: &#39;XJSText&#39;,
    YieldExpression: &#39;YieldExpression&#39;,
    AwaitExpression: &#39;AwaitExpression&#39;
};

PropertyKind = {
    Data: 1,
    Get: 2,
    Set: 4
};

ClassPropertyType = {
    &#39;static&#39;: &#39;static&#39;,
    prototype: &#39;prototype&#39;
};

// Error messages should be identical to V8.
Messages = {
    UnexpectedToken:  &#39;Unexpected token %0&#39;,
    UnexpectedNumber:  &#39;Unexpected number&#39;,
    UnexpectedString:  &#39;Unexpected string&#39;,
    UnexpectedIdentifier:  &#39;Unexpected identifier&#39;,
    UnexpectedReserved:  &#39;Unexpected reserved word&#39;,
    UnexpectedTemplate:  &#39;Unexpected quasi %0&#39;,
    UnexpectedEOS:  &#39;Unexpected end of input&#39;,
    NewlineAfterThrow:  &#39;Illegal newline after throw&#39;,
    InvalidRegExp: &#39;Invalid regular expression&#39;,
    UnterminatedRegExp:  &#39;Invalid regular expression: missing /&#39;,
    InvalidLHSInAssignment:  &#39;Invalid left-hand side in assignment&#39;,
    InvalidLHSInFormalsList:  &#39;Invalid left-hand side in formals list&#39;,
    InvalidLHSInForIn:  &#39;Invalid left-hand side in for-in&#39;,
    MultipleDefaultsInSwitch: &#39;More than one default clause in switch statement&#39;,
    NoCatchOrFinally:  &#39;Missing catch or finally after try&#39;,
    UnknownLabel: &#39;Undefined label \&#39;%0\&#39;&#39;,
    Redeclaration: &#39;%0 \&#39;%1\&#39; has already been declared&#39;,
    IllegalContinue: &#39;Illegal continue statement&#39;,
    IllegalBreak: &#39;Illegal break statement&#39;,
    IllegalDuplicateClassProperty: &#39;Illegal duplicate property in class definition&#39;,
    IllegalReturn: &#39;Illegal return statement&#39;,
    IllegalSpread: &#39;Illegal spread element&#39;,
    StrictModeWith:  &#39;Strict mode code may not include a with statement&#39;,
    StrictCatchVariable:  &#39;Catch variable may not be eval or arguments in strict mode&#39;,
    StrictVarName:  &#39;Variable name may not be eval or arguments in strict mode&#39;,
    StrictParamName:  &#39;Parameter name eval or arguments is not allowed in strict mode&#39;,
    StrictParamDupe: &#39;Strict mode function may not have duplicate parameter names&#39;,
    ParameterAfterRestParameter: &#39;Rest parameter must be final parameter of an argument list&#39;,
    DefaultRestParameter: &#39;Rest parameter can not have a default value&#39;,
    ElementAfterSpreadElement: &#39;Spread must be the final element of an element list&#39;,
    PropertyAfterSpreadProperty: &#39;A rest property must be the final property of an object literal&#39;,
    ObjectPatternAsRestParameter: &#39;Invalid rest parameter&#39;,
    ObjectPatternAsSpread: &#39;Invalid spread argument&#39;,
    StrictFunctionName:  &#39;Function name may not be eval or arguments in strict mode&#39;,
    StrictOctalLiteral:  &#39;Octal literals are not allowed in strict mode.&#39;,
    StrictDelete:  &#39;Delete of an unqualified identifier in strict mode.&#39;,
    StrictDuplicateProperty:  &#39;Duplicate data property in object literal not allowed in strict mode&#39;,
    AccessorDataProperty:  &#39;Object literal may not have data and accessor property with the same name&#39;,
    AccessorGetSet:  &#39;Object literal may not have multiple get/set accessors with the same name&#39;,
    StrictLHSAssignment:  &#39;Assignment to eval or arguments is not allowed in strict mode&#39;,
    StrictLHSPostfix:  &#39;Postfix increment/decrement may not have eval or arguments operand in strict mode&#39;,
    StrictLHSPrefix:  &#39;Prefix increment/decrement may not have eval or arguments operand in strict mode&#39;,
    StrictReservedWord:  &#39;Use of future reserved word in strict mode&#39;,
    MissingFromClause: &#39;Missing from clause&#39;,
    NoAsAfterImportNamespace: &#39;Missing as after import *&#39;,
    InvalidModuleSpecifier: &#39;Invalid module specifier&#39;,
    NoUnintializedConst: &#39;Const must be initialized&#39;,
    ComprehensionRequiresBlock: &#39;Comprehension must have at least one block&#39;,
    ComprehensionError:  &#39;Comprehension Error&#39;,
    EachNotAllowed:  &#39;Each is not supported&#39;,
    InvalidXJSAttributeValue: &#39;XJS value should be either an expression or a quoted XJS text&#39;,
    ExpectedXJSClosingTag: &#39;Expected corresponding XJS closing tag for %0&#39;,
    AdjacentXJSElements: &#39;Adjacent XJS elements must be wrapped in an enclosing tag&#39;,
    ConfusedAboutFunctionType: &#39;Unexpected token =&gt;. It looks like &#39; +
        &#39;you are trying to write a function type, but you ended up &#39; +
        &#39;writing a grouped type followed by an =&gt;, which is a syntax &#39; +
        &#39;error. Remember, function type parameters are named so function &#39; +
        &#39;types look like (name1: type1, name2: type2) =&gt; returnType. You &#39; +
        &#39;probably wrote (type1) =&gt; returnType&#39;
};

// See also tools/generate-unicode-regex.py.
Regex = {
    NonAsciiIdentifierStart: new RegExp(&#39;[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]&#39;),
    NonAsciiIdentifierPart: new RegExp(&#39;[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]&#39;),
    LeadingZeros: new RegExp(&#39;^0+(?!$)&#39;)
};

// Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
    if (!condition) {
        throw new Error(&#39;ASSERT: &#39; + message);
    }
}

function isDecimalDigit(ch) {
    return (ch &gt;= 48 &amp;&amp; ch &lt;= 57);   // 0..9
}

function isHexDigit(ch) {
    return &#39;0123456789abcdefABCDEF&#39;.indexOf(ch) &gt;= 0;
}

function isOctalDigit(ch) {
    return &#39;01234567&#39;.indexOf(ch) &gt;= 0;
}

// 7.2 White Space

function isWhiteSpace(ch) {
    return (ch === 32) ||  // space
        (ch === 9) ||      // tab
        (ch === 0xB) ||
        (ch === 0xC) ||
        (ch === 0xA0) ||
        (ch &gt;= 0x1680 &amp;&amp; &#39;\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF&#39;.indexOf(String.fromCharCode(ch)) &gt; 0);
}

// 7.3 Line Terminators

function isLineTerminator(ch) {
    return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
}

// 7.6 Identifier Names and Identifiers

function isIdentifierStart(ch) {
    return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
        (ch &gt;= 65 &amp;&amp; ch &lt;= 90) ||         // A..Z
        (ch &gt;= 97 &amp;&amp; ch &lt;= 122) ||        // a..z
        (ch === 92) ||                    // \ (backslash)
        ((ch &gt;= 0x80) &amp;&amp; Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
}

function isIdentifierPart(ch) {
    return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
        (ch &gt;= 65 &amp;&amp; ch &lt;= 90) ||         // A..Z
        (ch &gt;= 97 &amp;&amp; ch &lt;= 122) ||        // a..z
        (ch &gt;= 48 &amp;&amp; ch &lt;= 57) ||         // 0..9
        (ch === 92) ||                    // \ (backslash)
        ((ch &gt;= 0x80) &amp;&amp; Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
}

// 7.6.1.2 Future Reserved Words

function isFutureReservedWord(id) {
    switch (id) {
    case &#39;class&#39;:
    case &#39;enum&#39;:
    case &#39;export&#39;:
    case &#39;extends&#39;:
    case &#39;import&#39;:
    case &#39;super&#39;:
        return true;
    default:
        return false;
    }
}

function isStrictModeReservedWord(id) {
    switch (id) {
    case &#39;implements&#39;:
    case &#39;interface&#39;:
    case &#39;package&#39;:
    case &#39;private&#39;:
    case &#39;protected&#39;:
    case &#39;public&#39;:
    case &#39;static&#39;:
    case &#39;yield&#39;:
    case &#39;let&#39;:
        return true;
    default:
        return false;
    }
}

function isRestrictedWord(id) {
    return id === &#39;eval&#39; || id === &#39;arguments&#39;;
}

// 7.6.1.1 Keywords

function isKeyword(id) {
    if (strict &amp;&amp; isStrictModeReservedWord(id)) {
        return true;
    }

    // &#39;const&#39; is specialized as Keyword in V8.
    // &#39;yield&#39; is only treated as a keyword in strict mode.
    // &#39;let&#39; is for compatiblity with SpiderMonkey and ES.next.
    // Some others are from future reserved words.

    switch (id.length) {
    case 2:
        return (id === &#39;if&#39;) || (id === &#39;in&#39;) || (id === &#39;do&#39;);
    case 3:
        return (id === &#39;var&#39;) || (id === &#39;for&#39;) || (id === &#39;new&#39;) ||
            (id === &#39;try&#39;) || (id === &#39;let&#39;);
    case 4:
        return (id === &#39;this&#39;) || (id === &#39;else&#39;) || (id === &#39;case&#39;) ||
            (id === &#39;void&#39;) || (id === &#39;with&#39;) || (id === &#39;enum&#39;);
    case 5:
        return (id === &#39;while&#39;) || (id === &#39;break&#39;) || (id === &#39;catch&#39;) ||
            (id === &#39;throw&#39;) || (id === &#39;const&#39;) ||
            (id === &#39;class&#39;) || (id === &#39;super&#39;);
    case 6:
        return (id === &#39;return&#39;) || (id === &#39;typeof&#39;) || (id === &#39;delete&#39;) ||
            (id === &#39;switch&#39;) || (id === &#39;export&#39;) || (id === &#39;import&#39;);
    case 7:
        return (id === &#39;default&#39;) || (id === &#39;finally&#39;) || (id === &#39;extends&#39;);
    case 8:
        return (id === &#39;function&#39;) || (id === &#39;continue&#39;) || (id === &#39;debugger&#39;);
    case 10:
        return (id === &#39;instanceof&#39;);
    default:
        return false;
    }
}

// 7.4 Comments

function skipComment() {
    var ch, blockComment, lineComment;

    blockComment = false;
    lineComment = false;

    while (index &lt; length) {
        ch = source.charCodeAt(index);

        if (lineComment) {
            ++index;
            if (isLineTerminator(ch)) {
                lineComment = false;
                if (ch === 13 &amp;&amp; source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            }
        } else if (blockComment) {
            if (isLineTerminator(ch)) {
                if (ch === 13) {
                    ++index;
                }
                if (ch !== 13 || source.charCodeAt(index) === 10) {
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index &gt;= length) {
                        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                    }
                }
            } else {
                ch = source.charCodeAt(index++);
                if (index &gt;= length) {
                    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                }
                // Block comment ends with &#39;*/&#39; (char #42, char #47).
                if (ch === 42) {
                    ch = source.charCodeAt(index);
                    if (ch === 47) {
                        ++index;
                        blockComment = false;
                    }
                }
            }
        } else if (ch === 47) {
            ch = source.charCodeAt(index + 1);
            // Line comment starts with &#39;//&#39; (char #47, char #47).
            if (ch === 47) {
                index += 2;
                lineComment = true;
            } else if (ch === 42) {
                // Block comment starts with &#39;/*&#39; (char #47, char #42).
                index += 2;
                blockComment = true;
                if (index &gt;= length) {
                    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                }
            } else {
                break;
            }
        } else if (isWhiteSpace(ch)) {
            ++index;
        } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === 13 &amp;&amp; source.charCodeAt(index) === 10) {
                ++index;
            }
            ++lineNumber;
            lineStart = index;
        } else {
            break;
        }
    }
}

function scanHexEscape(prefix) {
    var i, len, ch, code = 0;

    len = (prefix === &#39;u&#39;) ? 4 : 2;
    for (i = 0; i &lt; len; ++i) {
        if (index &lt; length &amp;&amp; isHexDigit(source[index])) {
            ch = source[index++];
            code = code * 16 + &#39;0123456789abcdef&#39;.indexOf(ch.toLowerCase());
        } else {
            return &#39;&#39;;
        }
    }
    return String.fromCharCode(code);
}

function scanUnicodeCodePointEscape() {
    var ch, code, cu1, cu2;

    ch = source[index];
    code = 0;

    // At least, one hex digit is required.
    if (ch === &#39;}&#39;) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    while (index &lt; length) {
        ch = source[index++];
        if (!isHexDigit(ch)) {
            break;
        }
        code = code * 16 + &#39;0123456789abcdef&#39;.indexOf(ch.toLowerCase());
    }

    if (code &gt; 0x10FFFF || ch !== &#39;}&#39;) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    // UTF-16 Encoding
    if (code &lt;= 0xFFFF) {
        return String.fromCharCode(code);
    }
    cu1 = ((code - 0x10000) &gt;&gt; 10) + 0xD800;
    cu2 = ((code - 0x10000) &amp; 1023) + 0xDC00;
    return String.fromCharCode(cu1, cu2);
}

function getEscapedIdentifier() {
    var ch, id;

    ch = source.charCodeAt(index++);
    id = String.fromCharCode(ch);

    // &#39;\u&#39; (char #92, char #117) denotes an escaped character.
    if (ch === 92) {
        if (source.charCodeAt(index) !== 117) {
            throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
        }
        ++index;
        ch = scanHexEscape(&#39;u&#39;);
        if (!ch || ch === &#39;\\&#39; || !isIdentifierStart(ch.charCodeAt(0))) {
            throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
        }
        id = ch;
    }

    while (index &lt; length) {
        ch = source.charCodeAt(index);
        if (!isIdentifierPart(ch)) {
            break;
        }
        ++index;
        id += String.fromCharCode(ch);

        // &#39;\u&#39; (char #92, char #117) denotes an escaped character.
        if (ch === 92) {
            id = id.substr(0, id.length - 1);
            if (source.charCodeAt(index) !== 117) {
                throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
            }
            ++index;
            ch = scanHexEscape(&#39;u&#39;);
            if (!ch || ch === &#39;\\&#39; || !isIdentifierPart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
            }
            id += ch;
        }
    }

    return id;
}

function getIdentifier() {
    var start, ch;

    start = index++;
    while (index &lt; length) {
        ch = source.charCodeAt(index);
        if (ch === 92) {
            // Blackslash (char #92) marks Unicode escape sequence.
            index = start;
            return getEscapedIdentifier();
        }
        if (isIdentifierPart(ch)) {
            ++index;
        } else {
            break;
        }
    }

    return source.slice(start, index);
}

function scanIdentifier() {
    var start, id, type;

    start = index;

    // Backslash (char #92) starts an escaped character.
    id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

    // There is no keyword or literal with only one character.
    // Thus, it must be an identifier.
    if (id.length === 1) {
        type = Token.Identifier;
    } else if (isKeyword(id)) {
        type = Token.Keyword;
    } else if (id === &#39;null&#39;) {
        type = Token.NullLiteral;
    } else if (id === &#39;true&#39; || id === &#39;false&#39;) {
        type = Token.BooleanLiteral;
    } else {
        type = Token.Identifier;
    }

    return {
        type: type,
        value: id,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

// 7.7 Punctuators

function scanPunctuator() {
    var start = index,
        code = source.charCodeAt(index),
        code2,
        ch1 = source[index],
        ch2,
        ch3,
        ch4;

    switch (code) {
    // Check for most common single-character punctuators.
    case 40:   // ( open bracket
    case 41:   // ) close bracket
    case 59:   // ; semicolon
    case 44:   // , comma
    case 123:  // { open curly brace
    case 125:  // } close curly brace
    case 91:   // [
    case 93:   // ]
    case 58:   // :
    case 63:   // ?
    case 126:  // ~
        ++index;
        if (extra.tokenize) {
            if (code === 40) {
                extra.openParenToken = extra.tokens.length;
            } else if (code === 123) {
                extra.openCurlyToken = extra.tokens.length;
            }
        }
        return {
            type: Token.Punctuator,
            value: String.fromCharCode(code),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };

    default:
        code2 = source.charCodeAt(index + 1);

        // &#39;=&#39; (char #61) marks an assignment or comparison operator.
        if (code2 === 61) {
            switch (code) {
            case 37:  // %
            case 38:  // &amp;
            case 42:  // *:
            case 43:  // +
            case 45:  // -
            case 47:  // /
            case 60:  // &lt;
            case 62:  // &gt;
            case 94:  // ^
            case 124: // |
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code) + String.fromCharCode(code2),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };

            case 33: // !
            case 61: // =
                index += 2;

                // !== and ===
                if (source.charCodeAt(index) === 61) {
                    ++index;
                }
                return {
                    type: Token.Punctuator,
                    value: source.slice(start, index),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            default:
                break;
            }
        }
        break;
    }

    // Peek more characters.

    ch2 = source[index + 1];
    ch3 = source[index + 2];
    ch4 = source[index + 3];

    // 4-character punctuator: &gt;&gt;&gt;=

    if (ch1 === &#39;&gt;&#39; &amp;&amp; ch2 === &#39;&gt;&#39; &amp;&amp; ch3 === &#39;&gt;&#39;) {
        if (ch4 === &#39;=&#39;) {
            index += 4;
            return {
                type: Token.Punctuator,
                value: &#39;&gt;&gt;&gt;=&#39;,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    }

    // 3-character punctuators: === !== &gt;&gt;&gt; &lt;&lt;= &gt;&gt;=

    if (ch1 === &#39;&gt;&#39; &amp;&amp; ch2 === &#39;&gt;&#39; &amp;&amp; ch3 === &#39;&gt;&#39;) {
        index += 3;
        return {
            type: Token.Punctuator,
            value: &#39;&gt;&gt;&gt;&#39;,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (ch1 === &#39;&lt;&#39; &amp;&amp; ch2 === &#39;&lt;&#39; &amp;&amp; ch3 === &#39;=&#39;) {
        index += 3;
        return {
            type: Token.Punctuator,
            value: &#39;&lt;&lt;=&#39;,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (ch1 === &#39;&gt;&#39; &amp;&amp; ch2 === &#39;&gt;&#39; &amp;&amp; ch3 === &#39;=&#39;) {
        index += 3;
        return {
            type: Token.Punctuator,
            value: &#39;&gt;&gt;=&#39;,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (ch1 === &#39;.&#39; &amp;&amp; ch2 === &#39;.&#39; &amp;&amp; ch3 === &#39;.&#39;) {
        index += 3;
        return {
            type: Token.Punctuator,
            value: &#39;...&#39;,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // Other 2-character punctuators: ++ -- &lt;&lt; &gt;&gt; &amp;&amp; ||

    // Don&#39;t match these tokens if we&#39;re in a type, since they never can
    // occur and can mess up types like Map&lt;string, Array&lt;string&gt;&gt;
    if (ch1 === ch2 &amp;&amp; (&#39;+-&lt;&gt;&amp;|&#39;.indexOf(ch1) &gt;= 0) &amp;&amp; !state.inType) {
        index += 2;
        return {
            type: Token.Punctuator,
            value: ch1 + ch2,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (ch1 === &#39;=&#39; &amp;&amp; ch2 === &#39;&gt;&#39;) {
        index += 2;
        return {
            type: Token.Punctuator,
            value: &#39;=&gt;&#39;,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (&#39;&lt;&gt;=!+-*%&amp;|^/&#39;.indexOf(ch1) &gt;= 0) {
        ++index;
        return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    if (ch1 === &#39;.&#39;) {
        ++index;
        return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
}

// 7.8.3 Numeric Literals

function scanHexLiteral(start) {
    var number = &#39;&#39;;

    while (index &lt; length) {
        if (!isHexDigit(source[index])) {
            break;
        }
        number += source[index++];
    }

    if (number.length === 0) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    if (isIdentifierStart(source.charCodeAt(index))) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    return {
        type: Token.NumericLiteral,
        value: parseInt(&#39;0x&#39; + number, 16),
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanOctalLiteral(prefix, start) {
    var number, octal;

    if (isOctalDigit(prefix)) {
        octal = true;
        number = &#39;0&#39; + source[index++];
    } else {
        octal = false;
        ++index;
        number = &#39;&#39;;
    }

    while (index &lt; length) {
        if (!isOctalDigit(source[index])) {
            break;
        }
        number += source[index++];
    }

    if (!octal &amp;&amp; number.length === 0) {
        // only 0o or 0O
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    return {
        type: Token.NumericLiteral,
        value: parseInt(number, 8),
        octal: octal,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanNumericLiteral() {
    var number, start, ch, octal;

    ch = source[index];
    assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === &#39;.&#39;),
        &#39;Numeric literal must start with a decimal digit or a decimal point&#39;);

    start = index;
    number = &#39;&#39;;
    if (ch !== &#39;.&#39;) {
        number = source[index++];
        ch = source[index];

        // Hex number starts with &#39;0x&#39;.
        // Octal number starts with &#39;0&#39;.
        // Octal number in ES6 starts with &#39;0o&#39;.
        // Binary number in ES6 starts with &#39;0b&#39;.
        if (number === &#39;0&#39;) {
            if (ch === &#39;x&#39; || ch === &#39;X&#39;) {
                ++index;
                return scanHexLiteral(start);
            }
            if (ch === &#39;b&#39; || ch === &#39;B&#39;) {
                ++index;
                number = &#39;&#39;;

                while (index &lt; length) {
                    ch = source[index];
                    if (ch !== &#39;0&#39; &amp;&amp; ch !== &#39;1&#39;) {
                        break;
                    }
                    number += source[index++];
                }

                if (number.length === 0) {
                    // only 0b or 0B
                    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                }

                if (index &lt; length) {
                    ch = source.charCodeAt(index);
                    if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                    }
                }
                return {
                    type: Token.NumericLiteral,
                    value: parseInt(number, 2),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
            if (ch === &#39;o&#39; || ch === &#39;O&#39; || isOctalDigit(ch)) {
                return scanOctalLiteral(ch, start);
            }
            // decimal number starts with &#39;0&#39; such as &#39;09&#39; is illegal.
            if (ch &amp;&amp; isDecimalDigit(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
            }
        }

        while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
        }
        ch = source[index];
    }

    if (ch === &#39;.&#39;) {
        number += source[index++];
        while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
        }
        ch = source[index];
    }

    if (ch === &#39;e&#39; || ch === &#39;E&#39;) {
        number += source[index++];

        ch = source[index];
        if (ch === &#39;+&#39; || ch === &#39;-&#39;) {
            number += source[index++];
        }
        if (isDecimalDigit(source.charCodeAt(index))) {
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
        } else {
            throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
        }
    }

    if (isIdentifierStart(source.charCodeAt(index))) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    return {
        type: Token.NumericLiteral,
        value: parseFloat(number),
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

// 7.8.4 String Literals

function scanStringLiteral() {
    var str = &#39;&#39;, quote, start, ch, code, unescaped, restore, octal = false;

    quote = source[index];
    assert((quote === &#39;\&#39;&#39; || quote === &#39;&quot;&#39;),
        &#39;String literal must starts with a quote&#39;);

    start = index;
    ++index;

    while (index &lt; length) {
        ch = source[index++];

        if (ch === quote) {
            quote = &#39;&#39;;
            break;
        } else if (ch === &#39;\\&#39;) {
            ch = source[index++];
            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                switch (ch) {
                case &#39;n&#39;:
                    str += &#39;\n&#39;;
                    break;
                case &#39;r&#39;:
                    str += &#39;\r&#39;;
                    break;
                case &#39;t&#39;:
                    str += &#39;\t&#39;;
                    break;
                case &#39;u&#39;:
                case &#39;x&#39;:
                    if (source[index] === &#39;{&#39;) {
                        ++index;
                        str += scanUnicodeCodePointEscape();
                    } else {
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                    }
                    break;
                case &#39;b&#39;:
                    str += &#39;\b&#39;;
                    break;
                case &#39;f&#39;:
                    str += &#39;\f&#39;;
                    break;
                case &#39;v&#39;:
                    str += &#39;\x0B&#39;;
                    break;

                default:
                    if (isOctalDigit(ch)) {
                        code = &#39;01234567&#39;.indexOf(ch);

                        // \0 is not octal escape sequence
                        if (code !== 0) {
                            octal = true;
                        }

                        if (index &lt; length &amp;&amp; isOctalDigit(source[index])) {
                            octal = true;
                            code = code * 8 + &#39;01234567&#39;.indexOf(source[index++]);

                            // 3 digits are only allowed when string starts
                            // with 0, 1, 2, 3
                            if (&#39;0123&#39;.indexOf(ch) &gt;= 0 &amp;&amp;
                                    index &lt; length &amp;&amp;
                                    isOctalDigit(source[index])) {
                                code = code * 8 + &#39;01234567&#39;.indexOf(source[index++]);
                            }
                        }
                        str += String.fromCharCode(code);
                    } else {
                        str += ch;
                    }
                    break;
                }
            } else {
                ++lineNumber;
                if (ch ===  &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                    ++index;
                }
                lineStart = index;
            }
        } else if (isLineTerminator(ch.charCodeAt(0))) {
            break;
        } else {
            str += ch;
        }
    }

    if (quote !== &#39;&#39;) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    return {
        type: Token.StringLiteral,
        value: str,
        octal: octal,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanTemplate() {
    var cooked = &#39;&#39;, ch, start, terminated, tail, restore, unescaped, code, octal;

    terminated = false;
    tail = false;
    start = index;

    ++index;

    while (index &lt; length) {
        ch = source[index++];
        if (ch === &#39;`&#39;) {
            tail = true;
            terminated = true;
            break;
        } else if (ch === &#39;$&#39;) {
            if (source[index] === &#39;{&#39;) {
                ++index;
                terminated = true;
                break;
            }
            cooked += ch;
        } else if (ch === &#39;\\&#39;) {
            ch = source[index++];
            if (!isLineTerminator(ch.charCodeAt(0))) {
                switch (ch) {
                case &#39;n&#39;:
                    cooked += &#39;\n&#39;;
                    break;
                case &#39;r&#39;:
                    cooked += &#39;\r&#39;;
                    break;
                case &#39;t&#39;:
                    cooked += &#39;\t&#39;;
                    break;
                case &#39;u&#39;:
                case &#39;x&#39;:
                    if (source[index] === &#39;{&#39;) {
                        ++index;
                        cooked += scanUnicodeCodePointEscape();
                    } else {
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            cooked += unescaped;
                        } else {
                            index = restore;
                            cooked += ch;
                        }
                    }
                    break;
                case &#39;b&#39;:
                    cooked += &#39;\b&#39;;
                    break;
                case &#39;f&#39;:
                    cooked += &#39;\f&#39;;
                    break;
                case &#39;v&#39;:
                    cooked += &#39;\v&#39;;
                    break;

                default:
                    if (isOctalDigit(ch)) {
                        code = &#39;01234567&#39;.indexOf(ch);

                        // \0 is not octal escape sequence
                        if (code !== 0) {
                            octal = true;
                        }

                        if (index &lt; length &amp;&amp; isOctalDigit(source[index])) {
                            octal = true;
                            code = code * 8 + &#39;01234567&#39;.indexOf(source[index++]);

                            // 3 digits are only allowed when string starts
                            // with 0, 1, 2, 3
                            if (&#39;0123&#39;.indexOf(ch) &gt;= 0 &amp;&amp;
                                    index &lt; length &amp;&amp;
                                    isOctalDigit(source[index])) {
                                code = code * 8 + &#39;01234567&#39;.indexOf(source[index++]);
                            }
                        }
                        cooked += String.fromCharCode(code);
                    } else {
                        cooked += ch;
                    }
                    break;
                }
            } else {
                ++lineNumber;
                if (ch ===  &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                    ++index;
                }
                lineStart = index;
            }
        } else if (isLineTerminator(ch.charCodeAt(0))) {
            ++lineNumber;
            if (ch ===  &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                ++index;
            }
            lineStart = index;
            cooked += &#39;\n&#39;;
        } else {
            cooked += ch;
        }
    }

    if (!terminated) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    return {
        type: Token.Template,
        value: {
            cooked: cooked,
            raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
        },
        tail: tail,
        octal: octal,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanTemplateElement(option) {
    var startsWith, template;

    lookahead = null;
    skipComment();

    startsWith = (option.head) ? &#39;`&#39; : &#39;}&#39;;

    if (source[index] !== startsWith) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    template = scanTemplate();

    peek();

    return template;
}

function scanRegExp() {
    var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false, tmp;

    lookahead = null;
    skipComment();

    start = index;
    ch = source[index];
    assert(ch === &#39;/&#39;, &#39;Regular expression literal must start with a slash&#39;);
    str = source[index++];

    while (index &lt; length) {
        ch = source[index++];
        str += ch;
        if (classMarker) {
            if (ch === &#39;]&#39;) {
                classMarker = false;
            }
        } else {
            if (ch === &#39;\\&#39;) {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (ch === &#39;/&#39;) {
                terminated = true;
                break;
            } else if (ch === &#39;[&#39;) {
                classMarker = true;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            }
        }
    }

    if (!terminated) {
        throwError({}, Messages.UnterminatedRegExp);
    }

    // Exclude leading and trailing slash.
    pattern = str.substr(1, str.length - 2);

    flags = &#39;&#39;;
    while (index &lt; length) {
        ch = source[index];
        if (!isIdentifierPart(ch.charCodeAt(0))) {
            break;
        }

        ++index;
        if (ch === &#39;\\&#39; &amp;&amp; index &lt; length) {
            ch = source[index];
            if (ch === &#39;u&#39;) {
                ++index;
                restore = index;
                ch = scanHexEscape(&#39;u&#39;);
                if (ch) {
                    flags += ch;
                    for (str += &#39;\\u&#39;; restore &lt; index; ++restore) {
                        str += source[restore];
                    }
                } else {
                    index = restore;
                    flags += &#39;u&#39;;
                    str += &#39;\\u&#39;;
                }
            } else {
                str += &#39;\\&#39;;
            }
        } else {
            flags += ch;
            str += ch;
        }
    }

    tmp = pattern;
    if (flags.indexOf(&#39;u&#39;) &gt;= 0) {
        // Replace each astral symbol and every Unicode code point
        // escape sequence that represents such a symbol with a single
        // ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        tmp = tmp
            .replace(/\\u\{([0-9a-fA-F]{5,6})\}/g, &#39;x&#39;)
            .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, &#39;x&#39;);
    }

    // First, detect invalid regular expressions.
    try {
        value = new RegExp(tmp);
    } catch (e) {
        throwError({}, Messages.InvalidRegExp);
    }

    // Return a regular expression object for this pattern-flag pair, or
    // `null` in case the current environment doesn&#39;t support the flags it
    // uses.
    try {
        value = new RegExp(pattern, flags);
    } catch (exception) {
        value = null;
    }

    peek();

    if (extra.tokenize) {
        return {
            type: Token.RegularExpression,
            value: value,
            regex: {
                pattern: pattern,
                flags: flags
            },
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }
    return {
        literal: str,
        value: value,
        regex: {
            pattern: pattern,
            flags: flags
        },
        range: [start, index]
    };
}

function isIdentifierName(token) {
    return token.type === Token.Identifier ||
        token.type === Token.Keyword ||
        token.type === Token.BooleanLiteral ||
        token.type === Token.NullLiteral;
}

function advanceSlash() {
    var prevToken,
        checkToken;
    // Using the following algorithm:
    // https://github.com/mozilla/sweet.js/wiki/design
    prevToken = extra.tokens[extra.tokens.length - 1];
    if (!prevToken) {
        // Nothing before that: it cannot be a division.
        return scanRegExp();
    }
    if (prevToken.type === &#39;Punctuator&#39;) {
        if (prevToken.value === &#39;)&#39;) {
            checkToken = extra.tokens[extra.openParenToken - 1];
            if (checkToken &amp;&amp;
                    checkToken.type === &#39;Keyword&#39; &amp;&amp;
                    (checkToken.value === &#39;if&#39; ||
                     checkToken.value === &#39;while&#39; ||
                     checkToken.value === &#39;for&#39; ||
                     checkToken.value === &#39;with&#39;)) {
                return scanRegExp();
            }
            return scanPunctuator();
        }
        if (prevToken.value === &#39;}&#39;) {
            // Dividing a function by anything makes little sense,
            // but we have to check for that.
            if (extra.tokens[extra.openCurlyToken - 3] &amp;&amp;
                    extra.tokens[extra.openCurlyToken - 3].type === &#39;Keyword&#39;) {
                // Anonymous function.
                checkToken = extra.tokens[extra.openCurlyToken - 4];
                if (!checkToken) {
                    return scanPunctuator();
                }
            } else if (extra.tokens[extra.openCurlyToken - 4] &amp;&amp;
                    extra.tokens[extra.openCurlyToken - 4].type === &#39;Keyword&#39;) {
                // Named function.
                checkToken = extra.tokens[extra.openCurlyToken - 5];
                if (!checkToken) {
                    return scanRegExp();
                }
            } else {
                return scanPunctuator();
            }
            // checkToken determines whether the function is
            // a declaration or an expression.
            if (FnExprTokens.indexOf(checkToken.value) &gt;= 0) {
                // It is an expression.
                return scanPunctuator();
            }
            // It is a declaration.
            return scanRegExp();
        }
        return scanRegExp();
    }
    if (prevToken.type === &#39;Keyword&#39;) {
        return scanRegExp();
    }
    return scanPunctuator();
}

function advance() {
    var ch;

    if (!state.inXJSChild) {
        skipComment();
    }

    if (index &gt;= length) {
        return {
            type: Token.EOF,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [index, index]
        };
    }

    if (state.inXJSChild) {
        return advanceXJSChild();
    }

    ch = source.charCodeAt(index);

    // Very common: ( and ) and ;
    if (ch === 40 || ch === 41 || ch === 58) {
        return scanPunctuator();
    }

    // String literal starts with single quote (#39) or double quote (#34).
    if (ch === 39 || ch === 34) {
        if (state.inXJSTag) {
            return scanXJSStringLiteral();
        }
        return scanStringLiteral();
    }

    if (state.inXJSTag &amp;&amp; isXJSIdentifierStart(ch)) {
        return scanXJSIdentifier();
    }

    if (ch === 96) {
        return scanTemplate();
    }
    if (isIdentifierStart(ch)) {
        return scanIdentifier();
    }

    // Dot (.) char #46 can also start a floating-point number, hence the need
    // to check the next character.
    if (ch === 46) {
        if (isDecimalDigit(source.charCodeAt(index + 1))) {
            return scanNumericLiteral();
        }
        return scanPunctuator();
    }

    if (isDecimalDigit(ch)) {
        return scanNumericLiteral();
    }

    // Slash (/) char #47 can also start a regex.
    if (extra.tokenize &amp;&amp; ch === 47) {
        return advanceSlash();
    }

    return scanPunctuator();
}

function lex() {
    var token;

    token = lookahead;
    index = token.range[1];
    lineNumber = token.lineNumber;
    lineStart = token.lineStart;

    lookahead = advance();

    index = token.range[1];
    lineNumber = token.lineNumber;
    lineStart = token.lineStart;

    return token;
}

function peek() {
    var pos, line, start;

    pos = index;
    line = lineNumber;
    start = lineStart;
    lookahead = advance();
    index = pos;
    lineNumber = line;
    lineStart = start;
}

function lookahead2() {
    var adv, pos, line, start, result;

    // If we are collecting the tokens, don&#39;t grab the next one yet.
    adv = (typeof extra.advance === &#39;function&#39;) ? extra.advance : advance;

    pos = index;
    line = lineNumber;
    start = lineStart;

    // Scan for the next immediate token.
    if (lookahead === null) {
        lookahead = adv();
    }
    index = lookahead.range[1];
    lineNumber = lookahead.lineNumber;
    lineStart = lookahead.lineStart;

    // Grab the token right after.
    result = adv();
    index = pos;
    lineNumber = line;
    lineStart = start;

    return result;
}

function rewind(token) {
    index = token.range[0];
    lineNumber = token.lineNumber;
    lineStart = token.lineStart;
    lookahead = token;
}

function markerCreate() {
    if (!extra.loc &amp;&amp; !extra.range) {
        return undefined;
    }
    skipComment();
    return {offset: index, line: lineNumber, col: index - lineStart};
}

function markerCreatePreserveWhitespace() {
    if (!extra.loc &amp;&amp; !extra.range) {
        return undefined;
    }
    return {offset: index, line: lineNumber, col: index - lineStart};
}

function processComment(node) {
    var lastChild,
        trailingComments,
        bottomRight = extra.bottomRightStack,
        last = bottomRight[bottomRight.length - 1];

    if (node.type === Syntax.Program) {
        if (node.body.length &gt; 0) {
            return;
        }
    }

    if (extra.trailingComments.length &gt; 0) {
        if (extra.trailingComments[0].range[0] &gt;= node.range[1]) {
            trailingComments = extra.trailingComments;
            extra.trailingComments = [];
        } else {
            extra.trailingComments.length = 0;
        }
    } else {
        if (last &amp;&amp; last.trailingComments &amp;&amp; last.trailingComments[0].range[0] &gt;= node.range[1]) {
            trailingComments = last.trailingComments;
            delete last.trailingComments;
        }
    }

    // Eating the stack.
    if (last) {
        while (last &amp;&amp; last.range[0] &gt;= node.range[0]) {
            lastChild = last;
            last = bottomRight.pop();
        }
    }

    if (lastChild) {
        if (lastChild.leadingComments &amp;&amp; lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] &lt;= node.range[0]) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
        }
    } else if (extra.leadingComments.length &gt; 0 &amp;&amp; extra.leadingComments[extra.leadingComments.length - 1].range[1] &lt;= node.range[0]) {
        node.leadingComments = extra.leadingComments;
        extra.leadingComments = [];
    }

    if (trailingComments) {
        node.trailingComments = trailingComments;
    }

    bottomRight.push(node);
}

function markerApply(marker, node) {
    if (extra.range) {
        node.range = [marker.offset, index];
    }
    if (extra.loc) {
        node.loc = {
            start: {
                line: marker.line,
                column: marker.col
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        node = delegate.postProcess(node);
    }
    if (extra.attachComment) {
        processComment(node);
    }
    return node;
}

SyntaxTreeDelegate = {

    name: &#39;SyntaxTree&#39;,

    postProcess: function (node) {
        return node;
    },

    createArrayExpression: function (elements) {
        return {
            type: Syntax.ArrayExpression,
            elements: elements
        };
    },

    createAssignmentExpression: function (operator, left, right) {
        return {
            type: Syntax.AssignmentExpression,
            operator: operator,
            left: left,
            right: right
        };
    },

    createBinaryExpression: function (operator, left, right) {
        var type = (operator === &#39;||&#39; || operator === &#39;&amp;&amp;&#39;) ? Syntax.LogicalExpression :
                    Syntax.BinaryExpression;
        return {
            type: type,
            operator: operator,
            left: left,
            right: right
        };
    },

    createBlockStatement: function (body) {
        return {
            type: Syntax.BlockStatement,
            body: body
        };
    },

    createBreakStatement: function (label) {
        return {
            type: Syntax.BreakStatement,
            label: label
        };
    },

    createCallExpression: function (callee, args) {
        return {
            type: Syntax.CallExpression,
            callee: callee,
            &#39;arguments&#39;: args
        };
    },

    createCatchClause: function (param, body) {
        return {
            type: Syntax.CatchClause,
            param: param,
            body: body
        };
    },

    createConditionalExpression: function (test, consequent, alternate) {
        return {
            type: Syntax.ConditionalExpression,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    },

    createContinueStatement: function (label) {
        return {
            type: Syntax.ContinueStatement,
            label: label
        };
    },

    createDebuggerStatement: function () {
        return {
            type: Syntax.DebuggerStatement
        };
    },

    createDoWhileStatement: function (body, test) {
        return {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
        };
    },

    createEmptyStatement: function () {
        return {
            type: Syntax.EmptyStatement
        };
    },

    createExpressionStatement: function (expression) {
        return {
            type: Syntax.ExpressionStatement,
            expression: expression
        };
    },

    createForStatement: function (init, test, update, body) {
        return {
            type: Syntax.ForStatement,
            init: init,
            test: test,
            update: update,
            body: body
        };
    },

    createForInStatement: function (left, right, body) {
        return {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: false
        };
    },

    createForOfStatement: function (left, right, body) {
        return {
            type: Syntax.ForOfStatement,
            left: left,
            right: right,
            body: body
        };
    },

    createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,
                                         isAsync, returnType, typeParameters) {
        var funDecl = {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            defaults: defaults,
            body: body,
            rest: rest,
            generator: generator,
            expression: expression,
            returnType: returnType,
            typeParameters: typeParameters
        };

        if (isAsync) {
            funDecl.async = true;
        }

        return funDecl;
    },

    createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,
                                        isAsync, returnType, typeParameters) {
        var funExpr = {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            defaults: defaults,
            body: body,
            rest: rest,
            generator: generator,
            expression: expression,
            returnType: returnType,
            typeParameters: typeParameters
        };

        if (isAsync) {
            funExpr.async = true;
        }

        return funExpr;
    },

    createIdentifier: function (name) {
        return {
            type: Syntax.Identifier,
            name: name,
            // Only here to initialize the shape of the object to ensure
            // that the &#39;typeAnnotation&#39; key is ordered before others that
            // are added later (like &#39;loc&#39; and &#39;range&#39;). This just helps
            // keep the shape of Identifier nodes consistent with everything
            // else.
            typeAnnotation: undefined,
            optional: undefined
        };
    },

    createTypeAnnotation: function (typeAnnotation) {
        return {
            type: Syntax.TypeAnnotation,
            typeAnnotation: typeAnnotation
        };
    },

    createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {
        return {
            type: Syntax.FunctionTypeAnnotation,
            params: params,
            returnType: returnType,
            rest: rest,
            typeParameters: typeParameters
        };
    },

    createFunctionTypeParam: function (name, typeAnnotation, optional) {
        return {
            type: Syntax.FunctionTypeParam,
            name: name,
            typeAnnotation: typeAnnotation,
            optional: optional
        };
    },

    createNullableTypeAnnotation: function (typeAnnotation) {
        return {
            type: Syntax.NullableTypeAnnotation,
            typeAnnotation: typeAnnotation
        };
    },

    createArrayTypeAnnotation: function (elementType) {
        return {
            type: Syntax.ArrayTypeAnnotation,
            elementType: elementType
        };
    },

    createGenericTypeAnnotation: function (id, typeParameters) {
        return {
            type: Syntax.GenericTypeAnnotation,
            id: id,
            typeParameters: typeParameters
        };
    },

    createQualifiedTypeIdentifier: function (qualification, id) {
        return {
            type: Syntax.QualifiedTypeIdentifier,
            qualification: qualification,
            id: id
        };
    },

    createTypeParameterDeclaration: function (params) {
        return {
            type: Syntax.TypeParameterDeclaration,
            params: params
        };
    },

    createTypeParameterInstantiation: function (params) {
        return {
            type: Syntax.TypeParameterInstantiation,
            params: params
        };
    },

    createAnyTypeAnnotation: function () {
        return {
            type: Syntax.AnyTypeAnnotation
        };
    },

    createBooleanTypeAnnotation: function () {
        return {
            type: Syntax.BooleanTypeAnnotation
        };
    },

    createNumberTypeAnnotation: function () {
        return {
            type: Syntax.NumberTypeAnnotation
        };
    },

    createStringTypeAnnotation: function () {
        return {
            type: Syntax.StringTypeAnnotation
        };
    },

    createStringLiteralTypeAnnotation: function (token) {
        return {
            type: Syntax.StringLiteralTypeAnnotation,
            value: token.value,
            raw: source.slice(token.range[0], token.range[1])
        };
    },

    createVoidTypeAnnotation: function () {
        return {
            type: Syntax.VoidTypeAnnotation
        };
    },

    createTypeofTypeAnnotation: function (argument) {
        return {
            type: Syntax.TypeofTypeAnnotation,
            argument: argument
        };
    },

    createTupleTypeAnnotation: function (types) {
        return {
            type: Syntax.TupleTypeAnnotation,
            types: types
        };
    },

    createObjectTypeAnnotation: function (properties, indexers, callProperties) {
        return {
            type: Syntax.ObjectTypeAnnotation,
            properties: properties,
            indexers: indexers,
            callProperties: callProperties
        };
    },

    createObjectTypeIndexer: function (id, key, value, isStatic) {
        return {
            type: Syntax.ObjectTypeIndexer,
            id: id,
            key: key,
            value: value,
            &quot;static&quot;: isStatic
        };
    },

    createObjectTypeCallProperty: function (value, isStatic) {
        return {
            type: Syntax.ObjectTypeCallProperty,
            value: value,
            &quot;static&quot;: isStatic
        };
    },

    createObjectTypeProperty: function (key, value, optional, isStatic) {
        return {
            type: Syntax.ObjectTypeProperty,
            key: key,
            value: value,
            optional: optional,
            &quot;static&quot;: isStatic
        };
    },

    createUnionTypeAnnotation: function (types) {
        return {
            type: Syntax.UnionTypeAnnotation,
            types: types
        };
    },

    createIntersectionTypeAnnotation: function (types) {
        return {
            type: Syntax.IntersectionTypeAnnotation,
            types: types
        };
    },

    createTypeAlias: function (id, typeParameters, right) {
        return {
            type: Syntax.TypeAlias,
            id: id,
            typeParameters: typeParameters,
            right: right
        };
    },

    createInterface: function (id, typeParameters, body, extended) {
        return {
            type: Syntax.InterfaceDeclaration,
            id: id,
            typeParameters: typeParameters,
            body: body,
            &quot;extends&quot;: extended
        };
    },

    createInterfaceExtends: function (id, typeParameters) {
        return {
            type: Syntax.InterfaceExtends,
            id: id,
            typeParameters: typeParameters
        };
    },

    createDeclareFunction: function (id) {
        return {
            type: Syntax.DeclareFunction,
            id: id
        };
    },

    createDeclareVariable: function (id) {
        return {
            type: Syntax.DeclareVariable,
            id: id
        };
    },

    createDeclareModule: function (id, body) {
        return {
            type: Syntax.DeclareModule,
            id: id,
            body: body
        };
    },

    createXJSAttribute: function (name, value) {
        return {
            type: Syntax.XJSAttribute,
            name: name,
            value: value || null
        };
    },

    createXJSSpreadAttribute: function (argument) {
        return {
            type: Syntax.XJSSpreadAttribute,
            argument: argument
        };
    },

    createXJSIdentifier: function (name) {
        return {
            type: Syntax.XJSIdentifier,
            name: name
        };
    },

    createXJSNamespacedName: function (namespace, name) {
        return {
            type: Syntax.XJSNamespacedName,
            namespace: namespace,
            name: name
        };
    },

    createXJSMemberExpression: function (object, property) {
        return {
            type: Syntax.XJSMemberExpression,
            object: object,
            property: property
        };
    },

    createXJSElement: function (openingElement, closingElement, children) {
        return {
            type: Syntax.XJSElement,
            openingElement: openingElement,
            closingElement: closingElement,
            children: children
        };
    },

    createXJSEmptyExpression: function () {
        return {
            type: Syntax.XJSEmptyExpression
        };
    },

    createXJSExpressionContainer: function (expression) {
        return {
            type: Syntax.XJSExpressionContainer,
            expression: expression
        };
    },

    createXJSOpeningElement: function (name, attributes, selfClosing) {
        return {
            type: Syntax.XJSOpeningElement,
            name: name,
            selfClosing: selfClosing,
            attributes: attributes
        };
    },

    createXJSClosingElement: function (name) {
        return {
            type: Syntax.XJSClosingElement,
            name: name
        };
    },

    createIfStatement: function (test, consequent, alternate) {
        return {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    },

    createLabeledStatement: function (label, body) {
        return {
            type: Syntax.LabeledStatement,
            label: label,
            body: body
        };
    },

    createLiteral: function (token) {
        var object = {
            type: Syntax.Literal,
            value: token.value,
            raw: source.slice(token.range[0], token.range[1])
        };
        if (token.regex) {
            object.regex = token.regex;
        }
        return object;
    },

    createMemberExpression: function (accessor, object, property) {
        return {
            type: Syntax.MemberExpression,
            computed: accessor === &#39;[&#39;,
            object: object,
            property: property
        };
    },

    createNewExpression: function (callee, args) {
        return {
            type: Syntax.NewExpression,
            callee: callee,
            &#39;arguments&#39;: args
        };
    },

    createObjectExpression: function (properties) {
        return {
            type: Syntax.ObjectExpression,
            properties: properties
        };
    },

    createPostfixExpression: function (operator, argument) {
        return {
            type: Syntax.UpdateExpression,
            operator: operator,
            argument: argument,
            prefix: false
        };
    },

    createProgram: function (body) {
        return {
            type: Syntax.Program,
            body: body
        };
    },

    createProperty: function (kind, key, value, method, shorthand, computed) {
        return {
            type: Syntax.Property,
            key: key,
            value: value,
            kind: kind,
            method: method,
            shorthand: shorthand,
            computed: computed
        };
    },

    createReturnStatement: function (argument) {
        return {
            type: Syntax.ReturnStatement,
            argument: argument
        };
    },

    createSequenceExpression: function (expressions) {
        return {
            type: Syntax.SequenceExpression,
            expressions: expressions
        };
    },

    createSwitchCase: function (test, consequent) {
        return {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
        };
    },

    createSwitchStatement: function (discriminant, cases) {
        return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
        };
    },

    createThisExpression: function () {
        return {
            type: Syntax.ThisExpression
        };
    },

    createThrowStatement: function (argument) {
        return {
            type: Syntax.ThrowStatement,
            argument: argument
        };
    },

    createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
        return {
            type: Syntax.TryStatement,
            block: block,
            guardedHandlers: guardedHandlers,
            handlers: handlers,
            finalizer: finalizer
        };
    },

    createUnaryExpression: function (operator, argument) {
        if (operator === &#39;++&#39; || operator === &#39;--&#39;) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        }
        return {
            type: Syntax.UnaryExpression,
            operator: operator,
            argument: argument,
            prefix: true
        };
    },

    createVariableDeclaration: function (declarations, kind) {
        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
        };
    },

    createVariableDeclarator: function (id, init) {
        return {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
        };
    },

    createWhileStatement: function (test, body) {
        return {
            type: Syntax.WhileStatement,
            test: test,
            body: body
        };
    },

    createWithStatement: function (object, body) {
        return {
            type: Syntax.WithStatement,
            object: object,
            body: body
        };
    },

    createTemplateElement: function (value, tail) {
        return {
            type: Syntax.TemplateElement,
            value: value,
            tail: tail
        };
    },

    createTemplateLiteral: function (quasis, expressions) {
        return {
            type: Syntax.TemplateLiteral,
            quasis: quasis,
            expressions: expressions
        };
    },

    createSpreadElement: function (argument) {
        return {
            type: Syntax.SpreadElement,
            argument: argument
        };
    },

    createSpreadProperty: function (argument) {
        return {
            type: Syntax.SpreadProperty,
            argument: argument
        };
    },

    createTaggedTemplateExpression: function (tag, quasi) {
        return {
            type: Syntax.TaggedTemplateExpression,
            tag: tag,
            quasi: quasi
        };
    },

    createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {
        var arrowExpr = {
            type: Syntax.ArrowFunctionExpression,
            id: null,
            params: params,
            defaults: defaults,
            body: body,
            rest: rest,
            generator: false,
            expression: expression
        };

        if (isAsync) {
            arrowExpr.async = true;
        }

        return arrowExpr;
    },

    createMethodDefinition: function (propertyType, kind, key, value) {
        return {
            type: Syntax.MethodDefinition,
            key: key,
            value: value,
            kind: kind,
            &#39;static&#39;: propertyType === ClassPropertyType[&quot;static&quot;]
        };
    },

    createClassProperty: function (key, typeAnnotation, computed, isStatic) {
        return {
            type: Syntax.ClassProperty,
            key: key,
            typeAnnotation: typeAnnotation,
            computed: computed,
            &quot;static&quot;: isStatic
        };
    },

    createClassBody: function (body) {
        return {
            type: Syntax.ClassBody,
            body: body
        };
    },

    createClassImplements: function (id, typeParameters) {
        return {
            type: Syntax.ClassImplements,
            id: id,
            typeParameters: typeParameters
        };
    },

    createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
        return {
            type: Syntax.ClassExpression,
            id: id,
            superClass: superClass,
            body: body,
            typeParameters: typeParameters,
            superTypeParameters: superTypeParameters,
            &quot;implements&quot;: implemented
        };
    },

    createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
        return {
            type: Syntax.ClassDeclaration,
            id: id,
            superClass: superClass,
            body: body,
            typeParameters: typeParameters,
            superTypeParameters: superTypeParameters,
            &quot;implements&quot;: implemented
        };
    },

    createModuleSpecifier: function (token) {
        return {
            type: Syntax.ModuleSpecifier,
            value: token.value,
            raw: source.slice(token.range[0], token.range[1])
        };
    },

    createExportSpecifier: function (id, name) {
        return {
            type: Syntax.ExportSpecifier,
            id: id,
            name: name
        };
    },

    createExportBatchSpecifier: function () {
        return {
            type: Syntax.ExportBatchSpecifier
        };
    },

    createImportDefaultSpecifier: function (id) {
        return {
            type: Syntax.ImportDefaultSpecifier,
            id: id
        };
    },

    createImportNamespaceSpecifier: function (id) {
        return {
            type: Syntax.ImportNamespaceSpecifier,
            id: id
        };
    },

    createExportDeclaration: function (isDefault, declaration, specifiers, source) {
        return {
            type: Syntax.ExportDeclaration,
            &#39;default&#39;: !!isDefault,
            declaration: declaration,
            specifiers: specifiers,
            source: source
        };
    },

    createImportSpecifier: function (id, name) {
        return {
            type: Syntax.ImportSpecifier,
            id: id,
            name: name
        };
    },

    createImportDeclaration: function (specifiers, source) {
        return {
            type: Syntax.ImportDeclaration,
            specifiers: specifiers,
            source: source
        };
    },

    createYieldExpression: function (argument, delegate) {
        return {
            type: Syntax.YieldExpression,
            argument: argument,
            delegate: delegate
        };
    },

    createAwaitExpression: function (argument) {
        return {
            type: Syntax.AwaitExpression,
            argument: argument
        };
    },

    createComprehensionExpression: function (filter, blocks, body) {
        return {
            type: Syntax.ComprehensionExpression,
            filter: filter,
            blocks: blocks,
            body: body
        };
    }

};

// Return true if there is a line terminator before the next token.

function peekLineTerminator() {
    var pos, line, start, found;

    pos = index;
    line = lineNumber;
    start = lineStart;
    skipComment();
    found = lineNumber !== line;
    index = pos;
    lineNumber = line;
    lineStart = start;

    return found;
}

// Throw an exception

function throwError(token, messageFormat) {
    var error,
        args = Array.prototype.slice.call(arguments, 2),
        msg = messageFormat.replace(
            /%(\d)/g,
            function (whole, index) {
                assert(index &lt; args.length, &#39;Message reference must be in range&#39;);
                return args[index];
            }
        );

    if (typeof token.lineNumber === &#39;number&#39;) {
        error = new Error(&#39;Line &#39; + token.lineNumber + &#39;: &#39; + msg);
        error.index = token.range[0];
        error.lineNumber = token.lineNumber;
        error.column = token.range[0] - lineStart + 1;
    } else {
        error = new Error(&#39;Line &#39; + lineNumber + &#39;: &#39; + msg);
        error.index = index;
        error.lineNumber = lineNumber;
        error.column = index - lineStart + 1;
    }

    error.description = msg;
    throw error;
}

function throwErrorTolerant() {
    try {
        throwError.apply(null, arguments);
    } catch (e) {
        if (extra.errors) {
            extra.errors.push(e);
        } else {
            throw e;
        }
    }
}

// Throw an exception because of the token.

function throwUnexpected(token) {
    if (token.type === Token.EOF) {
        throwError(token, Messages.UnexpectedEOS);
    }

    if (token.type === Token.NumericLiteral) {
        throwError(token, Messages.UnexpectedNumber);
    }

    if (token.type === Token.StringLiteral || token.type === Token.XJSText) {
        throwError(token, Messages.UnexpectedString);
    }

    if (token.type === Token.Identifier) {
        throwError(token, Messages.UnexpectedIdentifier);
    }

    if (token.type === Token.Keyword) {
        if (isFutureReservedWord(token.value)) {
            throwError(token, Messages.UnexpectedReserved);
        } else if (strict &amp;&amp; isStrictModeReservedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictReservedWord);
            return;
        }
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    if (token.type === Token.Template) {
        throwError(token, Messages.UnexpectedTemplate, token.value.raw);
    }

    // BooleanLiteral, NullLiteral, or Punctuator.
    throwError(token, Messages.UnexpectedToken, token.value);
}

// Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.

function expect(value) {
    var token = lex();
    if (token.type !== Token.Punctuator || token.value !== value) {
        throwUnexpected(token);
    }
}

// Expect the next token to match the specified keyword.
// If not, an exception will be thrown.

function expectKeyword(keyword, contextual) {
    var token = lex();
    if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||
            token.value !== keyword) {
        throwUnexpected(token);
    }
}

// Expect the next token to match the specified contextual keyword.
// If not, an exception will be thrown.

function expectContextualKeyword(keyword) {
    return expectKeyword(keyword, true);
}

// Return true if the next token matches the specified punctuator.

function match(value) {
    return lookahead.type === Token.Punctuator &amp;&amp; lookahead.value === value;
}

// Return true if the next token matches the specified keyword

function matchKeyword(keyword, contextual) {
    var expectedType = contextual ? Token.Identifier : Token.Keyword;
    return lookahead.type === expectedType &amp;&amp; lookahead.value === keyword;
}

// Return true if the next token matches the specified contextual keyword

function matchContextualKeyword(keyword) {
    return matchKeyword(keyword, true);
}

// Return true if the next token is an assignment operator

function matchAssign() {
    var op;

    if (lookahead.type !== Token.Punctuator) {
        return false;
    }
    op = lookahead.value;
    return op === &#39;=&#39; ||
        op === &#39;*=&#39; ||
        op === &#39;/=&#39; ||
        op === &#39;%=&#39; ||
        op === &#39;+=&#39; ||
        op === &#39;-=&#39; ||
        op === &#39;&lt;&lt;=&#39; ||
        op === &#39;&gt;&gt;=&#39; ||
        op === &#39;&gt;&gt;&gt;=&#39; ||
        op === &#39;&amp;=&#39; ||
        op === &#39;^=&#39; ||
        op === &#39;|=&#39;;
}

// Note that &#39;yield&#39; is treated as a keyword in strict mode, but a
// contextual keyword (identifier) in non-strict mode, so we need to
// use matchKeyword(&#39;yield&#39;, false) and matchKeyword(&#39;yield&#39;, true)
// (i.e. matchContextualKeyword) appropriately.
function matchYield() {
    return state.yieldAllowed &amp;&amp; matchKeyword(&#39;yield&#39;, !strict);
}

function matchAsync() {
    var backtrackToken = lookahead, matches = false;

    if (matchContextualKeyword(&#39;async&#39;)) {
        lex(); // Make sure peekLineTerminator() starts after &#39;async&#39;.
        matches = !peekLineTerminator();
        rewind(backtrackToken); // Revert the lex().
    }

    return matches;
}

function matchAwait() {
    return state.awaitAllowed &amp;&amp; matchContextualKeyword(&#39;await&#39;);
}

function consumeSemicolon() {
    var line, oldIndex = index, oldLineNumber = lineNumber,
        oldLineStart = lineStart, oldLookahead = lookahead;

    // Catch the very common case first: immediately a semicolon (char #59).
    if (source.charCodeAt(index) === 59) {
        lex();
        return;
    }

    line = lineNumber;
    skipComment();
    if (lineNumber !== line) {
        index = oldIndex;
        lineNumber = oldLineNumber;
        lineStart = oldLineStart;
        lookahead = oldLookahead;
        return;
    }

    if (match(&#39;;&#39;)) {
        lex();
        return;
    }

    if (lookahead.type !== Token.EOF &amp;&amp; !match(&#39;}&#39;)) {
        throwUnexpected(lookahead);
    }
}

// Return true if provided expression is LeftHandSideExpression

function isLeftHandSide(expr) {
    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
}

function isAssignableLeftHandSide(expr) {
    return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;
}

// 11.1.4 Array Initialiser

function parseArrayInitialiser() {
    var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true, body,
        marker = markerCreate();

    expect(&#39;[&#39;);
    while (!match(&#39;]&#39;)) {
        if (lookahead.value === &#39;for&#39; &amp;&amp;
                lookahead.type === Token.Keyword) {
            if (!possiblecomprehension) {
                throwError({}, Messages.ComprehensionError);
            }
            matchKeyword(&#39;for&#39;);
            tmp = parseForStatement({ignoreBody: true});
            tmp.of = tmp.type === Syntax.ForOfStatement;
            tmp.type = Syntax.ComprehensionBlock;
            if (tmp.left.kind) { // can&#39;t be let or const
                throwError({}, Messages.ComprehensionError);
            }
            blocks.push(tmp);
        } else if (lookahead.value === &#39;if&#39; &amp;&amp;
                       lookahead.type === Token.Keyword) {
            if (!possiblecomprehension) {
                throwError({}, Messages.ComprehensionError);
            }
            expectKeyword(&#39;if&#39;);
            expect(&#39;(&#39;);
            filter = parseExpression();
            expect(&#39;)&#39;);
        } else if (lookahead.value === &#39;,&#39; &amp;&amp;
                       lookahead.type === Token.Punctuator) {
            possiblecomprehension = false; // no longer allowed.
            lex();
            elements.push(null);
        } else {
            tmp = parseSpreadOrAssignmentExpression();
            elements.push(tmp);
            if (tmp &amp;&amp; tmp.type === Syntax.SpreadElement) {
                if (!match(&#39;]&#39;)) {
                    throwError({}, Messages.ElementAfterSpreadElement);
                }
            } else if (!(match(&#39;]&#39;) || matchKeyword(&#39;for&#39;) || matchKeyword(&#39;if&#39;))) {
                expect(&#39;,&#39;); // this lexes.
                possiblecomprehension = false;
            }
        }
    }

    expect(&#39;]&#39;);

    if (filter &amp;&amp; !blocks.length) {
        throwError({}, Messages.ComprehensionRequiresBlock);
    }

    if (blocks.length) {
        if (elements.length !== 1) {
            throwError({}, Messages.ComprehensionError);
        }
        return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));
    }
    return markerApply(marker, delegate.createArrayExpression(elements));
}

// 11.1.5 Object Initialiser

function parsePropertyFunction(options) {
    var previousStrict, previousYieldAllowed, previousAwaitAllowed,
        params, defaults, body, marker = markerCreate();

    previousStrict = strict;
    previousYieldAllowed = state.yieldAllowed;
    state.yieldAllowed = options.generator;
    previousAwaitAllowed = state.awaitAllowed;
    state.awaitAllowed = options.async;
    params = options.params || [];
    defaults = options.defaults || [];

    body = parseConciseBody();
    if (options.name &amp;&amp; strict &amp;&amp; isRestrictedWord(params[0].name)) {
        throwErrorTolerant(options.name, Messages.StrictParamName);
    }
    strict = previousStrict;
    state.yieldAllowed = previousYieldAllowed;
    state.awaitAllowed = previousAwaitAllowed;

    return markerApply(marker, delegate.createFunctionExpression(
        null,
        params,
        defaults,
        body,
        options.rest || null,
        options.generator,
        body.type !== Syntax.BlockStatement,
        options.async,
        options.returnType,
        options.typeParameters
    ));
}

function parsePropertyMethodFunction(options) {
    var previousStrict, tmp, method;

    previousStrict = strict;
    strict = true;

    tmp = parseParams();

    if (tmp.stricted) {
        throwErrorTolerant(tmp.stricted, tmp.message);
    }

    method = parsePropertyFunction({
        params: tmp.params,
        defaults: tmp.defaults,
        rest: tmp.rest,
        generator: options.generator,
        async: options.async,
        returnType: tmp.returnType,
        typeParameters: options.typeParameters
    });

    strict = previousStrict;

    return method;
}

function parseObjectPropertyKey() {
    var marker = markerCreate(),
        token = lex(),
        propertyKey,
        result;

    // Note: This function is called only from parseObjectProperty(), where
    // EOF and Punctuator tokens are already filtered out.

    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
        if (strict &amp;&amp; token.octal) {
            throwErrorTolerant(token, Messages.StrictOctalLiteral);
        }
        return markerApply(marker, delegate.createLiteral(token));
    }

    if (token.type === Token.Punctuator &amp;&amp; token.value === &#39;[&#39;) {
        // For computed properties we should skip the [ and ], and
        // capture in marker only the assignment expression itself.
        marker = markerCreate();
        propertyKey = parseAssignmentExpression();
        result = markerApply(marker, propertyKey);
        expect(&#39;]&#39;);
        return result;
    }

    return markerApply(marker, delegate.createIdentifier(token.value));
}

function parseObjectProperty() {
    var token, key, id, value, param, expr, computed,
        marker = markerCreate(), returnType;

    token = lookahead;
    computed = (token.value === &#39;[&#39;);

    if (token.type === Token.Identifier || computed || matchAsync()) {
        id = parseObjectPropertyKey();

        if (match(&#39;:&#39;)) {
            lex();

            return markerApply(
                marker,
                delegate.createProperty(
                    &#39;init&#39;,
                    id,
                    parseAssignmentExpression(),
                    false,
                    false,
                    computed
                )
            );
        }

        if (match(&#39;(&#39;)) {
            return markerApply(
                marker,
                delegate.createProperty(
                    &#39;init&#39;,
                    id,
                    parsePropertyMethodFunction({
                        generator: false,
                        async: false
                    }),
                    true,
                    false,
                    computed
                )
            );
        }

        // Property Assignment: Getter and Setter.

        if (token.value === &#39;get&#39;) {
            computed = (lookahead.value === &#39;[&#39;);
            key = parseObjectPropertyKey();

            expect(&#39;(&#39;);
            expect(&#39;)&#39;);
            if (match(&#39;:&#39;)) {
                returnType = parseTypeAnnotation();
            }

            return markerApply(
                marker,
                delegate.createProperty(
                    &#39;get&#39;,
                    key,
                    parsePropertyFunction({
                        generator: false,
                        async: false,
                        returnType: returnType
                    }),
                    false,
                    false,
                    computed
                )
            );
        }

        if (token.value === &#39;set&#39;) {
            computed = (lookahead.value === &#39;[&#39;);
            key = parseObjectPropertyKey();

            expect(&#39;(&#39;);
            token = lookahead;
            param = [ parseTypeAnnotatableIdentifier() ];
            expect(&#39;)&#39;);
            if (match(&#39;:&#39;)) {
                returnType = parseTypeAnnotation();
            }

            return markerApply(
                marker,
                delegate.createProperty(
                    &#39;set&#39;,
                    key,
                    parsePropertyFunction({
                        params: param,
                        generator: false,
                        async: false,
                        name: token,
                        returnType: returnType
                    }),
                    false,
                    false,
                    computed
                )
            );
        }

        if (token.value === &#39;async&#39;) {
            computed = (lookahead.value === &#39;[&#39;);
            key = parseObjectPropertyKey();

            return markerApply(
                marker,
                delegate.createProperty(
                    &#39;init&#39;,
                    key,
                    parsePropertyMethodFunction({
                        generator: false,
                        async: true
                    }),
                    true,
                    false,
                    computed
                )
            );
        }

        if (computed) {
            // Computed properties can only be used with full notation.
            throwUnexpected(lookahead);
        }

        return markerApply(
            marker,
            delegate.createProperty(&#39;init&#39;, id, id, false, true, false)
        );
    }

    if (token.type === Token.EOF || token.type === Token.Punctuator) {
        if (!match(&#39;*&#39;)) {
            throwUnexpected(token);
        }
        lex();

        computed = (lookahead.type === Token.Punctuator &amp;&amp; lookahead.value === &#39;[&#39;);

        id = parseObjectPropertyKey();

        if (!match(&#39;(&#39;)) {
            throwUnexpected(lex());
        }

        return markerApply(marker, delegate.createProperty(&#39;init&#39;, id, parsePropertyMethodFunction({ generator: true }), true, false, computed));
    }
    key = parseObjectPropertyKey();
    if (match(&#39;:&#39;)) {
        lex();
        return markerApply(marker, delegate.createProperty(&#39;init&#39;, key, parseAssignmentExpression(), false, false, false));
    }
    if (match(&#39;(&#39;)) {
        return markerApply(marker, delegate.createProperty(&#39;init&#39;, key, parsePropertyMethodFunction({ generator: false }), true, false, false));
    }
    throwUnexpected(lex());
}

function parseObjectSpreadProperty() {
    var marker = markerCreate();
    expect(&#39;...&#39;);
    return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));
}

function parseObjectInitialiser() {
    var properties = [], property, name, key, kind, map = {}, toString = String,
        marker = markerCreate();

    expect(&#39;{&#39;);

    while (!match(&#39;}&#39;)) {
        if (match(&#39;...&#39;)) {
            property = parseObjectSpreadProperty();
        } else {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === &#39;init&#39;) ? PropertyKind.Data : (property.kind === &#39;get&#39;) ? PropertyKind.Get : PropertyKind.Set;

            key = &#39;$&#39; + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict &amp;&amp; kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] &amp; kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }
        }

        properties.push(property);

        if (!match(&#39;}&#39;)) {
            expect(&#39;,&#39;);
        }
    }

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createObjectExpression(properties));
}

function parseTemplateElement(option) {
    var marker = markerCreate(),
        token = scanTemplateElement(option);
    if (strict &amp;&amp; token.octal) {
        throwError(token, Messages.StrictOctalLiteral);
    }
    return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));
}

function parseTemplateLiteral() {
    var quasi, quasis, expressions, marker = markerCreate();

    quasi = parseTemplateElement({ head: true });
    quasis = [ quasi ];
    expressions = [];

    while (!quasi.tail) {
        expressions.push(parseExpression());
        quasi = parseTemplateElement({ head: false });
        quasis.push(quasi);
    }

    return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));
}

// 11.1.6 The Grouping Operator

function parseGroupExpression() {
    var expr;

    expect(&#39;(&#39;);

    ++state.parenthesizedCount;

    expr = parseExpression();

    expect(&#39;)&#39;);

    return expr;
}

function matchAsyncFuncExprOrDecl() {
    var token;

    if (matchAsync()) {
        token = lookahead2();
        if (token.type === Token.Keyword &amp;&amp; token.value === &#39;function&#39;) {
            return true;
        }
    }

    return false;
}

// 11.1 Primary Expressions

function parsePrimaryExpression() {
    var marker, type, token, expr;

    type = lookahead.type;

    if (type === Token.Identifier) {
        marker = markerCreate();
        return markerApply(marker, delegate.createIdentifier(lex().value));
    }

    if (type === Token.StringLiteral || type === Token.NumericLiteral) {
        if (strict &amp;&amp; lookahead.octal) {
            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
        }
        marker = markerCreate();
        return markerApply(marker, delegate.createLiteral(lex()));
    }

    if (type === Token.Keyword) {
        if (matchKeyword(&#39;this&#39;)) {
            marker = markerCreate();
            lex();
            return markerApply(marker, delegate.createThisExpression());
        }

        if (matchKeyword(&#39;function&#39;)) {
            return parseFunctionExpression();
        }

        if (matchKeyword(&#39;class&#39;)) {
            return parseClassExpression();
        }

        if (matchKeyword(&#39;super&#39;)) {
            marker = markerCreate();
            lex();
            return markerApply(marker, delegate.createIdentifier(&#39;super&#39;));
        }
    }

    if (type === Token.BooleanLiteral) {
        marker = markerCreate();
        token = lex();
        token.value = (token.value === &#39;true&#39;);
        return markerApply(marker, delegate.createLiteral(token));
    }

    if (type === Token.NullLiteral) {
        marker = markerCreate();
        token = lex();
        token.value = null;
        return markerApply(marker, delegate.createLiteral(token));
    }

    if (match(&#39;[&#39;)) {
        return parseArrayInitialiser();
    }

    if (match(&#39;{&#39;)) {
        return parseObjectInitialiser();
    }

    if (match(&#39;(&#39;)) {
        return parseGroupExpression();
    }

    if (match(&#39;/&#39;) || match(&#39;/=&#39;)) {
        marker = markerCreate();
        return markerApply(marker, delegate.createLiteral(scanRegExp()));
    }

    if (type === Token.Template) {
        return parseTemplateLiteral();
    }

    if (match(&#39;&lt;&#39;)) {
        return parseXJSElement();
    }

    throwUnexpected(lex());
}

// 11.2 Left-Hand-Side Expressions

function parseArguments() {
    var args = [], arg;

    expect(&#39;(&#39;);

    if (!match(&#39;)&#39;)) {
        while (index &lt; length) {
            arg = parseSpreadOrAssignmentExpression();
            args.push(arg);

            if (match(&#39;)&#39;)) {
                break;
            } else if (arg.type === Syntax.SpreadElement) {
                throwError({}, Messages.ElementAfterSpreadElement);
            }

            expect(&#39;,&#39;);
        }
    }

    expect(&#39;)&#39;);

    return args;
}

function parseSpreadOrAssignmentExpression() {
    if (match(&#39;...&#39;)) {
        var marker = markerCreate();
        lex();
        return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));
    }
    return parseAssignmentExpression();
}

function parseNonComputedProperty() {
    var marker = markerCreate(),
        token = lex();

    if (!isIdentifierName(token)) {
        throwUnexpected(token);
    }

    return markerApply(marker, delegate.createIdentifier(token.value));
}

function parseNonComputedMember() {
    expect(&#39;.&#39;);

    return parseNonComputedProperty();
}

function parseComputedMember() {
    var expr;

    expect(&#39;[&#39;);

    expr = parseExpression();

    expect(&#39;]&#39;);

    return expr;
}

function parseNewExpression() {
    var callee, args, marker = markerCreate();

    expectKeyword(&#39;new&#39;);
    callee = parseLeftHandSideExpression();
    args = match(&#39;(&#39;) ? parseArguments() : [];

    return markerApply(marker, delegate.createNewExpression(callee, args));
}

function parseLeftHandSideExpressionAllowCall() {
    var expr, args, marker = markerCreate();

    expr = matchKeyword(&#39;new&#39;) ? parseNewExpression() : parsePrimaryExpression();

    while (match(&#39;.&#39;) || match(&#39;[&#39;) || match(&#39;(&#39;) || lookahead.type === Token.Template) {
        if (match(&#39;(&#39;)) {
            args = parseArguments();
            expr = markerApply(marker, delegate.createCallExpression(expr, args));
        } else if (match(&#39;[&#39;)) {
            expr = markerApply(marker, delegate.createMemberExpression(&#39;[&#39;, expr, parseComputedMember()));
        } else if (match(&#39;.&#39;)) {
            expr = markerApply(marker, delegate.createMemberExpression(&#39;.&#39;, expr, parseNonComputedMember()));
        } else {
            expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
        }
    }

    return expr;
}

function parseLeftHandSideExpression() {
    var expr, marker = markerCreate();

    expr = matchKeyword(&#39;new&#39;) ? parseNewExpression() : parsePrimaryExpression();

    while (match(&#39;.&#39;) || match(&#39;[&#39;) || lookahead.type === Token.Template) {
        if (match(&#39;[&#39;)) {
            expr = markerApply(marker, delegate.createMemberExpression(&#39;[&#39;, expr, parseComputedMember()));
        } else if (match(&#39;.&#39;)) {
            expr = markerApply(marker, delegate.createMemberExpression(&#39;.&#39;, expr, parseNonComputedMember()));
        } else {
            expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
        }
    }

    return expr;
}

// 11.3 Postfix Expressions

function parsePostfixExpression() {
    var marker = markerCreate(),
        expr = parseLeftHandSideExpressionAllowCall(),
        token;

    if (lookahead.type !== Token.Punctuator) {
        return expr;
    }

    if ((match(&#39;++&#39;) || match(&#39;--&#39;)) &amp;&amp; !peekLineTerminator()) {
        // 11.3.1, 11.3.2
        if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPostfix);
        }

        if (!isLeftHandSide(expr)) {
            throwError({}, Messages.InvalidLHSInAssignment);
        }

        token = lex();
        expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));
    }

    return expr;
}

// 11.4 Unary Operators

function parseUnaryExpression() {
    var marker, token, expr;

    if (lookahead.type !== Token.Punctuator &amp;&amp; lookahead.type !== Token.Keyword) {
        return parsePostfixExpression();
    }

    if (match(&#39;++&#39;) || match(&#39;--&#39;)) {
        marker = markerCreate();
        token = lex();
        expr = parseUnaryExpression();
        // 11.4.4, 11.4.5
        if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPrefix);
        }

        if (!isLeftHandSide(expr)) {
            throwError({}, Messages.InvalidLHSInAssignment);
        }

        return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
    }

    if (match(&#39;+&#39;) || match(&#39;-&#39;) || match(&#39;~&#39;) || match(&#39;!&#39;)) {
        marker = markerCreate();
        token = lex();
        expr = parseUnaryExpression();
        return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
    }

    if (matchKeyword(&#39;delete&#39;) || matchKeyword(&#39;void&#39;) || matchKeyword(&#39;typeof&#39;)) {
        marker = markerCreate();
        token = lex();
        expr = parseUnaryExpression();
        expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));
        if (strict &amp;&amp; expr.operator === &#39;delete&#39; &amp;&amp; expr.argument.type === Syntax.Identifier) {
            throwErrorTolerant({}, Messages.StrictDelete);
        }
        return expr;
    }

    return parsePostfixExpression();
}

function binaryPrecedence(token, allowIn) {
    var prec = 0;

    if (token.type !== Token.Punctuator &amp;&amp; token.type !== Token.Keyword) {
        return 0;
    }

    switch (token.value) {
    case &#39;||&#39;:
        prec = 1;
        break;

    case &#39;&amp;&amp;&#39;:
        prec = 2;
        break;

    case &#39;|&#39;:
        prec = 3;
        break;

    case &#39;^&#39;:
        prec = 4;
        break;

    case &#39;&amp;&#39;:
        prec = 5;
        break;

    case &#39;==&#39;:
    case &#39;!=&#39;:
    case &#39;===&#39;:
    case &#39;!==&#39;:
        prec = 6;
        break;

    case &#39;&lt;&#39;:
    case &#39;&gt;&#39;:
    case &#39;&lt;=&#39;:
    case &#39;&gt;=&#39;:
    case &#39;instanceof&#39;:
        prec = 7;
        break;

    case &#39;in&#39;:
        prec = allowIn ? 7 : 0;
        break;

    case &#39;&lt;&lt;&#39;:
    case &#39;&gt;&gt;&#39;:
    case &#39;&gt;&gt;&gt;&#39;:
        prec = 8;
        break;

    case &#39;+&#39;:
    case &#39;-&#39;:
        prec = 9;
        break;

    case &#39;*&#39;:
    case &#39;/&#39;:
    case &#39;%&#39;:
        prec = 11;
        break;

    default:
        break;
    }

    return prec;
}

// 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators

function parseBinaryExpression() {
    var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
        marker, markers;

    previousAllowIn = state.allowIn;
    state.allowIn = true;

    marker = markerCreate();
    left = parseUnaryExpression();

    token = lookahead;
    prec = binaryPrecedence(token, previousAllowIn);
    if (prec === 0) {
        return left;
    }
    token.prec = prec;
    lex();

    markers = [marker, markerCreate()];
    right = parseUnaryExpression();

    stack = [left, token, right];

    while ((prec = binaryPrecedence(lookahead, previousAllowIn)) &gt; 0) {

        // Reduce: make a binary expression from the three topmost entries.
        while ((stack.length &gt; 2) &amp;&amp; (prec &lt;= stack[stack.length - 2].prec)) {
            right = stack.pop();
            operator = stack.pop().value;
            left = stack.pop();
            expr = delegate.createBinaryExpression(operator, left, right);
            markers.pop();
            marker = markers.pop();
            markerApply(marker, expr);
            stack.push(expr);
            markers.push(marker);
        }

        // Shift.
        token = lex();
        token.prec = prec;
        stack.push(token);
        markers.push(markerCreate());
        expr = parseUnaryExpression();
        stack.push(expr);
    }

    state.allowIn = previousAllowIn;

    // Final reduce to clean-up the stack.
    i = stack.length - 1;
    expr = stack[i];
    markers.pop();
    while (i &gt; 1) {
        expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
        i -= 2;
        marker = markers.pop();
        markerApply(marker, expr);
    }

    return expr;
}

// 11.12 Conditional Operator

function parseConditionalExpression() {
    var expr, previousAllowIn, consequent, alternate, marker = markerCreate();
    expr = parseBinaryExpression();

    if (match(&#39;?&#39;)) {
        lex();
        previousAllowIn = state.allowIn;
        state.allowIn = true;
        consequent = parseAssignmentExpression();
        state.allowIn = previousAllowIn;
        expect(&#39;:&#39;);
        alternate = parseAssignmentExpression();

        expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));
    }

    return expr;
}

// 11.13 Assignment Operators

function reinterpretAsAssignmentBindingPattern(expr) {
    var i, len, property, element;

    if (expr.type === Syntax.ObjectExpression) {
        expr.type = Syntax.ObjectPattern;
        for (i = 0, len = expr.properties.length; i &lt; len; i += 1) {
            property = expr.properties[i];
            if (property.type === Syntax.SpreadProperty) {
                if (i &lt; len - 1) {
                    throwError({}, Messages.PropertyAfterSpreadProperty);
                }
                reinterpretAsAssignmentBindingPattern(property.argument);
            } else {
                if (property.kind !== &#39;init&#39;) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
                reinterpretAsAssignmentBindingPattern(property.value);
            }
        }
    } else if (expr.type === Syntax.ArrayExpression) {
        expr.type = Syntax.ArrayPattern;
        for (i = 0, len = expr.elements.length; i &lt; len; i += 1) {
            element = expr.elements[i];
            if (element) {
                reinterpretAsAssignmentBindingPattern(element);
            }
        }
    } else if (expr.type === Syntax.Identifier) {
        if (isRestrictedWord(expr.name)) {
            throwError({}, Messages.InvalidLHSInAssignment);
        }
    } else if (expr.type === Syntax.SpreadElement) {
        reinterpretAsAssignmentBindingPattern(expr.argument);
        if (expr.argument.type === Syntax.ObjectPattern) {
            throwError({}, Messages.ObjectPatternAsSpread);
        }
    } else {
        if (expr.type !== Syntax.MemberExpression &amp;&amp; expr.type !== Syntax.CallExpression &amp;&amp; expr.type !== Syntax.NewExpression) {
            throwError({}, Messages.InvalidLHSInAssignment);
        }
    }
}

function reinterpretAsDestructuredParameter(options, expr) {
    var i, len, property, element;

    if (expr.type === Syntax.ObjectExpression) {
        expr.type = Syntax.ObjectPattern;
        for (i = 0, len = expr.properties.length; i &lt; len; i += 1) {
            property = expr.properties[i];
            if (property.type === Syntax.SpreadProperty) {
                if (i &lt; len - 1) {
                    throwError({}, Messages.PropertyAfterSpreadProperty);
                }
                reinterpretAsDestructuredParameter(options, property.argument);
            } else {
                if (property.kind !== &#39;init&#39;) {
                    throwError({}, Messages.InvalidLHSInFormalsList);
                }
                reinterpretAsDestructuredParameter(options, property.value);
            }
        }
    } else if (expr.type === Syntax.ArrayExpression) {
        expr.type = Syntax.ArrayPattern;
        for (i = 0, len = expr.elements.length; i &lt; len; i += 1) {
            element = expr.elements[i];
            if (element) {
                reinterpretAsDestructuredParameter(options, element);
            }
        }
    } else if (expr.type === Syntax.Identifier) {
        validateParam(options, expr, expr.name);
    } else {
        if (expr.type !== Syntax.MemberExpression) {
            throwError({}, Messages.InvalidLHSInFormalsList);
        }
    }
}

function reinterpretAsCoverFormalsList(expressions) {
    var i, len, param, params, defaults, defaultCount, options, rest;

    params = [];
    defaults = [];
    defaultCount = 0;
    rest = null;
    options = {
        paramSet: {}
    };

    for (i = 0, len = expressions.length; i &lt; len; i += 1) {
        param = expressions[i];
        if (param.type === Syntax.Identifier) {
            params.push(param);
            defaults.push(null);
            validateParam(options, param, param.name);
        } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {
            reinterpretAsDestructuredParameter(options, param);
            params.push(param);
            defaults.push(null);
        } else if (param.type === Syntax.SpreadElement) {
            assert(i === len - 1, &#39;It is guaranteed that SpreadElement is last element by parseExpression&#39;);
            reinterpretAsDestructuredParameter(options, param.argument);
            rest = param.argument;
        } else if (param.type === Syntax.AssignmentExpression) {
            params.push(param.left);
            defaults.push(param.right);
            ++defaultCount;
            validateParam(options, param.left, param.left.name);
        } else {
            return null;
        }
    }

    if (options.message === Messages.StrictParamDupe) {
        throwError(
            strict ? options.stricted : options.firstRestricted,
            options.message
        );
    }

    if (defaultCount === 0) {
        defaults = [];
    }

    return {
        params: params,
        defaults: defaults,
        rest: rest,
        stricted: options.stricted,
        firstRestricted: options.firstRestricted,
        message: options.message
    };
}

function parseArrowFunctionExpression(options, marker) {
    var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;

    expect(&#39;=&gt;&#39;);

    previousStrict = strict;
    previousYieldAllowed = state.yieldAllowed;
    state.yieldAllowed = false;
    previousAwaitAllowed = state.awaitAllowed;
    state.awaitAllowed = !!options.async;
    body = parseConciseBody();

    if (strict &amp;&amp; options.firstRestricted) {
        throwError(options.firstRestricted, options.message);
    }
    if (strict &amp;&amp; options.stricted) {
        throwErrorTolerant(options.stricted, options.message);
    }

    strict = previousStrict;
    state.yieldAllowed = previousYieldAllowed;
    state.awaitAllowed = previousAwaitAllowed;

    return markerApply(marker, delegate.createArrowFunctionExpression(
        options.params,
        options.defaults,
        body,
        options.rest,
        body.type !== Syntax.BlockStatement,
        !!options.async
    ));
}

function parseAssignmentExpression() {
    var marker, expr, token, params, oldParenthesizedCount,
        backtrackToken = lookahead, possiblyAsync = false;

    if (matchYield()) {
        return parseYieldExpression();
    }

    if (matchAwait()) {
        return parseAwaitExpression();
    }

    oldParenthesizedCount = state.parenthesizedCount;

    marker = markerCreate();

    if (matchAsyncFuncExprOrDecl()) {
        return parseFunctionExpression();
    }

    if (matchAsync()) {
        // We can&#39;t be completely sure that this &#39;async&#39; token is
        // actually a contextual keyword modifying a function
        // expression, so we might have to un-lex() it later by
        // calling rewind(backtrackToken).
        possiblyAsync = true;
        lex();
    }

    if (match(&#39;(&#39;)) {
        token = lookahead2();
        if ((token.type === Token.Punctuator &amp;&amp; token.value === &#39;)&#39;) || token.value === &#39;...&#39;) {
            params = parseParams();
            if (!match(&#39;=&gt;&#39;)) {
                throwUnexpected(lex());
            }
            params.async = possiblyAsync;
            return parseArrowFunctionExpression(params, marker);
        }
    }

    token = lookahead;

    // If the &#39;async&#39; keyword is not followed by a &#39;(&#39; character or an
    // identifier, then it can&#39;t be an arrow function modifier, and we
    // should interpret it as a normal identifer.
    if (possiblyAsync &amp;&amp; !match(&#39;(&#39;) &amp;&amp; token.type !== Token.Identifier) {
        possiblyAsync = false;
        rewind(backtrackToken);
    }

    expr = parseConditionalExpression();

    if (match(&#39;=&gt;&#39;) &amp;&amp;
            (state.parenthesizedCount === oldParenthesizedCount ||
            state.parenthesizedCount === (oldParenthesizedCount + 1))) {
        if (expr.type === Syntax.Identifier) {
            params = reinterpretAsCoverFormalsList([ expr ]);
        } else if (expr.type === Syntax.SequenceExpression) {
            params = reinterpretAsCoverFormalsList(expr.expressions);
        }
        if (params) {
            params.async = possiblyAsync;
            return parseArrowFunctionExpression(params, marker);
        }
    }

    // If we haven&#39;t returned by now, then the &#39;async&#39; keyword was not
    // a function modifier, and we should rewind and interpret it as a
    // normal identifier.
    if (possiblyAsync) {
        possiblyAsync = false;
        rewind(backtrackToken);
        expr = parseConditionalExpression();
    }

    if (matchAssign()) {
        // 11.13.1
        if (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
            throwErrorTolerant(token, Messages.StrictLHSAssignment);
        }

        // ES.next draf 11.13 Runtime Semantics step 1
        if (match(&#39;=&#39;) &amp;&amp; (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
            reinterpretAsAssignmentBindingPattern(expr);
        } else if (!isLeftHandSide(expr)) {
            throwError({}, Messages.InvalidLHSInAssignment);
        }

        expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));
    }

    return expr;
}

// 11.14 Comma Operator

function parseExpression() {
    var marker, expr, expressions, sequence, coverFormalsList, spreadFound, oldParenthesizedCount;

    oldParenthesizedCount = state.parenthesizedCount;

    marker = markerCreate();
    expr = parseAssignmentExpression();
    expressions = [ expr ];

    if (match(&#39;,&#39;)) {
        while (index &lt; length) {
            if (!match(&#39;,&#39;)) {
                break;
            }

            lex();
            expr = parseSpreadOrAssignmentExpression();
            expressions.push(expr);

            if (expr.type === Syntax.SpreadElement) {
                spreadFound = true;
                if (!match(&#39;)&#39;)) {
                    throwError({}, Messages.ElementAfterSpreadElement);
                }
                break;
            }
        }

        sequence = markerApply(marker, delegate.createSequenceExpression(expressions));
    }

    if (match(&#39;=&gt;&#39;)) {
        // Do not allow nested parentheses on the LHS of the =&gt;.
        if (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === (oldParenthesizedCount + 1)) {
            expr = expr.type === Syntax.SequenceExpression ? expr.expressions : expressions;
            coverFormalsList = reinterpretAsCoverFormalsList(expr);
            if (coverFormalsList) {
                return parseArrowFunctionExpression(coverFormalsList, marker);
            }
        }
        throwUnexpected(lex());
    }

    if (spreadFound &amp;&amp; lookahead2().value !== &#39;=&gt;&#39;) {
        throwError({}, Messages.IllegalSpread);
    }

    return sequence || expr;
}

// 12.1 Block

function parseStatementList() {
    var list = [],
        statement;

    while (index &lt; length) {
        if (match(&#39;}&#39;)) {
            break;
        }
        statement = parseSourceElement();
        if (typeof statement === &#39;undefined&#39;) {
            break;
        }
        list.push(statement);
    }

    return list;
}

function parseBlock() {
    var block, marker = markerCreate();

    expect(&#39;{&#39;);

    block = parseStatementList();

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createBlockStatement(block));
}

// 12.2 Variable Statement

function parseTypeParameterDeclaration() {
    var marker = markerCreate(), paramTypes = [];

    expect(&#39;&lt;&#39;);
    while (!match(&#39;&gt;&#39;)) {
        paramTypes.push(parseVariableIdentifier());
        if (!match(&#39;&gt;&#39;)) {
            expect(&#39;,&#39;);
        }
    }
    expect(&#39;&gt;&#39;);

    return markerApply(marker, delegate.createTypeParameterDeclaration(
        paramTypes
    ));
}

function parseTypeParameterInstantiation() {
    var marker = markerCreate(), oldInType = state.inType, paramTypes = [];

    state.inType = true;

    expect(&#39;&lt;&#39;);
    while (!match(&#39;&gt;&#39;)) {
        paramTypes.push(parseType());
        if (!match(&#39;&gt;&#39;)) {
            expect(&#39;,&#39;);
        }
    }
    expect(&#39;&gt;&#39;);

    state.inType = oldInType;

    return markerApply(marker, delegate.createTypeParameterInstantiation(
        paramTypes
    ));
}

function parseObjectTypeIndexer(marker, isStatic) {
    var id, key, value;

    expect(&#39;[&#39;);
    id = parseObjectPropertyKey();
    expect(&#39;:&#39;);
    key = parseType();
    expect(&#39;]&#39;);
    expect(&#39;:&#39;);
    value = parseType();

    return markerApply(marker, delegate.createObjectTypeIndexer(
        id,
        key,
        value,
        isStatic
    ));
}

function parseObjectTypeMethodish(marker) {
    var params = [], rest = null, returnType, typeParameters = null;
    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    expect(&#39;(&#39;);
    while (lookahead.type === Token.Identifier) {
        params.push(parseFunctionTypeParam());
        if (!match(&#39;)&#39;)) {
            expect(&#39;,&#39;);
        }
    }

    if (match(&#39;...&#39;)) {
        lex();
        rest = parseFunctionTypeParam();
    }
    expect(&#39;)&#39;);
    expect(&#39;:&#39;);
    returnType = parseType();

    return markerApply(marker, delegate.createFunctionTypeAnnotation(
        params,
        returnType,
        rest,
        typeParameters
    ));
}

function parseObjectTypeMethod(marker, isStatic, key) {
    var optional = false, value;
    value = parseObjectTypeMethodish(marker);

    return markerApply(marker, delegate.createObjectTypeProperty(
        key,
        value,
        optional,
        isStatic
    ));
}

function parseObjectTypeCallProperty(marker, isStatic) {
    var valueMarker = markerCreate();
    return markerApply(marker, delegate.createObjectTypeCallProperty(
        parseObjectTypeMethodish(valueMarker),
        isStatic
    ));
}

function parseObjectType(allowStatic) {
    var callProperties = [], indexers = [], marker, optional = false,
        properties = [], property, propertyKey, propertyTypeAnnotation,
        token, isStatic;

    expect(&#39;{&#39;);

    while (!match(&#39;}&#39;)) {
        marker = markerCreate();
        if (allowStatic &amp;&amp; matchContextualKeyword(&#39;static&#39;)) {
            token = lex();
            isStatic = true;
        }

        if (match(&#39;[&#39;)) {
            indexers.push(parseObjectTypeIndexer(marker, isStatic));
        } else if (match(&#39;(&#39;) || match(&#39;&lt;&#39;)) {
            callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));
        } else {
            if (isStatic &amp;&amp; match(&#39;:&#39;)) {
                propertyKey = markerApply(marker, delegate.createIdentifier(token));
                throwErrorTolerant(token, Messages.StrictReservedWord);
            } else {
                propertyKey = parseObjectPropertyKey();
            }
            if (match(&#39;&lt;&#39;) || match(&#39;(&#39;)) {
                // This is a method property
                properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));
            } else {
                if (match(&#39;?&#39;)) {
                    lex();
                    optional = true;
                }
                expect(&#39;:&#39;);
                propertyTypeAnnotation = parseType();
                properties.push(markerApply(marker, delegate.createObjectTypeProperty(
                    propertyKey,
                    propertyTypeAnnotation,
                    optional,
                    isStatic
                )));
            }
        }

        if (match(&#39;;&#39;)) {
            lex();
        } else if (!match(&#39;}&#39;)) {
            throwUnexpected(lookahead);
        }
    }

    expect(&#39;}&#39;);

    return delegate.createObjectTypeAnnotation(
        properties,
        indexers,
        callProperties
    );
}

function parseGenericType() {
    var marker = markerCreate(), returnType = null,
        typeParameters = null, typeIdentifier,
        typeIdentifierMarker = markerCreate;

    typeIdentifier = parseVariableIdentifier();

    while (match(&#39;.&#39;)) {
        expect(&#39;.&#39;);
        typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(
            typeIdentifier,
            parseVariableIdentifier()
        ));
    }

    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterInstantiation();
    }

    return markerApply(marker, delegate.createGenericTypeAnnotation(
        typeIdentifier,
        typeParameters
    ));
}

function parseVoidType() {
    var marker = markerCreate();
    expectKeyword(&#39;void&#39;);
    return markerApply(marker, delegate.createVoidTypeAnnotation());
}

function parseTypeofType() {
    var argument, marker = markerCreate();
    expectKeyword(&#39;typeof&#39;);
    argument = parsePrimaryType();
    return markerApply(marker, delegate.createTypeofTypeAnnotation(
        argument
    ));
}

function parseTupleType() {
    var marker = markerCreate(), types = [];
    expect(&#39;[&#39;);
    // We allow trailing commas
    while (index &lt; length &amp;&amp; !match(&#39;]&#39;)) {
        types.push(parseType());
        if (match(&#39;]&#39;)) {
            break;
        }
        expect(&#39;,&#39;);
    }
    expect(&#39;]&#39;);
    return markerApply(marker, delegate.createTupleTypeAnnotation(
        types
    ));
}

function parseFunctionTypeParam() {
    var marker = markerCreate(), name, optional = false, typeAnnotation;
    name = parseVariableIdentifier();
    if (match(&#39;?&#39;)) {
        lex();
        optional = true;
    }
    expect(&#39;:&#39;);
    typeAnnotation = parseType();
    return markerApply(marker, delegate.createFunctionTypeParam(
        name,
        typeAnnotation,
        optional
    ));
}

function parseFunctionTypeParams() {
    var ret = { params: [], rest: null };
    while (lookahead.type === Token.Identifier) {
        ret.params.push(parseFunctionTypeParam());
        if (!match(&#39;)&#39;)) {
            expect(&#39;,&#39;);
        }
    }

    if (match(&#39;...&#39;)) {
        lex();
        ret.rest = parseFunctionTypeParam();
    }
    return ret;
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they&#39;re the
// primitives with which other types are constructed.
function parsePrimaryType() {
    var typeIdentifier = null, params = null, returnType = null,
        marker = markerCreate(), rest = null, tmp,
        typeParameters, token, type, isGroupedType = false;

    switch (lookahead.type) {
    case Token.Identifier:
        switch (lookahead.value) {
        case &#39;any&#39;:
            lex();
            return markerApply(marker, delegate.createAnyTypeAnnotation());
        case &#39;bool&#39;:  // fallthrough
        case &#39;boolean&#39;:
            lex();
            return markerApply(marker, delegate.createBooleanTypeAnnotation());
        case &#39;number&#39;:
            lex();
            return markerApply(marker, delegate.createNumberTypeAnnotation());
        case &#39;string&#39;:
            lex();
            return markerApply(marker, delegate.createStringTypeAnnotation());
        }
        return markerApply(marker, parseGenericType());
    case Token.Punctuator:
        switch (lookahead.value) {
        case &#39;{&#39;:
            return markerApply(marker, parseObjectType());
        case &#39;[&#39;:
            return parseTupleType();
        case &#39;&lt;&#39;:
            typeParameters = parseTypeParameterDeclaration();
            expect(&#39;(&#39;);
            tmp = parseFunctionTypeParams();
            params = tmp.params;
            rest = tmp.rest;
            expect(&#39;)&#39;);

            expect(&#39;=&gt;&#39;);

            returnType = parseType();

            return markerApply(marker, delegate.createFunctionTypeAnnotation(
                params,
                returnType,
                rest,
                typeParameters
            ));
        case &#39;(&#39;:
            lex();
            // Check to see if this is actually a grouped type
            if (!match(&#39;)&#39;) &amp;&amp; !match(&#39;...&#39;)) {
                if (lookahead.type === Token.Identifier) {
                    token = lookahead2();
                    isGroupedType = token.value !== &#39;?&#39; &amp;&amp; token.value !== &#39;:&#39;;
                } else {
                    isGroupedType = true;
                }
            }

            if (isGroupedType) {
                type = parseType();
                expect(&#39;)&#39;);

                // If we see a =&gt; next then someone was probably confused about
                // function types, so we can provide a better error message
                if (match(&#39;=&gt;&#39;)) {
                    throwError({}, Messages.ConfusedAboutFunctionType);
                }

                return type;
            }

            tmp = parseFunctionTypeParams();
            params = tmp.params;
            rest = tmp.rest;

            expect(&#39;)&#39;);

            expect(&#39;=&gt;&#39;);

            returnType = parseType();

            return markerApply(marker, delegate.createFunctionTypeAnnotation(
                params,
                returnType,
                rest,
                null /* typeParameters */
            ));
        }
        break;
    case Token.Keyword:
        switch (lookahead.value) {
        case &#39;void&#39;:
            return markerApply(marker, parseVoidType());
        case &#39;typeof&#39;:
            return markerApply(marker, parseTypeofType());
        }
        break;
    case Token.StringLiteral:
        token = lex();
        if (token.octal) {
            throwError(token, Messages.StrictOctalLiteral);
        }
        return markerApply(marker, delegate.createStringLiteralTypeAnnotation(
            token
        ));
    }

    throwUnexpected(lookahead);
}

function parsePostfixType() {
    var marker = markerCreate(), t = parsePrimaryType();
    if (match(&#39;[&#39;)) {
        expect(&#39;[&#39;);
        expect(&#39;]&#39;);
        return markerApply(marker, delegate.createArrayTypeAnnotation(t));
    }
    return t;
}

function parsePrefixType() {
    var marker = markerCreate();
    if (match(&#39;?&#39;)) {
        lex();
        return markerApply(marker, delegate.createNullableTypeAnnotation(
            parsePrefixType()
        ));
    }
    return parsePostfixType();
}

function parseIntersectionType() {
    var marker = markerCreate(), type, types;
    type = parsePrefixType();
    types = [type];
    while (match(&#39;&amp;&#39;)) {
        lex();
        types.push(parsePrefixType());
    }

    return types.length === 1 ?
            type :
            markerApply(marker, delegate.createIntersectionTypeAnnotation(
                types
            ));
}

function parseUnionType() {
    var marker = markerCreate(), type, types;
    type = parseIntersectionType();
    types = [type];
    while (match(&#39;|&#39;)) {
        lex();
        types.push(parseIntersectionType());
    }
    return types.length === 1 ?
            type :
            markerApply(marker, delegate.createUnionTypeAnnotation(
                types
            ));
}

function parseType() {
    var oldInType = state.inType, type;
    state.inType = true;

    type = parseUnionType();

    state.inType = oldInType;
    return type;
}

function parseTypeAnnotation() {
    var marker = markerCreate(), type;

    expect(&#39;:&#39;);
    type = parseType();

    return markerApply(marker, delegate.createTypeAnnotation(type));
}

function parseVariableIdentifier() {
    var marker = markerCreate(),
        token = lex();

    if (token.type !== Token.Identifier) {
        throwUnexpected(token);
    }

    return markerApply(marker, delegate.createIdentifier(token.value));
}

function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
    var marker = markerCreate(),
        ident = parseVariableIdentifier(),
        isOptionalParam = false;

    if (canBeOptionalParam &amp;&amp; match(&#39;?&#39;)) {
        expect(&#39;?&#39;);
        isOptionalParam = true;
    }

    if (requireTypeAnnotation || match(&#39;:&#39;)) {
        ident.typeAnnotation = parseTypeAnnotation();
        ident = markerApply(marker, ident);
    }

    if (isOptionalParam) {
        ident.optional = true;
        ident = markerApply(marker, ident);
    }

    return ident;
}

function parseVariableDeclaration(kind) {
    var id,
        marker = markerCreate(),
        init = null,
        typeAnnotationMarker = markerCreate();
    if (match(&#39;{&#39;)) {
        id = parseObjectInitialiser();
        reinterpretAsAssignmentBindingPattern(id);
        if (match(&#39;:&#39;)) {
            id.typeAnnotation = parseTypeAnnotation();
            markerApply(typeAnnotationMarker, id);
        }
    } else if (match(&#39;[&#39;)) {
        id = parseArrayInitialiser();
        reinterpretAsAssignmentBindingPattern(id);
        if (match(&#39;:&#39;)) {
            id.typeAnnotation = parseTypeAnnotation();
            markerApply(typeAnnotationMarker, id);
        }
    } else {
        id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();
        // 12.2.1
        if (strict &amp;&amp; isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }
    }

    if (kind === &#39;const&#39;) {
        if (!match(&#39;=&#39;)) {
            throwError({}, Messages.NoUnintializedConst);
        }
        expect(&#39;=&#39;);
        init = parseAssignmentExpression();
    } else if (match(&#39;=&#39;)) {
        lex();
        init = parseAssignmentExpression();
    }

    return markerApply(marker, delegate.createVariableDeclarator(id, init));
}

function parseVariableDeclarationList(kind) {
    var list = [];

    do {
        list.push(parseVariableDeclaration(kind));
        if (!match(&#39;,&#39;)) {
            break;
        }
        lex();
    } while (index &lt; length);

    return list;
}

function parseVariableStatement() {
    var declarations, marker = markerCreate();

    expectKeyword(&#39;var&#39;);

    declarations = parseVariableDeclarationList();

    consumeSemicolon();

    return markerApply(marker, delegate.createVariableDeclaration(declarations, &#39;var&#39;));
}

// kind may be `const` or `let`
// Both are experimental and not in the specification yet.
// see http://wiki.ecmascript.org/doku.php?id=harmony:const
// and http://wiki.ecmascript.org/doku.php?id=harmony:let
function parseConstLetDeclaration(kind) {
    var declarations, marker = markerCreate();

    expectKeyword(kind);

    declarations = parseVariableDeclarationList(kind);

    consumeSemicolon();

    return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));
}

// people.mozilla.org/~jorendorff/es6-draft.html

function parseModuleSpecifier() {
    var marker = markerCreate(),
        specifier;

    if (lookahead.type !== Token.StringLiteral) {
        throwError({}, Messages.InvalidModuleSpecifier);
    }
    specifier = delegate.createModuleSpecifier(lookahead);
    lex();
    return markerApply(marker, specifier);
}

function parseExportBatchSpecifier() {
    var marker = markerCreate();
    expect(&#39;*&#39;);
    return markerApply(marker, delegate.createExportBatchSpecifier());
}

function parseExportSpecifier() {
    var id, name = null, marker = markerCreate(), from;
    if (matchKeyword(&#39;default&#39;)) {
        lex();
        id = markerApply(marker, delegate.createIdentifier(&#39;default&#39;));
        // export {default} from &quot;something&quot;;
    } else {
        id = parseVariableIdentifier();
    }
    if (matchContextualKeyword(&#39;as&#39;)) {
        lex();
        name = parseNonComputedProperty();
    }

    return markerApply(marker, delegate.createExportSpecifier(id, name));
}

function parseExportDeclaration() {
    var backtrackToken, id, previousAllowKeyword, declaration = null,
        isExportFromIdentifier,
        src = null, specifiers = [],
        marker = markerCreate();

    expectKeyword(&#39;export&#39;);

    if (matchKeyword(&#39;default&#39;)) {
        // covers:
        // export default ...
        lex();
        if (matchKeyword(&#39;function&#39;) || matchKeyword(&#39;class&#39;)) {
            backtrackToken = lookahead;
            lex();
            if (isIdentifierName(lookahead)) {
                // covers:
                // export default function foo () {}
                // export default class foo {}
                id = parseNonComputedProperty();
                rewind(backtrackToken);
                return markerApply(marker, delegate.createExportDeclaration(true, parseSourceElement(), [id], null));
            }
            // covers:
            // export default function () {}
            // export default class {}
            rewind(backtrackToken);
            switch (lookahead.value) {
            case &#39;class&#39;:
                return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));
            case &#39;function&#39;:
                return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));
            }
        }

        if (matchContextualKeyword(&#39;from&#39;)) {
            throwError({}, Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        if (match(&#39;{&#39;)) {
            declaration = parseObjectInitialiser();
        } else if (match(&#39;[&#39;)) {
            declaration = parseArrayInitialiser();
        } else {
            declaration = parseAssignmentExpression();
        }
        consumeSemicolon();
        return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));
    }

    // non-default export
    if (lookahead.type === Token.Keyword) {
        // covers:
        // export var f = 1;
        switch (lookahead.value) {
        case &#39;let&#39;:
        case &#39;const&#39;:
        case &#39;var&#39;:
        case &#39;class&#39;:
        case &#39;function&#39;:
            return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));
        }
    }

    if (match(&#39;*&#39;)) {
        // covers:
        // export * from &quot;foo&quot;;
        specifiers.push(parseExportBatchSpecifier());

        if (!matchContextualKeyword(&#39;from&#39;)) {
            throwError({}, lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));
    }

    expect(&#39;{&#39;);
    do {
        isExportFromIdentifier = isExportFromIdentifier || matchKeyword(&#39;default&#39;);
        specifiers.push(parseExportSpecifier());
    } while (match(&#39;,&#39;) &amp;&amp; lex());
    expect(&#39;}&#39;);

    if (matchContextualKeyword(&#39;from&#39;)) {
        // covering:
        // export {default} from &quot;foo&quot;;
        // export {foo} from &quot;foo&quot;;
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();
    } else if (isExportFromIdentifier) {
        // covering:
        // export {default}; // missing fromClause
        throwError({}, lookahead.value ?
                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
    } else {
        // cover
        // export {foo};
        consumeSemicolon();
    }
    return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));
}

function parseImportSpecifier() {
    // import {&lt;foo as bar&gt;} ...;
    var id, name = null, marker = markerCreate();

    id = parseNonComputedProperty();
    if (matchContextualKeyword(&#39;as&#39;)) {
        lex();
        name = parseVariableIdentifier();
    }

    return markerApply(marker, delegate.createImportSpecifier(id, name));
}

function parseNamedImports() {
    var specifiers = [];
    // {foo, bar as bas}
    expect(&#39;{&#39;);
    do {
        specifiers.push(parseImportSpecifier());
    } while (match(&#39;,&#39;) &amp;&amp; lex());
    expect(&#39;}&#39;);
    return specifiers;
}

function parseImportDefaultSpecifier() {
    // import &lt;foo&gt; ...;
    var id, marker = markerCreate();

    id = parseNonComputedProperty();

    return markerApply(marker, delegate.createImportDefaultSpecifier(id));
}

function parseImportNamespaceSpecifier() {
    // import &lt;* as foo&gt; ...;
    var id, marker = markerCreate();

    expect(&#39;*&#39;);
    if (!matchContextualKeyword(&#39;as&#39;)) {
        throwError({}, Messages.NoAsAfterImportNamespace);
    }
    lex();
    id = parseNonComputedProperty();

    return markerApply(marker, delegate.createImportNamespaceSpecifier(id));
}

function parseImportDeclaration() {
    var specifiers, src, marker = markerCreate();

    expectKeyword(&#39;import&#39;);
    specifiers = [];

    if (lookahead.type === Token.StringLiteral) {
        // covers:
        // import &quot;foo&quot;;
        src = parseModuleSpecifier();
        consumeSemicolon();
        return markerApply(marker, delegate.createImportDeclaration(specifiers, src));
    }

    if (!matchKeyword(&#39;default&#39;) &amp;&amp; isIdentifierName(lookahead)) {
        // covers:
        // import foo
        // import foo, ...
        specifiers.push(parseImportDefaultSpecifier());
        if (match(&#39;,&#39;)) {
            lex();
        }
    }
    if (match(&#39;*&#39;)) {
        // covers:
        // import foo, * as foo
        // import * as foo
        specifiers.push(parseImportNamespaceSpecifier());
    } else if (match(&#39;{&#39;)) {
        // covers:
        // import foo, {bar}
        // import {bar}
        specifiers = specifiers.concat(parseNamedImports());
    }

    if (!matchContextualKeyword(&#39;from&#39;)) {
        throwError({}, lookahead.value ?
                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
    }
    lex();
    src = parseModuleSpecifier();
    consumeSemicolon();

    return markerApply(marker, delegate.createImportDeclaration(specifiers, src));
}

// 12.3 Empty Statement

function parseEmptyStatement() {
    var marker = markerCreate();
    expect(&#39;;&#39;);
    return markerApply(marker, delegate.createEmptyStatement());
}

// 12.4 Expression Statement

function parseExpressionStatement() {
    var marker = markerCreate(), expr = parseExpression();
    consumeSemicolon();
    return markerApply(marker, delegate.createExpressionStatement(expr));
}

// 12.5 If statement

function parseIfStatement() {
    var test, consequent, alternate, marker = markerCreate();

    expectKeyword(&#39;if&#39;);

    expect(&#39;(&#39;);

    test = parseExpression();

    expect(&#39;)&#39;);

    consequent = parseStatement();

    if (matchKeyword(&#39;else&#39;)) {
        lex();
        alternate = parseStatement();
    } else {
        alternate = null;
    }

    return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));
}

// 12.6 Iteration Statements

function parseDoWhileStatement() {
    var body, test, oldInIteration, marker = markerCreate();

    expectKeyword(&#39;do&#39;);

    oldInIteration = state.inIteration;
    state.inIteration = true;

    body = parseStatement();

    state.inIteration = oldInIteration;

    expectKeyword(&#39;while&#39;);

    expect(&#39;(&#39;);

    test = parseExpression();

    expect(&#39;)&#39;);

    if (match(&#39;;&#39;)) {
        lex();
    }

    return markerApply(marker, delegate.createDoWhileStatement(body, test));
}

function parseWhileStatement() {
    var test, body, oldInIteration, marker = markerCreate();

    expectKeyword(&#39;while&#39;);

    expect(&#39;(&#39;);

    test = parseExpression();

    expect(&#39;)&#39;);

    oldInIteration = state.inIteration;
    state.inIteration = true;

    body = parseStatement();

    state.inIteration = oldInIteration;

    return markerApply(marker, delegate.createWhileStatement(test, body));
}

function parseForVariableDeclaration() {
    var marker = markerCreate(),
        token = lex(),
        declarations = parseVariableDeclarationList();

    return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));
}

function parseForStatement(opts) {
    var init, test, update, left, right, body, operator, oldInIteration,
        marker = markerCreate();
    init = test = update = null;
    expectKeyword(&#39;for&#39;);

    // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&amp;s=each
    if (matchContextualKeyword(&#39;each&#39;)) {
        throwError({}, Messages.EachNotAllowed);
    }

    expect(&#39;(&#39;);

    if (match(&#39;;&#39;)) {
        lex();
    } else {
        if (matchKeyword(&#39;var&#39;) || matchKeyword(&#39;let&#39;) || matchKeyword(&#39;const&#39;)) {
            state.allowIn = false;
            init = parseForVariableDeclaration();
            state.allowIn = true;

            if (init.declarations.length === 1) {
                if (matchKeyword(&#39;in&#39;) || matchContextualKeyword(&#39;of&#39;)) {
                    operator = lookahead;
                    if (!((operator.value === &#39;in&#39; || init.kind !== &#39;var&#39;) &amp;&amp; init.declarations[0].init)) {
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                }
            }
        } else {
            state.allowIn = false;
            init = parseExpression();
            state.allowIn = true;

            if (matchContextualKeyword(&#39;of&#39;)) {
                operator = lex();
                left = init;
                right = parseExpression();
                init = null;
            } else if (matchKeyword(&#39;in&#39;)) {
                // LeftHandSideExpression
                if (!isAssignableLeftHandSide(init)) {
                    throwError({}, Messages.InvalidLHSInForIn);
                }
                operator = lex();
                left = init;
                right = parseExpression();
                init = null;
            }
        }

        if (typeof left === &#39;undefined&#39;) {
            expect(&#39;;&#39;);
        }
    }

    if (typeof left === &#39;undefined&#39;) {

        if (!match(&#39;;&#39;)) {
            test = parseExpression();
        }
        expect(&#39;;&#39;);

        if (!match(&#39;)&#39;)) {
            update = parseExpression();
        }
    }

    expect(&#39;)&#39;);

    oldInIteration = state.inIteration;
    state.inIteration = true;

    if (!(opts !== undefined &amp;&amp; opts.ignoreBody)) {
        body = parseStatement();
    }

    state.inIteration = oldInIteration;

    if (typeof left === &#39;undefined&#39;) {
        return markerApply(marker, delegate.createForStatement(init, test, update, body));
    }

    if (operator.value === &#39;in&#39;) {
        return markerApply(marker, delegate.createForInStatement(left, right, body));
    }
    return markerApply(marker, delegate.createForOfStatement(left, right, body));
}

// 12.7 The continue statement

function parseContinueStatement() {
    var label = null, key, marker = markerCreate();

    expectKeyword(&#39;continue&#39;);

    // Optimize the most common form: &#39;continue;&#39;.
    if (source.charCodeAt(index) === 59) {
        lex();

        if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return markerApply(marker, delegate.createContinueStatement(null));
    }

    if (peekLineTerminator()) {
        if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return markerApply(marker, delegate.createContinueStatement(null));
    }

    if (lookahead.type === Token.Identifier) {
        label = parseVariableIdentifier();

        key = &#39;$&#39; + label.name;
        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
        }
    }

    consumeSemicolon();

    if (label === null &amp;&amp; !state.inIteration) {
        throwError({}, Messages.IllegalContinue);
    }

    return markerApply(marker, delegate.createContinueStatement(label));
}

// 12.8 The break statement

function parseBreakStatement() {
    var label = null, key, marker = markerCreate();

    expectKeyword(&#39;break&#39;);

    // Catch the very common case first: immediately a semicolon (char #59).
    if (source.charCodeAt(index) === 59) {
        lex();

        if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return markerApply(marker, delegate.createBreakStatement(null));
    }

    if (peekLineTerminator()) {
        if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return markerApply(marker, delegate.createBreakStatement(null));
    }

    if (lookahead.type === Token.Identifier) {
        label = parseVariableIdentifier();

        key = &#39;$&#39; + label.name;
        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
        }
    }

    consumeSemicolon();

    if (label === null &amp;&amp; !(state.inIteration || state.inSwitch)) {
        throwError({}, Messages.IllegalBreak);
    }

    return markerApply(marker, delegate.createBreakStatement(label));
}

// 12.9 The return statement

function parseReturnStatement() {
    var argument = null, marker = markerCreate();

    expectKeyword(&#39;return&#39;);

    if (!state.inFunctionBody) {
        throwErrorTolerant({}, Messages.IllegalReturn);
    }

    // &#39;return&#39; followed by a space and an identifier is very common.
    if (source.charCodeAt(index) === 32) {
        if (isIdentifierStart(source.charCodeAt(index + 1))) {
            argument = parseExpression();
            consumeSemicolon();
            return markerApply(marker, delegate.createReturnStatement(argument));
        }
    }

    if (peekLineTerminator()) {
        return markerApply(marker, delegate.createReturnStatement(null));
    }

    if (!match(&#39;;&#39;)) {
        if (!match(&#39;}&#39;) &amp;&amp; lookahead.type !== Token.EOF) {
            argument = parseExpression();
        }
    }

    consumeSemicolon();

    return markerApply(marker, delegate.createReturnStatement(argument));
}

// 12.10 The with statement

function parseWithStatement() {
    var object, body, marker = markerCreate();

    if (strict) {
        throwErrorTolerant({}, Messages.StrictModeWith);
    }

    expectKeyword(&#39;with&#39;);

    expect(&#39;(&#39;);

    object = parseExpression();

    expect(&#39;)&#39;);

    body = parseStatement();

    return markerApply(marker, delegate.createWithStatement(object, body));
}

// 12.10 The swith statement

function parseSwitchCase() {
    var test,
        consequent = [],
        sourceElement,
        marker = markerCreate();

    if (matchKeyword(&#39;default&#39;)) {
        lex();
        test = null;
    } else {
        expectKeyword(&#39;case&#39;);
        test = parseExpression();
    }
    expect(&#39;:&#39;);

    while (index &lt; length) {
        if (match(&#39;}&#39;) || matchKeyword(&#39;default&#39;) || matchKeyword(&#39;case&#39;)) {
            break;
        }
        sourceElement = parseSourceElement();
        if (typeof sourceElement === &#39;undefined&#39;) {
            break;
        }
        consequent.push(sourceElement);
    }

    return markerApply(marker, delegate.createSwitchCase(test, consequent));
}

function parseSwitchStatement() {
    var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();

    expectKeyword(&#39;switch&#39;);

    expect(&#39;(&#39;);

    discriminant = parseExpression();

    expect(&#39;)&#39;);

    expect(&#39;{&#39;);

    cases = [];

    if (match(&#39;}&#39;)) {
        lex();
        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
    }

    oldInSwitch = state.inSwitch;
    state.inSwitch = true;
    defaultFound = false;

    while (index &lt; length) {
        if (match(&#39;}&#39;)) {
            break;
        }
        clause = parseSwitchCase();
        if (clause.test === null) {
            if (defaultFound) {
                throwError({}, Messages.MultipleDefaultsInSwitch);
            }
            defaultFound = true;
        }
        cases.push(clause);
    }

    state.inSwitch = oldInSwitch;

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
}

// 12.13 The throw statement

function parseThrowStatement() {
    var argument, marker = markerCreate();

    expectKeyword(&#39;throw&#39;);

    if (peekLineTerminator()) {
        throwError({}, Messages.NewlineAfterThrow);
    }

    argument = parseExpression();

    consumeSemicolon();

    return markerApply(marker, delegate.createThrowStatement(argument));
}

// 12.14 The try statement

function parseCatchClause() {
    var param, body, marker = markerCreate();

    expectKeyword(&#39;catch&#39;);

    expect(&#39;(&#39;);
    if (match(&#39;)&#39;)) {
        throwUnexpected(lookahead);
    }

    param = parseExpression();
    // 12.14.1
    if (strict &amp;&amp; param.type === Syntax.Identifier &amp;&amp; isRestrictedWord(param.name)) {
        throwErrorTolerant({}, Messages.StrictCatchVariable);
    }

    expect(&#39;)&#39;);
    body = parseBlock();
    return markerApply(marker, delegate.createCatchClause(param, body));
}

function parseTryStatement() {
    var block, handlers = [], finalizer = null, marker = markerCreate();

    expectKeyword(&#39;try&#39;);

    block = parseBlock();

    if (matchKeyword(&#39;catch&#39;)) {
        handlers.push(parseCatchClause());
    }

    if (matchKeyword(&#39;finally&#39;)) {
        lex();
        finalizer = parseBlock();
    }

    if (handlers.length === 0 &amp;&amp; !finalizer) {
        throwError({}, Messages.NoCatchOrFinally);
    }

    return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));
}

// 12.15 The debugger statement

function parseDebuggerStatement() {
    var marker = markerCreate();
    expectKeyword(&#39;debugger&#39;);

    consumeSemicolon();

    return markerApply(marker, delegate.createDebuggerStatement());
}

// 12 Statements

function parseStatement() {
    var type = lookahead.type,
        marker,
        expr,
        labeledBody,
        key;

    if (type === Token.EOF) {
        throwUnexpected(lookahead);
    }

    if (type === Token.Punctuator) {
        switch (lookahead.value) {
        case &#39;;&#39;:
            return parseEmptyStatement();
        case &#39;{&#39;:
            return parseBlock();
        case &#39;(&#39;:
            return parseExpressionStatement();
        default:
            break;
        }
    }

    if (type === Token.Keyword) {
        switch (lookahead.value) {
        case &#39;break&#39;:
            return parseBreakStatement();
        case &#39;continue&#39;:
            return parseContinueStatement();
        case &#39;debugger&#39;:
            return parseDebuggerStatement();
        case &#39;do&#39;:
            return parseDoWhileStatement();
        case &#39;for&#39;:
            return parseForStatement();
        case &#39;function&#39;:
            return parseFunctionDeclaration();
        case &#39;class&#39;:
            return parseClassDeclaration();
        case &#39;if&#39;:
            return parseIfStatement();
        case &#39;return&#39;:
            return parseReturnStatement();
        case &#39;switch&#39;:
            return parseSwitchStatement();
        case &#39;throw&#39;:
            return parseThrowStatement();
        case &#39;try&#39;:
            return parseTryStatement();
        case &#39;var&#39;:
            return parseVariableStatement();
        case &#39;while&#39;:
            return parseWhileStatement();
        case &#39;with&#39;:
            return parseWithStatement();
        default:
            break;
        }
    }

    if (matchAsyncFuncExprOrDecl()) {
        return parseFunctionDeclaration();
    }

    marker = markerCreate();
    expr = parseExpression();

    // 12.12 Labelled Statements
    if ((expr.type === Syntax.Identifier) &amp;&amp; match(&#39;:&#39;)) {
        lex();

        key = &#39;$&#39; + expr.name;
        if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.Redeclaration, &#39;Label&#39;, expr.name);
        }

        state.labelSet[key] = true;
        labeledBody = parseStatement();
        delete state.labelSet[key];
        return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));
    }

    consumeSemicolon();

    return markerApply(marker, delegate.createExpressionStatement(expr));
}

// 13 Function Definition

function parseConciseBody() {
    if (match(&#39;{&#39;)) {
        return parseFunctionSourceElements();
    }
    return parseAssignmentExpression();
}

function parseFunctionSourceElements() {
    var sourceElement, sourceElements = [], token, directive, firstRestricted,
        oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,
        marker = markerCreate();

    expect(&#39;{&#39;);

    while (index &lt; length) {
        if (lookahead.type !== Token.StringLiteral) {
            break;
        }
        token = lookahead;

        sourceElement = parseSourceElement();
        sourceElements.push(sourceElement);
        if (sourceElement.expression.type !== Syntax.Literal) {
            // this is not directive
            break;
        }
        directive = source.slice(token.range[0] + 1, token.range[1] - 1);
        if (directive === &#39;use strict&#39;) {
            strict = true;
            if (firstRestricted) {
                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
        } else {
            if (!firstRestricted &amp;&amp; token.octal) {
                firstRestricted = token;
            }
        }
    }

    oldLabelSet = state.labelSet;
    oldInIteration = state.inIteration;
    oldInSwitch = state.inSwitch;
    oldInFunctionBody = state.inFunctionBody;
    oldParenthesizedCount = state.parenthesizedCount;

    state.labelSet = {};
    state.inIteration = false;
    state.inSwitch = false;
    state.inFunctionBody = true;
    state.parenthesizedCount = 0;

    while (index &lt; length) {
        if (match(&#39;}&#39;)) {
            break;
        }
        sourceElement = parseSourceElement();
        if (typeof sourceElement === &#39;undefined&#39;) {
            break;
        }
        sourceElements.push(sourceElement);
    }

    expect(&#39;}&#39;);

    state.labelSet = oldLabelSet;
    state.inIteration = oldInIteration;
    state.inSwitch = oldInSwitch;
    state.inFunctionBody = oldInFunctionBody;
    state.parenthesizedCount = oldParenthesizedCount;

    return markerApply(marker, delegate.createBlockStatement(sourceElements));
}

function validateParam(options, param, name) {
    var key = &#39;$&#39; + name;
    if (strict) {
        if (isRestrictedWord(name)) {
            options.stricted = param;
            options.message = Messages.StrictParamName;
        }
        if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
            options.stricted = param;
            options.message = Messages.StrictParamDupe;
        }
    } else if (!options.firstRestricted) {
        if (isRestrictedWord(name)) {
            options.firstRestricted = param;
            options.message = Messages.StrictParamName;
        } else if (isStrictModeReservedWord(name)) {
            options.firstRestricted = param;
            options.message = Messages.StrictReservedWord;
        } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
            options.firstRestricted = param;
            options.message = Messages.StrictParamDupe;
        }
    }
    options.paramSet[key] = true;
}

function parseParam(options) {
    var marker, token, rest, param, def;

    token = lookahead;
    if (token.value === &#39;...&#39;) {
        token = lex();
        rest = true;
    }

    if (match(&#39;[&#39;)) {
        marker = markerCreate();
        param = parseArrayInitialiser();
        reinterpretAsDestructuredParameter(options, param);
        if (match(&#39;:&#39;)) {
            param.typeAnnotation = parseTypeAnnotation();
            markerApply(marker, param);
        }
    } else if (match(&#39;{&#39;)) {
        marker = markerCreate();
        if (rest) {
            throwError({}, Messages.ObjectPatternAsRestParameter);
        }
        param = parseObjectInitialiser();
        reinterpretAsDestructuredParameter(options, param);
        if (match(&#39;:&#39;)) {
            param.typeAnnotation = parseTypeAnnotation();
            markerApply(marker, param);
        }
    } else {
        param =
            rest
            ? parseTypeAnnotatableIdentifier(
                false, /* requireTypeAnnotation */
                false /* canBeOptionalParam */
            )
            : parseTypeAnnotatableIdentifier(
                false, /* requireTypeAnnotation */
                true /* canBeOptionalParam */
            );

        validateParam(options, token, token.value);
    }

    if (match(&#39;=&#39;)) {
        if (rest) {
            throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
        }
        lex();
        def = parseAssignmentExpression();
        ++options.defaultCount;
    }

    if (rest) {
        if (!match(&#39;)&#39;)) {
            throwError({}, Messages.ParameterAfterRestParameter);
        }
        options.rest = param;
        return false;
    }

    options.params.push(param);
    options.defaults.push(def);
    return !match(&#39;)&#39;);
}

function parseParams(firstRestricted) {
    var options, marker = markerCreate();

    options = {
        params: [],
        defaultCount: 0,
        defaults: [],
        rest: null,
        firstRestricted: firstRestricted
    };

    expect(&#39;(&#39;);

    if (!match(&#39;)&#39;)) {
        options.paramSet = {};
        while (index &lt; length) {
            if (!parseParam(options)) {
                break;
            }
            expect(&#39;,&#39;);
        }
    }

    expect(&#39;)&#39;);

    if (options.defaultCount === 0) {
        options.defaults = [];
    }

    if (match(&#39;:&#39;)) {
        options.returnType = parseTypeAnnotation();
    }

    return markerApply(marker, options);
}

function parseFunctionDeclaration() {
    var id, body, token, tmp, firstRestricted, message, generator, isAsync,
        previousStrict, previousYieldAllowed, previousAwaitAllowed,
        marker = markerCreate(), typeParameters;

    isAsync = false;
    if (matchAsync()) {
        lex();
        isAsync = true;
    }

    expectKeyword(&#39;function&#39;);

    generator = false;
    if (match(&#39;*&#39;)) {
        lex();
        generator = true;
    }

    token = lookahead;

    id = parseVariableIdentifier();

    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    if (strict) {
        if (isRestrictedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictFunctionName);
        }
    } else {
        if (isRestrictedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictFunctionName;
        } else if (isStrictModeReservedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictReservedWord;
        }
    }

    tmp = parseParams(firstRestricted);
    firstRestricted = tmp.firstRestricted;
    if (tmp.message) {
        message = tmp.message;
    }

    previousStrict = strict;
    previousYieldAllowed = state.yieldAllowed;
    state.yieldAllowed = generator;
    previousAwaitAllowed = state.awaitAllowed;
    state.awaitAllowed = isAsync;

    body = parseFunctionSourceElements();

    if (strict &amp;&amp; firstRestricted) {
        throwError(firstRestricted, message);
    }
    if (strict &amp;&amp; tmp.stricted) {
        throwErrorTolerant(tmp.stricted, message);
    }
    strict = previousStrict;
    state.yieldAllowed = previousYieldAllowed;
    state.awaitAllowed = previousAwaitAllowed;

    return markerApply(
        marker,
        delegate.createFunctionDeclaration(
            id,
            tmp.params,
            tmp.defaults,
            body,
            tmp.rest,
            generator,
            false,
            isAsync,
            tmp.returnType,
            typeParameters
        )
    );
}

function parseFunctionExpression() {
    var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,
        previousStrict, previousYieldAllowed, previousAwaitAllowed,
        marker = markerCreate(), typeParameters;

    isAsync = false;
    if (matchAsync()) {
        lex();
        isAsync = true;
    }

    expectKeyword(&#39;function&#39;);

    generator = false;

    if (match(&#39;*&#39;)) {
        lex();
        generator = true;
    }

    if (!match(&#39;(&#39;)) {
        if (!match(&#39;&lt;&#39;)) {
            token = lookahead;
            id = parseVariableIdentifier();

            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        if (match(&#39;&lt;&#39;)) {
            typeParameters = parseTypeParameterDeclaration();
        }
    }

    tmp = parseParams(firstRestricted);
    firstRestricted = tmp.firstRestricted;
    if (tmp.message) {
        message = tmp.message;
    }

    previousStrict = strict;
    previousYieldAllowed = state.yieldAllowed;
    state.yieldAllowed = generator;
    previousAwaitAllowed = state.awaitAllowed;
    state.awaitAllowed = isAsync;

    body = parseFunctionSourceElements();

    if (strict &amp;&amp; firstRestricted) {
        throwError(firstRestricted, message);
    }
    if (strict &amp;&amp; tmp.stricted) {
        throwErrorTolerant(tmp.stricted, message);
    }
    strict = previousStrict;
    state.yieldAllowed = previousYieldAllowed;
    state.awaitAllowed = previousAwaitAllowed;

    return markerApply(
        marker,
        delegate.createFunctionExpression(
            id,
            tmp.params,
            tmp.defaults,
            body,
            tmp.rest,
            generator,
            false,
            isAsync,
            tmp.returnType,
            typeParameters
        )
    );
}

function parseYieldExpression() {
    var delegateFlag, expr, marker = markerCreate();

    expectKeyword(&#39;yield&#39;, !strict);

    delegateFlag = false;
    if (match(&#39;*&#39;)) {
        lex();
        delegateFlag = true;
    }

    expr = parseAssignmentExpression();

    return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));
}

function parseAwaitExpression() {
    var expr, marker = markerCreate();
    expectContextualKeyword(&#39;await&#39;);
    expr = parseAssignmentExpression();
    return markerApply(marker, delegate.createAwaitExpression(expr));
}

// 14 Classes

function parseMethodDefinition(existingPropNames, key, isStatic, generator, computed) {
    var token, param, propType, isValidDuplicateProp = false,
        isAsync, typeParameters, tokenValue, returnType,
        annotationMarker;

    propType = isStatic ? ClassPropertyType[&quot;static&quot;] : ClassPropertyType.prototype;

    if (generator) {
        return delegate.createMethodDefinition(
            propType,
            &#39;&#39;,
            key,
            parsePropertyMethodFunction({ generator: true })
        );
    }

    tokenValue = key.type === &#39;Identifier&#39; &amp;&amp; key.name;

    if (tokenValue === &#39;get&#39; &amp;&amp; !match(&#39;(&#39;)) {
        key = parseObjectPropertyKey();

        // It is a syntax error if any other properties have a name
        // duplicating this one unless they are a setter
        if (existingPropNames[propType].hasOwnProperty(key.name)) {
            isValidDuplicateProp =
                // There isn&#39;t already a getter for this prop
                existingPropNames[propType][key.name].get === undefined
                // There isn&#39;t already a data prop by this name
                &amp;&amp; existingPropNames[propType][key.name].data === undefined
                // The only existing prop by this name is a setter
                &amp;&amp; existingPropNames[propType][key.name].set !== undefined;
            if (!isValidDuplicateProp) {
                throwError(key, Messages.IllegalDuplicateClassProperty);
            }
        } else {
            existingPropNames[propType][key.name] = {};
        }
        existingPropNames[propType][key.name].get = true;

        expect(&#39;(&#39;);
        expect(&#39;)&#39;);
        if (match(&#39;:&#39;)) {
            returnType = parseTypeAnnotation();
        }
        return delegate.createMethodDefinition(
            propType,
            &#39;get&#39;,
            key,
            parsePropertyFunction({ generator: false, returnType: returnType })
        );
    }
    if (tokenValue === &#39;set&#39; &amp;&amp; !match(&#39;(&#39;)) {
        key = parseObjectPropertyKey();

        // It is a syntax error if any other properties have a name
        // duplicating this one unless they are a getter
        if (existingPropNames[propType].hasOwnProperty(key.name)) {
            isValidDuplicateProp =
                // There isn&#39;t already a setter for this prop
                existingPropNames[propType][key.name].set === undefined
                // There isn&#39;t already a data prop by this name
                &amp;&amp; existingPropNames[propType][key.name].data === undefined
                // The only existing prop by this name is a getter
                &amp;&amp; existingPropNames[propType][key.name].get !== undefined;
            if (!isValidDuplicateProp) {
                throwError(key, Messages.IllegalDuplicateClassProperty);
            }
        } else {
            existingPropNames[propType][key.name] = {};
        }
        existingPropNames[propType][key.name].set = true;

        expect(&#39;(&#39;);
        token = lookahead;
        param = [ parseTypeAnnotatableIdentifier() ];
        expect(&#39;)&#39;);
        if (match(&#39;:&#39;)) {
            returnType = parseTypeAnnotation();
        }
        return delegate.createMethodDefinition(
            propType,
            &#39;set&#39;,
            key,
            parsePropertyFunction({
                params: param,
                generator: false,
                name: token,
                returnType: returnType
            })
        );
    }

    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    isAsync = tokenValue === &#39;async&#39; &amp;&amp; !match(&#39;(&#39;);
    if (isAsync) {
        key = parseObjectPropertyKey();
    }

    // It is a syntax error if any other properties have the same name as a
    // non-getter, non-setter method
    if (existingPropNames[propType].hasOwnProperty(key.name)) {
        throwError(key, Messages.IllegalDuplicateClassProperty);
    } else {
        existingPropNames[propType][key.name] = {};
    }
    existingPropNames[propType][key.name].data = true;

    return delegate.createMethodDefinition(
        propType,
        &#39;&#39;,
        key,
        parsePropertyMethodFunction({
            generator: false,
            async: isAsync,
            typeParameters: typeParameters
        })
    );
}

function parseClassProperty(existingPropNames, key, computed, isStatic) {
    var typeAnnotation;

    typeAnnotation = parseTypeAnnotation();
    expect(&#39;;&#39;);

    return delegate.createClassProperty(
        key,
        typeAnnotation,
        computed,
        isStatic
    );
}

function parseClassElement(existingProps) {
    var computed, generator = false, key, marker = markerCreate(),
        isStatic = false;
    if (match(&#39;;&#39;)) {
        lex();
        return;
    }

    if (lookahead.value === &#39;static&#39;) {
        lex();
        isStatic = true;
    }

    if (match(&#39;*&#39;)) {
        lex();
        generator = true;
    }

    computed = (lookahead.value === &#39;[&#39;);
    key = parseObjectPropertyKey();

    if (!generator &amp;&amp; lookahead.value === &#39;:&#39;) {
        return markerApply(marker, parseClassProperty(existingProps, key, computed, isStatic));
    }

    return markerApply(marker, parseMethodDefinition(
        existingProps,
        key,
        isStatic,
        generator,
        computed
    ));
}

function parseClassBody() {
    var classElement, classElements = [], existingProps = {}, marker = markerCreate();

    existingProps[ClassPropertyType[&quot;static&quot;]] = {};
    existingProps[ClassPropertyType.prototype] = {};

    expect(&#39;{&#39;);

    while (index &lt; length) {
        if (match(&#39;}&#39;)) {
            break;
        }
        classElement = parseClassElement(existingProps);

        if (typeof classElement !== &#39;undefined&#39;) {
            classElements.push(classElement);
        }
    }

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createClassBody(classElements));
}

function parseClassImplements() {
    var id, implemented = [], marker, typeParameters;
    expectContextualKeyword(&#39;implements&#39;);
    while (index &lt; length) {
        marker = markerCreate();
        id = parseVariableIdentifier();
        if (match(&#39;&lt;&#39;)) {
            typeParameters = parseTypeParameterInstantiation();
        } else {
            typeParameters = null;
        }
        implemented.push(markerApply(marker, delegate.createClassImplements(
            id,
            typeParameters
        )));
        if (!match(&#39;,&#39;)) {
            break;
        }
        expect(&#39;,&#39;);
    }
    return implemented;
}

function parseClassExpression() {
    var id, implemented, previousYieldAllowed, superClass = null,
        superTypeParameters, marker = markerCreate(), typeParameters;

    expectKeyword(&#39;class&#39;);

    if (!matchKeyword(&#39;extends&#39;) &amp;&amp; !matchContextualKeyword(&#39;implements&#39;) &amp;&amp; !match(&#39;{&#39;)) {
        id = parseVariableIdentifier();
    }

    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    if (matchKeyword(&#39;extends&#39;)) {
        expectKeyword(&#39;extends&#39;);
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = false;
        superClass = parseLeftHandSideExpressionAllowCall();
        if (match(&#39;&lt;&#39;)) {
            superTypeParameters = parseTypeParameterInstantiation();
        }
        state.yieldAllowed = previousYieldAllowed;
    }

    if (matchContextualKeyword(&#39;implements&#39;)) {
        implemented = parseClassImplements();
    }

    return markerApply(marker, delegate.createClassExpression(
        id,
        superClass,
        parseClassBody(),
        typeParameters,
        superTypeParameters,
        implemented
    ));
}

function parseClassDeclaration() {
    var id, implemented, previousYieldAllowed, superClass = null,
        superTypeParameters, marker = markerCreate(), typeParameters;

    expectKeyword(&#39;class&#39;);

    id = parseVariableIdentifier();

    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    if (matchKeyword(&#39;extends&#39;)) {
        expectKeyword(&#39;extends&#39;);
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = false;
        superClass = parseLeftHandSideExpressionAllowCall();
        if (match(&#39;&lt;&#39;)) {
            superTypeParameters = parseTypeParameterInstantiation();
        }
        state.yieldAllowed = previousYieldAllowed;
    }

    if (matchContextualKeyword(&#39;implements&#39;)) {
        implemented = parseClassImplements();
    }

    return markerApply(marker, delegate.createClassDeclaration(
        id,
        superClass,
        parseClassBody(),
        typeParameters,
        superTypeParameters,
        implemented
    ));
}

// 15 Program

function parseSourceElement() {
    var token;
    if (lookahead.type === Token.Keyword) {
        switch (lookahead.value) {
        case &#39;const&#39;:
        case &#39;let&#39;:
            return parseConstLetDeclaration(lookahead.value);
        case &#39;function&#39;:
            return parseFunctionDeclaration();
        default:
            return parseStatement();
        }
    }

    if (matchContextualKeyword(&#39;type&#39;)
            &amp;&amp; lookahead2().type === Token.Identifier) {
        return parseTypeAlias();
    }

    if (matchContextualKeyword(&#39;interface&#39;)
            &amp;&amp; lookahead2().type === Token.Identifier) {
        return parseInterface();
    }

    if (matchContextualKeyword(&#39;declare&#39;)) {
        token = lookahead2();
        if (token.type === Token.Keyword) {
            switch (token.value) {
            case &#39;class&#39;:
                return parseDeclareClass();
            case &#39;function&#39;:
                return parseDeclareFunction();
            case &#39;var&#39;:
                return parseDeclareVariable();
            }
        } else if (token.type === Token.Identifier
                &amp;&amp; token.value === &#39;module&#39;) {
            return parseDeclareModule();
        }
    }

    if (lookahead.type !== Token.EOF) {
        return parseStatement();
    }
}

function parseProgramElement() {
    if (lookahead.type === Token.Keyword) {
        switch (lookahead.value) {
        case &#39;export&#39;:
            return parseExportDeclaration();
        case &#39;import&#39;:
            return parseImportDeclaration();
        }
    }

    return parseSourceElement();
}

function parseProgramElements() {
    var sourceElement, sourceElements = [], token, directive, firstRestricted;

    while (index &lt; length) {
        token = lookahead;
        if (token.type !== Token.StringLiteral) {
            break;
        }

        sourceElement = parseProgramElement();
        sourceElements.push(sourceElement);
        if (sourceElement.expression.type !== Syntax.Literal) {
            // this is not directive
            break;
        }
        directive = source.slice(token.range[0] + 1, token.range[1] - 1);
        if (directive === &#39;use strict&#39;) {
            strict = true;
            if (firstRestricted) {
                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
        } else {
            if (!firstRestricted &amp;&amp; token.octal) {
                firstRestricted = token;
            }
        }
    }

    while (index &lt; length) {
        sourceElement = parseProgramElement();
        if (typeof sourceElement === &#39;undefined&#39;) {
            break;
        }
        sourceElements.push(sourceElement);
    }
    return sourceElements;
}

function parseProgram() {
    var body, marker = markerCreate();
    strict = false;
    peek();
    body = parseProgramElements();
    return markerApply(marker, delegate.createProgram(body));
}

// The following functions are needed only when the option to preserve
// the comments is active.

function addComment(type, value, start, end, loc) {
    var comment;

    assert(typeof start === &#39;number&#39;, &#39;Comment must have valid position&#39;);

    // Because the way the actual token is scanned, often the comments
    // (if any) are skipped twice during the lexical analysis.
    // Thus, we need to skip adding a comment if the comment array already
    // handled it.
    if (state.lastCommentStart &gt;= start) {
        return;
    }
    state.lastCommentStart = start;

    comment = {
        type: type,
        value: value
    };
    if (extra.range) {
        comment.range = [start, end];
    }
    if (extra.loc) {
        comment.loc = loc;
    }
    extra.comments.push(comment);
    if (extra.attachComment) {
        extra.leadingComments.push(comment);
        extra.trailingComments.push(comment);
    }
}

function scanComment() {
    var comment, ch, loc, start, blockComment, lineComment;

    comment = &#39;&#39;;
    blockComment = false;
    lineComment = false;

    while (index &lt; length) {
        ch = source[index];

        if (lineComment) {
            ch = source[index++];
            if (isLineTerminator(ch.charCodeAt(0))) {
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart - 1
                };
                lineComment = false;
                addComment(&#39;Line&#39;, comment, start, index - 1, loc);
                if (ch === &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                comment = &#39;&#39;;
            } else if (index &gt;= length) {
                lineComment = false;
                comment += ch;
                loc.end = {
                    line: lineNumber,
                    column: length - lineStart
                };
                addComment(&#39;Line&#39;, comment, start, length, loc);
            } else {
                comment += ch;
            }
        } else if (blockComment) {
            if (isLineTerminator(ch.charCodeAt(0))) {
                if (ch === &#39;\r&#39;) {
                    ++index;
                    comment += &#39;\r&#39;;
                }
                if (ch !== &#39;\r&#39; || source[index] === &#39;\n&#39;) {
                    comment += source[index];
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index &gt;= length) {
                        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                    }
                }
            } else {
                ch = source[index++];
                if (index &gt;= length) {
                    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                }
                comment += ch;
                if (ch === &#39;*&#39;) {
                    ch = source[index];
                    if (ch === &#39;/&#39;) {
                        comment = comment.substr(0, comment.length - 1);
                        blockComment = false;
                        ++index;
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment(&#39;Block&#39;, comment, start, index, loc);
                        comment = &#39;&#39;;
                    }
                }
            }
        } else if (ch === &#39;/&#39;) {
            ch = source[index + 1];
            if (ch === &#39;/&#39;) {
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                start = index;
                index += 2;
                lineComment = true;
                if (index &gt;= length) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart
                    };
                    lineComment = false;
                    addComment(&#39;Line&#39;, comment, start, index, loc);
                }
            } else if (ch === &#39;*&#39;) {
                start = index;
                index += 2;
                blockComment = true;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart - 2
                    }
                };
                if (index &gt;= length) {
                    throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
                }
            } else {
                break;
            }
        } else if (isWhiteSpace(ch.charCodeAt(0))) {
            ++index;
        } else if (isLineTerminator(ch.charCodeAt(0))) {
            ++index;
            if (ch ===  &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                ++index;
            }
            ++lineNumber;
            lineStart = index;
        } else {
            break;
        }
    }
}

// 16 XJS

XHTMLEntities = {
    quot: &#39;\u0022&#39;,
    amp: &#39;&amp;&#39;,
    apos: &#39;\u0027&#39;,
    lt: &#39;&lt;&#39;,
    gt: &#39;&gt;&#39;,
    nbsp: &#39;\u00A0&#39;,
    iexcl: &#39;\u00A1&#39;,
    cent: &#39;\u00A2&#39;,
    pound: &#39;\u00A3&#39;,
    curren: &#39;\u00A4&#39;,
    yen: &#39;\u00A5&#39;,
    brvbar: &#39;\u00A6&#39;,
    sect: &#39;\u00A7&#39;,
    uml: &#39;\u00A8&#39;,
    copy: &#39;\u00A9&#39;,
    ordf: &#39;\u00AA&#39;,
    laquo: &#39;\u00AB&#39;,
    not: &#39;\u00AC&#39;,
    shy: &#39;\u00AD&#39;,
    reg: &#39;\u00AE&#39;,
    macr: &#39;\u00AF&#39;,
    deg: &#39;\u00B0&#39;,
    plusmn: &#39;\u00B1&#39;,
    sup2: &#39;\u00B2&#39;,
    sup3: &#39;\u00B3&#39;,
    acute: &#39;\u00B4&#39;,
    micro: &#39;\u00B5&#39;,
    para: &#39;\u00B6&#39;,
    middot: &#39;\u00B7&#39;,
    cedil: &#39;\u00B8&#39;,
    sup1: &#39;\u00B9&#39;,
    ordm: &#39;\u00BA&#39;,
    raquo: &#39;\u00BB&#39;,
    frac14: &#39;\u00BC&#39;,
    frac12: &#39;\u00BD&#39;,
    frac34: &#39;\u00BE&#39;,
    iquest: &#39;\u00BF&#39;,
    Agrave: &#39;\u00C0&#39;,
    Aacute: &#39;\u00C1&#39;,
    Acirc: &#39;\u00C2&#39;,
    Atilde: &#39;\u00C3&#39;,
    Auml: &#39;\u00C4&#39;,
    Aring: &#39;\u00C5&#39;,
    AElig: &#39;\u00C6&#39;,
    Ccedil: &#39;\u00C7&#39;,
    Egrave: &#39;\u00C8&#39;,
    Eacute: &#39;\u00C9&#39;,
    Ecirc: &#39;\u00CA&#39;,
    Euml: &#39;\u00CB&#39;,
    Igrave: &#39;\u00CC&#39;,
    Iacute: &#39;\u00CD&#39;,
    Icirc: &#39;\u00CE&#39;,
    Iuml: &#39;\u00CF&#39;,
    ETH: &#39;\u00D0&#39;,
    Ntilde: &#39;\u00D1&#39;,
    Ograve: &#39;\u00D2&#39;,
    Oacute: &#39;\u00D3&#39;,
    Ocirc: &#39;\u00D4&#39;,
    Otilde: &#39;\u00D5&#39;,
    Ouml: &#39;\u00D6&#39;,
    times: &#39;\u00D7&#39;,
    Oslash: &#39;\u00D8&#39;,
    Ugrave: &#39;\u00D9&#39;,
    Uacute: &#39;\u00DA&#39;,
    Ucirc: &#39;\u00DB&#39;,
    Uuml: &#39;\u00DC&#39;,
    Yacute: &#39;\u00DD&#39;,
    THORN: &#39;\u00DE&#39;,
    szlig: &#39;\u00DF&#39;,
    agrave: &#39;\u00E0&#39;,
    aacute: &#39;\u00E1&#39;,
    acirc: &#39;\u00E2&#39;,
    atilde: &#39;\u00E3&#39;,
    auml: &#39;\u00E4&#39;,
    aring: &#39;\u00E5&#39;,
    aelig: &#39;\u00E6&#39;,
    ccedil: &#39;\u00E7&#39;,
    egrave: &#39;\u00E8&#39;,
    eacute: &#39;\u00E9&#39;,
    ecirc: &#39;\u00EA&#39;,
    euml: &#39;\u00EB&#39;,
    igrave: &#39;\u00EC&#39;,
    iacute: &#39;\u00ED&#39;,
    icirc: &#39;\u00EE&#39;,
    iuml: &#39;\u00EF&#39;,
    eth: &#39;\u00F0&#39;,
    ntilde: &#39;\u00F1&#39;,
    ograve: &#39;\u00F2&#39;,
    oacute: &#39;\u00F3&#39;,
    ocirc: &#39;\u00F4&#39;,
    otilde: &#39;\u00F5&#39;,
    ouml: &#39;\u00F6&#39;,
    divide: &#39;\u00F7&#39;,
    oslash: &#39;\u00F8&#39;,
    ugrave: &#39;\u00F9&#39;,
    uacute: &#39;\u00FA&#39;,
    ucirc: &#39;\u00FB&#39;,
    uuml: &#39;\u00FC&#39;,
    yacute: &#39;\u00FD&#39;,
    thorn: &#39;\u00FE&#39;,
    yuml: &#39;\u00FF&#39;,
    OElig: &#39;\u0152&#39;,
    oelig: &#39;\u0153&#39;,
    Scaron: &#39;\u0160&#39;,
    scaron: &#39;\u0161&#39;,
    Yuml: &#39;\u0178&#39;,
    fnof: &#39;\u0192&#39;,
    circ: &#39;\u02C6&#39;,
    tilde: &#39;\u02DC&#39;,
    Alpha: &#39;\u0391&#39;,
    Beta: &#39;\u0392&#39;,
    Gamma: &#39;\u0393&#39;,
    Delta: &#39;\u0394&#39;,
    Epsilon: &#39;\u0395&#39;,
    Zeta: &#39;\u0396&#39;,
    Eta: &#39;\u0397&#39;,
    Theta: &#39;\u0398&#39;,
    Iota: &#39;\u0399&#39;,
    Kappa: &#39;\u039A&#39;,
    Lambda: &#39;\u039B&#39;,
    Mu: &#39;\u039C&#39;,
    Nu: &#39;\u039D&#39;,
    Xi: &#39;\u039E&#39;,
    Omicron: &#39;\u039F&#39;,
    Pi: &#39;\u03A0&#39;,
    Rho: &#39;\u03A1&#39;,
    Sigma: &#39;\u03A3&#39;,
    Tau: &#39;\u03A4&#39;,
    Upsilon: &#39;\u03A5&#39;,
    Phi: &#39;\u03A6&#39;,
    Chi: &#39;\u03A7&#39;,
    Psi: &#39;\u03A8&#39;,
    Omega: &#39;\u03A9&#39;,
    alpha: &#39;\u03B1&#39;,
    beta: &#39;\u03B2&#39;,
    gamma: &#39;\u03B3&#39;,
    delta: &#39;\u03B4&#39;,
    epsilon: &#39;\u03B5&#39;,
    zeta: &#39;\u03B6&#39;,
    eta: &#39;\u03B7&#39;,
    theta: &#39;\u03B8&#39;,
    iota: &#39;\u03B9&#39;,
    kappa: &#39;\u03BA&#39;,
    lambda: &#39;\u03BB&#39;,
    mu: &#39;\u03BC&#39;,
    nu: &#39;\u03BD&#39;,
    xi: &#39;\u03BE&#39;,
    omicron: &#39;\u03BF&#39;,
    pi: &#39;\u03C0&#39;,
    rho: &#39;\u03C1&#39;,
    sigmaf: &#39;\u03C2&#39;,
    sigma: &#39;\u03C3&#39;,
    tau: &#39;\u03C4&#39;,
    upsilon: &#39;\u03C5&#39;,
    phi: &#39;\u03C6&#39;,
    chi: &#39;\u03C7&#39;,
    psi: &#39;\u03C8&#39;,
    omega: &#39;\u03C9&#39;,
    thetasym: &#39;\u03D1&#39;,
    upsih: &#39;\u03D2&#39;,
    piv: &#39;\u03D6&#39;,
    ensp: &#39;\u2002&#39;,
    emsp: &#39;\u2003&#39;,
    thinsp: &#39;\u2009&#39;,
    zwnj: &#39;\u200C&#39;,
    zwj: &#39;\u200D&#39;,
    lrm: &#39;\u200E&#39;,
    rlm: &#39;\u200F&#39;,
    ndash: &#39;\u2013&#39;,
    mdash: &#39;\u2014&#39;,
    lsquo: &#39;\u2018&#39;,
    rsquo: &#39;\u2019&#39;,
    sbquo: &#39;\u201A&#39;,
    ldquo: &#39;\u201C&#39;,
    rdquo: &#39;\u201D&#39;,
    bdquo: &#39;\u201E&#39;,
    dagger: &#39;\u2020&#39;,
    Dagger: &#39;\u2021&#39;,
    bull: &#39;\u2022&#39;,
    hellip: &#39;\u2026&#39;,
    permil: &#39;\u2030&#39;,
    prime: &#39;\u2032&#39;,
    Prime: &#39;\u2033&#39;,
    lsaquo: &#39;\u2039&#39;,
    rsaquo: &#39;\u203A&#39;,
    oline: &#39;\u203E&#39;,
    frasl: &#39;\u2044&#39;,
    euro: &#39;\u20AC&#39;,
    image: &#39;\u2111&#39;,
    weierp: &#39;\u2118&#39;,
    real: &#39;\u211C&#39;,
    trade: &#39;\u2122&#39;,
    alefsym: &#39;\u2135&#39;,
    larr: &#39;\u2190&#39;,
    uarr: &#39;\u2191&#39;,
    rarr: &#39;\u2192&#39;,
    darr: &#39;\u2193&#39;,
    harr: &#39;\u2194&#39;,
    crarr: &#39;\u21B5&#39;,
    lArr: &#39;\u21D0&#39;,
    uArr: &#39;\u21D1&#39;,
    rArr: &#39;\u21D2&#39;,
    dArr: &#39;\u21D3&#39;,
    hArr: &#39;\u21D4&#39;,
    forall: &#39;\u2200&#39;,
    part: &#39;\u2202&#39;,
    exist: &#39;\u2203&#39;,
    empty: &#39;\u2205&#39;,
    nabla: &#39;\u2207&#39;,
    isin: &#39;\u2208&#39;,
    notin: &#39;\u2209&#39;,
    ni: &#39;\u220B&#39;,
    prod: &#39;\u220F&#39;,
    sum: &#39;\u2211&#39;,
    minus: &#39;\u2212&#39;,
    lowast: &#39;\u2217&#39;,
    radic: &#39;\u221A&#39;,
    prop: &#39;\u221D&#39;,
    infin: &#39;\u221E&#39;,
    ang: &#39;\u2220&#39;,
    and: &#39;\u2227&#39;,
    or: &#39;\u2228&#39;,
    cap: &#39;\u2229&#39;,
    cup: &#39;\u222A&#39;,
    &#39;int&#39;: &#39;\u222B&#39;,
    there4: &#39;\u2234&#39;,
    sim: &#39;\u223C&#39;,
    cong: &#39;\u2245&#39;,
    asymp: &#39;\u2248&#39;,
    ne: &#39;\u2260&#39;,
    equiv: &#39;\u2261&#39;,
    le: &#39;\u2264&#39;,
    ge: &#39;\u2265&#39;,
    sub: &#39;\u2282&#39;,
    sup: &#39;\u2283&#39;,
    nsub: &#39;\u2284&#39;,
    sube: &#39;\u2286&#39;,
    supe: &#39;\u2287&#39;,
    oplus: &#39;\u2295&#39;,
    otimes: &#39;\u2297&#39;,
    perp: &#39;\u22A5&#39;,
    sdot: &#39;\u22C5&#39;,
    lceil: &#39;\u2308&#39;,
    rceil: &#39;\u2309&#39;,
    lfloor: &#39;\u230A&#39;,
    rfloor: &#39;\u230B&#39;,
    lang: &#39;\u2329&#39;,
    rang: &#39;\u232A&#39;,
    loz: &#39;\u25CA&#39;,
    spades: &#39;\u2660&#39;,
    clubs: &#39;\u2663&#39;,
    hearts: &#39;\u2665&#39;,
    diams: &#39;\u2666&#39;
};

function getQualifiedXJSName(object) {
    if (object.type === Syntax.XJSIdentifier) {
        return object.name;
    }
    if (object.type === Syntax.XJSNamespacedName) {
        return object.namespace.name + &#39;:&#39; + object.name.name;
    }
    if (object.type === Syntax.XJSMemberExpression) {
        return (
            getQualifiedXJSName(object.object) + &#39;.&#39; +
            getQualifiedXJSName(object.property)
        );
    }
}

function isXJSIdentifierStart(ch) {
    // exclude backslash (\)
    return (ch !== 92) &amp;&amp; isIdentifierStart(ch);
}

function isXJSIdentifierPart(ch) {
    // exclude backslash (\) and add hyphen (-)
    return (ch !== 92) &amp;&amp; (ch === 45 || isIdentifierPart(ch));
}

function scanXJSIdentifier() {
    var ch, start, value = &#39;&#39;;

    start = index;
    while (index &lt; length) {
        ch = source.charCodeAt(index);
        if (!isXJSIdentifierPart(ch)) {
            break;
        }
        value += source[index++];
    }

    return {
        type: Token.XJSIdentifier,
        value: value,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanXJSEntity() {
    var ch, str = &#39;&#39;, start = index, count = 0, code;
    ch = source[index];
    assert(ch === &#39;&amp;&#39;, &#39;Entity must start with an ampersand&#39;);
    index++;
    while (index &lt; length &amp;&amp; count++ &lt; 10) {
        ch = source[index++];
        if (ch === &#39;;&#39;) {
            break;
        }
        str += ch;
    }

    // Well-formed entity (ending was found).
    if (ch === &#39;;&#39;) {
        // Numeric entity.
        if (str[0] === &#39;#&#39;) {
            if (str[1] === &#39;x&#39;) {
                code = +(&#39;0&#39; + str.substr(1));
            } else {
                // Removing leading zeros in order to avoid treating as octal in old browsers.
                code = +str.substr(1).replace(Regex.LeadingZeros, &#39;&#39;);
            }

            if (!isNaN(code)) {
                return String.fromCharCode(code);
            }
        } else if (XHTMLEntities[str]) {
            return XHTMLEntities[str];
        }
    }

    // Treat non-entity sequences as regular text.
    index = start + 1;
    return &#39;&amp;&#39;;
}

function scanXJSText(stopChars) {
    var ch, str = &#39;&#39;, start;
    start = index;
    while (index &lt; length) {
        ch = source[index];
        if (stopChars.indexOf(ch) !== -1) {
            break;
        }
        if (ch === &#39;&amp;&#39;) {
            str += scanXJSEntity();
        } else {
            index++;
            if (ch === &#39;\r&#39; &amp;&amp; source[index] === &#39;\n&#39;) {
                str += ch;
                ch = source[index];
                index++;
            }
            if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                lineStart = index;
            }
            str += ch;
        }
    }
    return {
        type: Token.XJSText,
        value: str,
        lineNumber: lineNumber,
        lineStart: lineStart,
        range: [start, index]
    };
}

function scanXJSStringLiteral() {
    var innerToken, quote, start;

    quote = source[index];
    assert((quote === &#39;\&#39;&#39; || quote === &#39;&quot;&#39;),
        &#39;String literal must starts with a quote&#39;);

    start = index;
    ++index;

    innerToken = scanXJSText([quote]);

    if (quote !== source[index]) {
        throwError({}, Messages.UnexpectedToken, &#39;ILLEGAL&#39;);
    }

    ++index;

    innerToken.range = [start, index];

    return innerToken;
}

/**
   Between XJS opening and closing tags (e.g. &lt;foo&gt;HERE&lt;/foo&gt;), anything that
   is not another XJS tag and is not an expression wrapped by {} is text.
  /
function advanceXJSChild() {
    var ch = source.charCodeAt(index);

    // { (123) and &lt; (60)
    if (ch !== 123 &amp;&amp; ch !== 60) {
        return scanXJSText([&#39;&lt;&#39;, &#39;{&#39;]);
    }

    return scanPunctuator();
}

function parseXJSIdentifier() {
    var token, marker = markerCreate();

    if (lookahead.type !== Token.XJSIdentifier) {
        throwUnexpected(lookahead);
    }

    token = lex();
    return markerApply(marker, delegate.createXJSIdentifier(token.value));
}

function parseXJSNamespacedName() {
    var namespace, name, marker = markerCreate();

    namespace = parseXJSIdentifier();
    expect(&#39;:&#39;);
    name = parseXJSIdentifier();

    return markerApply(marker, delegate.createXJSNamespacedName(namespace, name));
}

function parseXJSMemberExpression() {
    var marker = markerCreate(),
        expr = parseXJSIdentifier();

    while (match(&#39;.&#39;)) {
        lex();
        expr = markerApply(marker, delegate.createXJSMemberExpression(expr, parseXJSIdentifier()));
    }

    return expr;
}

function parseXJSElementName() {
    if (lookahead2().value === &#39;:&#39;) {
        return parseXJSNamespacedName();
    }
    if (lookahead2().value === &#39;.&#39;) {
        return parseXJSMemberExpression();
    }

    return parseXJSIdentifier();
}

function parseXJSAttributeName() {
    if (lookahead2().value === &#39;:&#39;) {
        return parseXJSNamespacedName();
    }

    return parseXJSIdentifier();
}

function parseXJSAttributeValue() {
    var value, marker;
    if (match(&#39;{&#39;)) {
        value = parseXJSExpressionContainer();
        if (value.expression.type === Syntax.XJSEmptyExpression) {
            throwError(
                value,
                &#39;XJS attributes must only be assigned a non-empty &#39; +
                    &#39;expression&#39;
            );
        }
    } else if (match(&#39;&lt;&#39;)) {
        value = parseXJSElement();
    } else if (lookahead.type === Token.XJSText) {
        marker = markerCreate();
        value = markerApply(marker, delegate.createLiteral(lex()));
    } else {
        throwError({}, Messages.InvalidXJSAttributeValue);
    }
    return value;
}

function parseXJSEmptyExpression() {
    var marker = markerCreatePreserveWhitespace();
    while (source.charAt(index) !== &#39;}&#39;) {
        index++;
    }
    return markerApply(marker, delegate.createXJSEmptyExpression());
}

function parseXJSExpressionContainer() {
    var expression, origInXJSChild, origInXJSTag, marker = markerCreate();

    origInXJSChild = state.inXJSChild;
    origInXJSTag = state.inXJSTag;
    state.inXJSChild = false;
    state.inXJSTag = false;

    expect(&#39;{&#39;);

    if (match(&#39;}&#39;)) {
        expression = parseXJSEmptyExpression();
    } else {
        expression = parseExpression();
    }

    state.inXJSChild = origInXJSChild;
    state.inXJSTag = origInXJSTag;

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createXJSExpressionContainer(expression));
}

function parseXJSSpreadAttribute() {
    var expression, origInXJSChild, origInXJSTag, marker = markerCreate();

    origInXJSChild = state.inXJSChild;
    origInXJSTag = state.inXJSTag;
    state.inXJSChild = false;
    state.inXJSTag = false;

    expect(&#39;{&#39;);
    expect(&#39;...&#39;);

    expression = parseAssignmentExpression();

    state.inXJSChild = origInXJSChild;
    state.inXJSTag = origInXJSTag;

    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createXJSSpreadAttribute(expression));
}

function parseXJSAttribute() {
    var name, marker;

    if (match(&#39;{&#39;)) {
        return parseXJSSpreadAttribute();
    }

    marker = markerCreate();

    name = parseXJSAttributeName();

    // HTML empty attribute
    if (match(&#39;=&#39;)) {
        lex();
        return markerApply(marker, delegate.createXJSAttribute(name, parseXJSAttributeValue()));
    }

    return markerApply(marker, delegate.createXJSAttribute(name));
}

function parseXJSChild() {
    var token, marker;
    if (match(&#39;{&#39;)) {
        token = parseXJSExpressionContainer();
    } else if (lookahead.type === Token.XJSText) {
        marker = markerCreatePreserveWhitespace();
        token = markerApply(marker, delegate.createLiteral(lex()));
    } else {
        token = parseXJSElement();
    }
    return token;
}

function parseXJSClosingElement() {
    var name, origInXJSChild, origInXJSTag, marker = markerCreate();
    origInXJSChild = state.inXJSChild;
    origInXJSTag = state.inXJSTag;
    state.inXJSChild = false;
    state.inXJSTag = true;
    expect(&#39;&lt;&#39;);
    expect(&#39;/&#39;);
    name = parseXJSElementName();
    // Because advance() (called by lex() called by expect()) expects there
    // to be a valid token after &gt;, it needs to know whether to look for a
    // standard JS token or an XJS text node
    state.inXJSChild = origInXJSChild;
    state.inXJSTag = origInXJSTag;
    expect(&#39;&gt;&#39;);
    return markerApply(marker, delegate.createXJSClosingElement(name));
}

function parseXJSOpeningElement() {
    var name, attribute, attributes = [], selfClosing = false, origInXJSChild, origInXJSTag, marker = markerCreate();

    origInXJSChild = state.inXJSChild;
    origInXJSTag = state.inXJSTag;
    state.inXJSChild = false;
    state.inXJSTag = true;

    expect(&#39;&lt;&#39;);

    name = parseXJSElementName();

    while (index &lt; length &amp;&amp;
            lookahead.value !== &#39;/&#39; &amp;&amp;
            lookahead.value !== &#39;&gt;&#39;) {
        attributes.push(parseXJSAttribute());
    }

    state.inXJSTag = origInXJSTag;

    if (lookahead.value === &#39;/&#39;) {
        expect(&#39;/&#39;);
        // Because advance() (called by lex() called by expect()) expects
        // there to be a valid token after &gt;, it needs to know whether to
        // look for a standard JS token or an XJS text node
        state.inXJSChild = origInXJSChild;
        expect(&#39;&gt;&#39;);
        selfClosing = true;
    } else {
        state.inXJSChild = true;
        expect(&#39;&gt;&#39;);
    }
    return markerApply(marker, delegate.createXJSOpeningElement(name, attributes, selfClosing));
}

function parseXJSElement() {
    var openingElement, closingElement = null, children = [], origInXJSChild, origInXJSTag, marker = markerCreate();

    origInXJSChild = state.inXJSChild;
    origInXJSTag = state.inXJSTag;
    openingElement = parseXJSOpeningElement();

    if (!openingElement.selfClosing) {
        while (index &lt; length) {
            state.inXJSChild = false; // Call lookahead2() with inXJSChild = false because &lt;/ should not be considered in the child
            if (lookahead.value === &#39;&lt;&#39; &amp;&amp; lookahead2().value === &#39;/&#39;) {
                break;
            }
            state.inXJSChild = true;
            children.push(parseXJSChild());
        }
        state.inXJSChild = origInXJSChild;
        state.inXJSTag = origInXJSTag;
        closingElement = parseXJSClosingElement();
        if (getQualifiedXJSName(closingElement.name) !== getQualifiedXJSName(openingElement.name)) {
            throwError({}, Messages.ExpectedXJSClosingTag, getQualifiedXJSName(openingElement.name));
        }
    }

    // When (erroneously) writing two adjacent tags like
    //
    //     var x = &lt;div&gt;one&lt;/div&gt;&lt;div&gt;two&lt;/div&gt;;
    //
    // the default error message is a bit incomprehensible. Since it&#39;s
    // rarely (never?) useful to write a less-than sign after an XJS
    // element, we disallow it here in the parser in order to provide a
    // better error message. (In the rare case that the less-than operator
    // was intended, the left tag can be wrapped in parentheses.)
    if (!origInXJSChild &amp;&amp; match(&#39;&lt;&#39;)) {
        throwError(lookahead, Messages.AdjacentXJSElements);
    }

    return markerApply(marker, delegate.createXJSElement(openingElement, closingElement, children));
}

function parseTypeAlias() {
    var id, marker = markerCreate(), typeParameters = null, right;
    expectContextualKeyword(&#39;type&#39;);
    id = parseVariableIdentifier();
    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }
    expect(&#39;=&#39;);
    right = parseType();
    consumeSemicolon();
    return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));
}

function parseInterfaceExtends() {
    var marker = markerCreate(), id, typeParameters = null;

    id = parseVariableIdentifier();
    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterInstantiation();
    }

    return markerApply(marker, delegate.createInterfaceExtends(
        id,
        typeParameters
    ));
}

function parseInterfaceish(marker, allowStatic) {
    var body, bodyMarker, extended = [], id,
        typeParameters = null;

    id = parseVariableIdentifier();
    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }

    if (matchKeyword(&#39;extends&#39;)) {
        expectKeyword(&#39;extends&#39;);

        while (index &lt; length) {
            extended.push(parseInterfaceExtends());
            if (!match(&#39;,&#39;)) {
                break;
            }
            expect(&#39;,&#39;);
        }
    }

    bodyMarker = markerCreate();
    body = markerApply(bodyMarker, parseObjectType(allowStatic));

    return markerApply(marker, delegate.createInterface(
        id,
        typeParameters,
        body,
        extended
    ));
}

function parseInterface() {
    var body, bodyMarker, extended = [], id, marker = markerCreate(),
        typeParameters = null;

    expectContextualKeyword(&#39;interface&#39;);
    return parseInterfaceish(marker, /* allowStatic */false);
}

function parseDeclareClass() {
    var marker = markerCreate(), ret;
    expectContextualKeyword(&#39;declare&#39;);
    expectKeyword(&#39;class&#39;);

    ret = parseInterfaceish(marker, /* allowStatic */true);
    ret.type = Syntax.DeclareClass;
    return ret;
}

function parseDeclareFunction() {
    var id, idMarker,
        marker = markerCreate(), params, returnType, rest, tmp,
        typeParameters = null, value, valueMarker;

    expectContextualKeyword(&#39;declare&#39;);
    expectKeyword(&#39;function&#39;);
    idMarker = markerCreate();
    id = parseVariableIdentifier();

    valueMarker = markerCreate();
    if (match(&#39;&lt;&#39;)) {
        typeParameters = parseTypeParameterDeclaration();
    }
    expect(&#39;(&#39;);
    tmp = parseFunctionTypeParams();
    params = tmp.params;
    rest = tmp.rest;
    expect(&#39;)&#39;);

    expect(&#39;:&#39;);
    returnType = parseType();

    value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(
        params,
        returnType,
        rest,
        typeParameters
    ));

    id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(
        value
    ));
    markerApply(idMarker, id);

    consumeSemicolon();

    return markerApply(marker, delegate.createDeclareFunction(
        id
    ));
}

function parseDeclareVariable() {
    var id, marker = markerCreate();
    expectContextualKeyword(&#39;declare&#39;);
    expectKeyword(&#39;var&#39;);
    id = parseTypeAnnotatableIdentifier();

    consumeSemicolon();

    return markerApply(marker, delegate.createDeclareVariable(
        id
    ));
}

function parseDeclareModule() {
    var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;
    expectContextualKeyword(&#39;declare&#39;);
    expectContextualKeyword(&#39;module&#39;);

    if (lookahead.type === Token.StringLiteral) {
        if (strict &amp;&amp; lookahead.octal) {
            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
        }
        idMarker = markerCreate();
        id = markerApply(idMarker, delegate.createLiteral(lex()));
    } else {
        id = parseVariableIdentifier();
    }

    bodyMarker = markerCreate();
    expect(&#39;{&#39;);
    while (index &lt; length &amp;&amp; !match(&#39;}&#39;)) {
        token = lookahead2();
        switch (token.value) {
        case &#39;class&#39;:
            body.push(parseDeclareClass());
            break;
        case &#39;function&#39;:
            body.push(parseDeclareFunction());
            break;
        case &#39;var&#39;:
            body.push(parseDeclareVariable());
            break;
        default:
            throwUnexpected(lookahead);
        }
    }
    expect(&#39;}&#39;);

    return markerApply(marker, delegate.createDeclareModule(
        id,
        markerApply(bodyMarker, delegate.createBlockStatement(body))
    ));
}

function collectToken() {
    var start, loc, token, range, value, entry;

    if (!state.inXJSChild) {
        skipComment();
    }

    start = index;
    loc = {
        start: {
            line: lineNumber,
            column: index - lineStart
        }
    };

    token = extra.advance();
    loc.end = {
        line: lineNumber,
        column: index - lineStart
    };

    if (token.type !== Token.EOF) {
        range = [token.range[0], token.range[1]];
        value = source.slice(token.range[0], token.range[1]);
        entry = {
            type: TokenName[token.type],
            value: value,
            range: range,
            loc: loc
        };
        if (token.regex) {
            entry.regex = {
                pattern: token.regex.pattern,
                flags: token.regex.flags
            };
        }
        extra.tokens.push(entry);
    }

    return token;
}

function collectRegex() {
    var pos, loc, regex, token;

    skipComment();

    pos = index;
    loc = {
        start: {
            line: lineNumber,
            column: index - lineStart
        }
    };

    regex = extra.scanRegExp();
    loc.end = {
        line: lineNumber,
        column: index - lineStart
    };

    if (!extra.tokenize) {
        // Pop the previous token, which is likely &#39;/&#39; or &#39;/=&#39;
        if (extra.tokens.length &gt; 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos &amp;&amp; token.type === &#39;Punctuator&#39;) {
                if (token.value === &#39;/&#39; || token.value === &#39;/=&#39;) {
                    extra.tokens.pop();
                }
            }
        }

        extra.tokens.push({
            type: &#39;RegularExpression&#39;,
            value: regex.literal,
            regex: regex.regex,
            range: [pos, index],
            loc: loc
        });
    }

    return regex;
}

function filterTokenLocation() {
    var i, entry, token, tokens = [];

    for (i = 0; i &lt; extra.tokens.length; ++i) {
        entry = extra.tokens[i];
        token = {
            type: entry.type,
            value: entry.value
        };
        if (entry.regex) {
            token.regex = {
                pattern: entry.regex.pattern,
                flags: entry.regex.flags
            };
        }
        if (extra.range) {
            token.range = entry.range;
        }
        if (extra.loc) {
            token.loc = entry.loc;
        }
        tokens.push(token);
    }

    extra.tokens = tokens;
}

function patch() {
    if (extra.comments) {
        extra.skipComment = skipComment;
        skipComment = scanComment;
    }

    if (typeof extra.tokens !== &#39;undefined&#39;) {
        extra.advance = advance;
        extra.scanRegExp = scanRegExp;

        advance = collectToken;
        scanRegExp = collectRegex;
    }
}

function unpatch() {
    if (typeof extra.skipComment === &#39;function&#39;) {
        skipComment = extra.skipComment;
    }

    if (typeof extra.scanRegExp === &#39;function&#39;) {
        advance = extra.advance;
        scanRegExp = extra.scanRegExp;
    }
}

// This is used to modify the delegate.

function extend(object, properties) {
    var entry, result = {};

    for (entry in object) {
        if (object.hasOwnProperty(entry)) {
            result[entry] = object[entry];
        }
    }

    for (entry in properties) {
        if (properties.hasOwnProperty(entry)) {
            result[entry] = properties[entry];
        }
    }

    return result;
}

function tokenize(code, options) {
    var toString,
        token,
        tokens;

    toString = String;
    if (typeof code !== &#39;string&#39; &amp;&amp; !(code instanceof String)) {
        code = toString(code);
    }

    delegate = SyntaxTreeDelegate;
    source = code;
    index = 0;
    lineNumber = (source.length &gt; 0) ? 1 : 0;
    lineStart = 0;
    length = source.length;
    lookahead = null;
    state = {
        allowKeyword: true,
        allowIn: true,
        labelSet: {},
        inFunctionBody: false,
        inIteration: false,
        inSwitch: false,
        lastCommentStart: -1
    };

    extra = {};

    // Options matching.
    options = options || {};

    // Of course we collect tokens here.
    options.tokens = true;
    extra.tokens = [];
    extra.tokenize = true;
    // The following two fields are necessary to compute the Regex tokens.
    extra.openParenToken = -1;
    extra.openCurlyToken = -1;

    extra.range = (typeof options.range === &#39;boolean&#39;) &amp;&amp; options.range;
    extra.loc = (typeof options.loc === &#39;boolean&#39;) &amp;&amp; options.loc;

    if (typeof options.comment === &#39;boolean&#39; &amp;&amp; options.comment) {
        extra.comments = [];
    }
    if (typeof options.tolerant === &#39;boolean&#39; &amp;&amp; options.tolerant) {
        extra.errors = [];
    }

    if (length &gt; 0) {
        if (typeof source[0] === &#39;undefined&#39;) {
            // Try first to convert to a string. This is good as fast path
            // for old IE which understands string indexing for string
            // literals only and not for string object.
            if (code instanceof String) {
                source = code.valueOf();
            }
        }
    }

    patch();

    try {
        peek();
        if (lookahead.type === Token.EOF) {
            return extra.tokens;
        }

        token = lex();
        while (lookahead.type !== Token.EOF) {
            try {
                token = lex();
            } catch (lexError) {
                token = lookahead;
                if (extra.errors) {
                    extra.errors.push(lexError);
                    // We have to break on the first error
                    // to avoid infinite loops.
                    break;
                } else {
                    throw lexError;
                }
            }
        }

        filterTokenLocation();
        tokens = extra.tokens;
        if (typeof extra.comments !== &#39;undefined&#39;) {
            tokens.comments = extra.comments;
        }
        if (typeof extra.errors !== &#39;undefined&#39;) {
            tokens.errors = extra.errors;
        }
    } catch (e) {
        throw e;
    } finally {
        unpatch();
        extra = {};
    }
    return tokens;
}

function parse(code, options) {
    var program, toString;

    toString = String;
    if (typeof code !== &#39;string&#39; &amp;&amp; !(code instanceof String)) {
        code = toString(code);
    }

    delegate = SyntaxTreeDelegate;
    source = code;
    index = 0;
    lineNumber = (source.length &gt; 0) ? 1 : 0;
    lineStart = 0;
    length = source.length;
    lookahead = null;
    state = {
        allowKeyword: false,
        allowIn: true,
        labelSet: {},
        parenthesizedCount: 0,
        inFunctionBody: false,
        inIteration: false,
        inSwitch: false,
        inXJSChild: false,
        inXJSTag: false,
        inType: false,
        lastCommentStart: -1,
        yieldAllowed: false,
        awaitAllowed: false
    };

    extra = {};
    if (typeof options !== &#39;undefined&#39;) {
        extra.range = (typeof options.range === &#39;boolean&#39;) &amp;&amp; options.range;
        extra.loc = (typeof options.loc === &#39;boolean&#39;) &amp;&amp; options.loc;
        extra.attachComment = (typeof options.attachComment === &#39;boolean&#39;) &amp;&amp; options.attachComment;

        if (extra.loc &amp;&amp; options.source !== null &amp;&amp; options.source !== undefined) {
            delegate = extend(delegate, {
                &#39;postProcess&#39;: function (node) {
                    node.loc.source = toString(options.source);
                    return node;
                }
            });
        }

        if (typeof options.tokens === &#39;boolean&#39; &amp;&amp; options.tokens) {
            extra.tokens = [];
        }
        if (typeof options.comment === &#39;boolean&#39; &amp;&amp; options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === &#39;boolean&#39; &amp;&amp; options.tolerant) {
            extra.errors = [];
        }
        if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            extra.bottomRightStack = [];
            extra.trailingComments = [];
            extra.leadingComments = [];
        }
    }

    if (length &gt; 0) {
        if (typeof source[0] === &#39;undefined&#39;) {
            // Try first to convert to a string. This is good as fast path
            // for old IE which understands string indexing for string
            // literals only and not for string object.
            if (code instanceof String) {
                source = code.valueOf();
            }
        }
    }

    patch();
    try {
        program = parseProgram();
        if (typeof extra.comments !== &#39;undefined&#39;) {
            program.comments = extra.comments;
        }
        if (typeof extra.tokens !== &#39;undefined&#39;) {
            filterTokenLocation();
            program.tokens = extra.tokens;
        }
        if (typeof extra.errors !== &#39;undefined&#39;) {
            program.errors = extra.errors;
        }
    } catch (e) {
        throw e;
    } finally {
        unpatch();
        extra = {};
    }

    return program;
}

// Sync with *.json manifests.
exports.version = &#39;8001.1001.0-dev-harmony-fb&#39;;

exports.tokenize = tokenize;

exports.parse = parse;

// Deep copy.
exports.Syntax = (function () {
    var name, types = {};

    if (typeof Object.create === &#39;function&#39;) {
        types = Object.create(null);
    }

    for (name in Syntax) {
        if (Syntax.hasOwnProperty(name)) {
            types[name] = Syntax[name];
        }
    }

    if (typeof Object.freeze === &#39;function&#39;) {
        Object.freeze(types);
    }

    return types;
}());</pre>

<p>})); /* vim: set sw=4 ts=4 et tw=80 : */</p>

<p>},{}],10:[function(<em>dereq</em>,module,exports){ /*</p>

<pre> Copyright 2009-2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE.txt or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>exports.SourceMapGenerator =
<em>dereq</em>(&#39;./source-map/source-map-generator&#39;).SourceMapGenerator;
exports.SourceMapConsumer =
<em>dereq</em>(&#39;./source-map/source-map-consumer&#39;).SourceMapConsumer;
exports.SourceNode =
<em>dereq</em>(&#39;./source-map/source-node&#39;).SourceNode;</p>

<p>},{“./source-map/source-map-consumer”:15,“./source-map/source-map-generator”:16,“./source-map/source-node”:17}],11:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var util = _dereq_(&#39;./util&#39;);

/**
   A data structure which is a combination of an array and a set. Adding a new
   member is O(1), testing for membership is O(1), and finding the index of an
   element is O(1). Removing elements from the set is not supported. Only
   strings are supported for membership.
  /
function ArraySet() {
  this._array = [];
  this._set = {};
}

/**
   Static method for creating ArraySet instances from an existing array.
  /
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i &lt; len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
   Add the given string to this set.

   @param String aStr
  /
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var isDuplicate = this.has(aStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[util.toSetString(aStr)] = idx;
  }
};

/**
   Is the given string a member of this set?

   @param String aStr
  /
ArraySet.prototype.has = function ArraySet_has(aStr) {
  return Object.prototype.hasOwnProperty.call(this._set,
                                              util.toSetString(aStr));
};

/**
   What is the index of the given string in the array?

   @param String aStr
  /
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (this.has(aStr)) {
    return this._set[util.toSetString(aStr)];
  }
  throw new Error(&#39;&quot;&#39; + aStr + &#39;&quot; is not in the set.&#39;);
};

/**
   What is the element at the given index?

   @param Number aIdx
  /
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx &gt;= 0 &amp;&amp; aIdx &lt; this._array.length) {
    return this._array[aIdx];
  }
  throw new Error(&#39;No element indexed by &#39; + aIdx);
};

/**
   Returns the array representation of this set (which has the proper indices
   indicated by indexOf). Note that this is a copy of the internal array used
   for storing the members so that no one can mess with internal state.
  /
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;</pre>

<p>});</p>

<p>},{“./util”:18,“amdefine”:19}],12:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause

 Based on the Base 64 VLQ implementation in Closure Compiler:
 https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java

 Copyright 2011 The Closure Compiler Authors. All rights reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

    Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following
    disclaimer in the documentation and/or other materials provided
    with the distribution.
    Neither the name of Google Inc. nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var base64 = _dereq_(&#39;./base64&#39;);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 &lt;&lt; VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
   Converts from a two-complement value to a value where the sign bit is
   is placed in the least significant bit.  For example, as decimals:
     1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
     2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
  /
function toVLQSigned(aValue) {
  return aValue &lt; 0
    ? ((-aValue) &lt;&lt; 1) + 1
    : (aValue &lt;&lt; 1) + 0;
}

/**
   Converts to a two-complement value from a value where the sign bit is
   is placed in the least significant bit.  For example, as decimals:
     2 (10 binary) becomes 1, 3 (11 binary) becomes -1
     4 (100 binary) becomes 2, 5 (101 binary) becomes -2
  /
function fromVLQSigned(aValue) {
  var isNegative = (aValue &amp; 1) === 1;
  var shifted = aValue &gt;&gt; 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
   Returns the base 64 VLQ encoded value.
  /
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = &quot;&quot;;
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq &amp; VLQ_BASE_MASK;
    vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;
    if (vlq &gt; 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq &gt; 0);

  return encoded;
};

/**
   Decodes the next base 64 VLQ value from the given string and returns the
   value and the rest of the string.
  /
exports.decode = function base64VLQ_decode(aStr) {
  var i = 0;
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (i &gt;= strLen) {
      throw new Error(&quot;Expected more digits in base 64 VLQ value.&quot;);
    }
    digit = base64.decode(aStr.charAt(i++));
    continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);
    digit &amp;= VLQ_BASE_MASK;
    result = result + (digit &lt;&lt; shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  return {
    value: fromVLQSigned(result),
    rest: aStr.slice(i)
  };
};</pre>

<p>});</p>

<p>},{“./base64”:13,“amdefine”:19}],13:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var charToIntMap = {};
var intToCharMap = {};

&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;
  .split(&#39;&#39;)
  .forEach(function (ch, index) {
    charToIntMap[ch] = index;
    intToCharMap[index] = ch;
  });

/**
   Encode an integer in the range of 0 to 63 to a single base 64 digit.
  /
exports.encode = function base64_encode(aNumber) {
  if (aNumber in intToCharMap) {
    return intToCharMap[aNumber];
  }
  throw new TypeError(&quot;Must be between 0 and 63: &quot; + aNumber);
};

/**
   Decode a single base 64 digit to an integer.
  /
exports.decode = function base64_decode(aChar) {
  if (aChar in charToIntMap) {
    return charToIntMap[aChar];
  }
  throw new TypeError(&quot;Not a valid base 64 digit: &quot; + aChar);
};</pre>

<p>});</p>

<p>},{“amdefine”:19}],14:[function(<em>dereq</em>,module,exports){ /* -*-
Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>/**
   Recursive implementation of binary search.

   @param aLow Indices here and lower do not contain the needle.
   @param aHigh Indices here and higher do not contain the needle.
   @param aNeedle The element being searched for.
   @param aHaystack The non-empty array being searched.
   @param aCompare Function which takes two elements and returns -1, 0, or 1.
  /
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the next
  //      closest element that is less than that element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element which is less than the one we are searching for, so we
  //      return null.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return aHaystack[mid];
  }
  else if (cmp &gt; 0) {
    // aHaystack[mid] is greater than our needle.
    if (aHigh - mid &gt; 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
    }
    // We did not find an exact match, return the next closest one
    // (termination case 2).
    return aHaystack[mid];
  }
  else {
    // aHaystack[mid] is less than our needle.
    if (mid - aLow &gt; 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
    }
    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (2) or (3) and return the appropriate thing.
    return aLow &lt; 0
      ? null
      : aHaystack[aLow];
  }
}

/**
   This is an implementation of binary search which will always try and return
   the next lowest value checked if there is no exact hit. This is because
   mappings between original and generated line/col pairs are single points,
   and there is an implicit region between each of them, so a miss just means
   that you aren&#39;t on the very start of a region.

   @param aNeedle The element you are looking for.
   @param aHaystack The array that is being searched.
   @param aCompare A function which takes the needle and an element in the
       array and returns -1, 0, or 1 depending on whether the needle is less
       than, equal to, or greater than the element, respectively.
  /
exports.search = function search(aNeedle, aHaystack, aCompare) {
  return aHaystack.length &gt; 0
    ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
    : null;
};</pre>

<p>});</p>

<p>},{“amdefine”:19}],15:[function(<em>dereq</em>,module,exports){ /* -*-
Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var util = _dereq_(&#39;./util&#39;);
var binarySearch = _dereq_(&#39;./binary-search&#39;);
var ArraySet = _dereq_(&#39;./array-set&#39;).ArraySet;
var base64VLQ = _dereq_(&#39;./base64-vlq&#39;);

/**
   A SourceMapConsumer instance represents a parsed source map which we can
   query for information about the original file positions by giving it a file
   position in the generated source.

   The only parameter is the raw source map (either as a JSON string, or
   already parsed to an object). According to the spec, source maps have the
   following attributes:

     - version: Which version of the source map spec this map is following.
     - sources: An array of URLs to the original source files.
     - names: An array of identifiers which can be referrenced by individual mappings.
     - sourceRoot: Optional. The URL root from which all sources are relative.
     - sourcesContent: Optional. An array of contents of the original source files.
     - mappings: A string of base64 VLQs which contain the actual mappings.
     - file: The generated file this source map is associated with.

   Here is an example source map, taken from the source map spec[0]:

       {
         version : 3,
         file: &quot;out.js&quot;,
         sourceRoot : &quot;&quot;,
         sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],
         names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],
         mappings: &quot;AA,AB;;ABCDE;&quot;
       }

   [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
  /
function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === &#39;string&#39;) {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}&#39;/, &#39;&#39;));
  }

  var version = util.getArg(sourceMap, &#39;version&#39;);
  var sources = util.getArg(sourceMap, &#39;sources&#39;);
  // Sass 3.3 leaves out the &#39;names&#39; array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, &#39;names&#39;, []);
  var sourceRoot = util.getArg(sourceMap, &#39;sourceRoot&#39;, null);
  var sourcesContent = util.getArg(sourceMap, &#39;sourcesContent&#39;, null);
  var mappings = util.getArg(sourceMap, &#39;mappings&#39;);
  var file = util.getArg(sourceMap, &#39;file&#39;, null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error(&#39;Unsupported version: &#39; + version);
  }

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names, true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

/**
   Create a SourceMapConsumer from a SourceMapGenerator.

   @param SourceMapGenerator aSourceMap
          The source map that will be consumed.
   @returns SourceMapConsumer
  /
SourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(SourceMapConsumer.prototype);

    smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    smc.__generatedMappings = aSourceMap._mappings.slice()
      .sort(util.compareByGeneratedPositions);
    smc.__originalMappings = aSourceMap._mappings.slice()
      .sort(util.compareByOriginalPositions);

    return smc;
  };

/**
   The version of the source mapping spec that we are consuming.
  /
SourceMapConsumer.prototype._version = 3;

/**
   The list of original sources.
  /
Object.defineProperty(SourceMapConsumer.prototype, &#39;sources&#39;, {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map&#39;s &quot;mappings&quot; attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, &#39;_generatedMappings&#39;, {
  get: function () {
    if (!this.__generatedMappings) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, &#39;_originalMappings&#39;, {
  get: function () {
    if (!this.__originalMappings) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

/**
   Parse the mappings in a string in to a data structure which we can easily
   query (the ordered arrays in the `this.__generatedMappings` and
   `this.__originalMappings` properties).
  /
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var mappingSeparator = /^[,;]/;
    var str = aStr;
    var mapping;
    var temp;

    while (str.length &gt; 0) {
      if (str.charAt(0) === &#39;;&#39;) {
        generatedLine++;
        str = str.slice(1);
        previousGeneratedColumn = 0;
      }
      else if (str.charAt(0) === &#39;,&#39;) {
        str = str.slice(1);
      }
      else {
        mapping = {};
        mapping.generatedLine = generatedLine;

        // Generated column.
        temp = base64VLQ.decode(str);
        mapping.generatedColumn = previousGeneratedColumn + temp.value;
        previousGeneratedColumn = mapping.generatedColumn;
        str = temp.rest;

        if (str.length &gt; 0 &amp;&amp; !mappingSeparator.test(str.charAt(0))) {
          // Original source.
          temp = base64VLQ.decode(str);
          mapping.source = this._sources.at(previousSource + temp.value);
          previousSource += temp.value;
          str = temp.rest;
          if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
            throw new Error(&#39;Found a source, but no line and column&#39;);
          }

          // Original line.
          temp = base64VLQ.decode(str);
          mapping.originalLine = previousOriginalLine + temp.value;
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;
          str = temp.rest;
          if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
            throw new Error(&#39;Found a source and line, but no column&#39;);
          }

          // Original column.
          temp = base64VLQ.decode(str);
          mapping.originalColumn = previousOriginalColumn + temp.value;
          previousOriginalColumn = mapping.originalColumn;
          str = temp.rest;

          if (str.length &gt; 0 &amp;&amp; !mappingSeparator.test(str.charAt(0))) {
            // Original name.
            temp = base64VLQ.decode(str);
            mapping.name = this._names.at(previousName + temp.value);
            previousName += temp.value;
            str = temp.rest;
          }
        }

        this.__generatedMappings.push(mapping);
        if (typeof mapping.originalLine === &#39;number&#39;) {
          this.__originalMappings.push(mapping);
        }
      }
    }

    this.__originalMappings.sort(util.compareByOriginalPositions);
  };

/**
   Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that
   we are searching for in the given &quot;haystack&quot; of mappings.
  /
SourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] &lt;= 0) {
      throw new TypeError(&#39;Line must be greater than or equal to 1, got &#39;
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] &lt; 0) {
      throw new TypeError(&#39;Column must be greater than or equal to 0, got &#39;
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator);
  };

/**
   Returns the original source, line, and column information for the generated
   source&#39;s line and column positions provided. The only argument is an object
   with the following properties:

     - line: The line number in the generated source.
     - column: The column number in the generated source.

   and an object is returned with the following properties:

     - source: The original source file, or null.
     - line: The line number in the original source, or null.
     - column: The column number in the original source, or null.
     - name: The original identifier, or null.
  /
SourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, &#39;line&#39;),
      generatedColumn: util.getArg(aArgs, &#39;column&#39;)
    };

    var mapping = this._findMapping(needle,
                                    this._generatedMappings,
                                    &quot;generatedLine&quot;,
                                    &quot;generatedColumn&quot;,
                                    util.compareByGeneratedPositions);

    if (mapping) {
      var source = util.getArg(mapping, &#39;source&#39;, null);
      if (source &amp;&amp; this.sourceRoot) {
        source = util.join(this.sourceRoot, source);
      }
      return {
        source: source,
        line: util.getArg(mapping, &#39;originalLine&#39;, null),
        column: util.getArg(mapping, &#39;originalColumn&#39;, null),
        name: util.getArg(mapping, &#39;name&#39;, null)
      };
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
   Returns the original source content. The only argument is the url of the
   original source file. Returns null if no original source content is
   availible.
  /
SourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot
        &amp;&amp; (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, &quot;&quot;);
      if (url.scheme == &quot;file&quot;
          &amp;&amp; this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == &quot;/&quot;)
          &amp;&amp; this._sources.has(&quot;/&quot; + aSource)) {
        return this.sourcesContent[this._sources.indexOf(&quot;/&quot; + aSource)];
      }
    }

    throw new Error(&#39;&quot;&#39; + aSource + &#39;&quot; is not in the SourceMap.&#39;);
  };

/**
   Returns the generated line and column information for the original source,
   line, and column positions provided. The only argument is an object with
   the following properties:

     - source: The filename of the original source.
     - line: The line number in the original source.
     - column: The column number in the original source.

   and an object is returned with the following properties:

     - line: The line number in the generated source, or null.
     - column: The column number in the generated source, or null.
  /
SourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var needle = {
      source: util.getArg(aArgs, &#39;source&#39;),
      originalLine: util.getArg(aArgs, &#39;line&#39;),
      originalColumn: util.getArg(aArgs, &#39;column&#39;)
    };

    if (this.sourceRoot) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }

    var mapping = this._findMapping(needle,
                                    this._originalMappings,
                                    &quot;originalLine&quot;,
                                    &quot;originalColumn&quot;,
                                    util.compareByOriginalPositions);

    if (mapping) {
      return {
        line: util.getArg(mapping, &#39;generatedLine&#39;, null),
        column: util.getArg(mapping, &#39;generatedColumn&#39;, null)
      };
    }

    return {
      line: null,
      column: null
    };
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

/**
   Iterate over each mapping between an original source/line/column and a
   generated line/column in this source map.

   @param Function aCallback
          The function that is called with each mapping.
   @param Object aContext
          Optional. If specified, this object will be the value of `this` every
          time that `aCallback` is called.
   @param aOrder
          Either `SourceMapConsumer.GENERATED_ORDER` or
          `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
          iterate over the mappings sorted by the generated file&#39;s line/column
          order or the original&#39;s source/line/column order, respectively. Defaults to
          `SourceMapConsumer.GENERATED_ORDER`.
  /
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error(&quot;Unknown order of iteration.&quot;);
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source;
      if (source &amp;&amp; sourceRoot) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name
      };
    }).forEach(aCallback, context);
  };

exports.SourceMapConsumer = SourceMapConsumer;</pre>

<p>});</p>

<p>},{“./array-set”:11,“./base64-vlq”:12,“./binary-search”:14,“./util”:18,“amdefine”:19}],16:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var base64VLQ = _dereq_(&#39;./base64-vlq&#39;);
var util = _dereq_(&#39;./util&#39;);
var ArraySet = _dereq_(&#39;./array-set&#39;).ArraySet;

/**
   An instance of the SourceMapGenerator represents a source map which is
   being built incrementally. To create a new one, you must pass an object
   with the following properties:

     - file: The filename of the generated source.
     - sourceRoot: An optional root for all URLs in this source map.
  /
function SourceMapGenerator(aArgs) {
  this._file = util.getArg(aArgs, &#39;file&#39;);
  this._sourceRoot = util.getArg(aArgs, &#39;sourceRoot&#39;, null);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = [];
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
   Creates a new SourceMapGenerator based on a SourceMapConsumer

   @param aSourceMapConsumer The SourceMap.
  /
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source) {
        newMapping.source = mapping.source;
        if (sourceRoot) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
   Add a single mapping from original source line and column to the generated
   source&#39;s line and column for this source map being created. The mapping
   object should have the following properties:

     - generated: An object with the generated line and column positions.
     - original: An object with the original line and column positions.
     - source: The original source file (relative to the sourceRoot).
     - name: An optional original token name for this mapping.
  /
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, &#39;generated&#39;);
    var original = util.getArg(aArgs, &#39;original&#39;, null);
    var source = util.getArg(aArgs, &#39;source&#39;, null);
    var name = util.getArg(aArgs, &#39;name&#39;, null);

    this._validateMapping(generated, original, source, name);

    if (source &amp;&amp; !this._sources.has(source)) {
      this._sources.add(source);
    }

    if (name &amp;&amp; !this._names.has(name)) {
      this._names.add(name);
    }

    this._mappings.push({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null &amp;&amp; original.line,
      originalColumn: original != null &amp;&amp; original.column,
      source: source,
      name: name
    });
  };

/**
   Set the source content for a source file.
  /
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent !== null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = {};
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
   Applies the mappings of a sub-source-map for a specific source file to the
   source map being generated. Each mapping to the supplied source file is
   rewritten using the supplied source map. Note: The resolution for the
   resulting mappings is the minimium of this map and the supplied map.

   @param aSourceMapConsumer The source map to be applied.
   @param aSourceFile Optional. The filename of the source file.
          If omitted, SourceMapConsumer&#39;s file property will be used.
  /
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (!aSourceFile) {
      aSourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make &quot;aSourceFile&quot; relative if an absolute Url is passed.
    if (sourceRoot) {
      aSourceFile = util.relative(sourceRoot, aSourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the &quot;aSourceFile&quot;
    this._mappings.forEach(function (mapping) {
      if (mapping.source === aSourceFile &amp;&amp; mapping.originalLine) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source !== null) {
          // Copy mapping
          if (sourceRoot) {
            mapping.source = util.relative(sourceRoot, original.source);
          } else {
            mapping.source = original.source;
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name !== null &amp;&amp; mapping.name !== null) {
            // Only use the identifier name if it&#39;s an identifier
            // in both SourceMaps
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source &amp;&amp; !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name &amp;&amp; !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        if (sourceRoot) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
   A mapping can have one of the three levels of data:

     1. Just the generated position.
     2. The Generated position, original position, and original source.
     3. Generated and original position, original source, as well as a name
        token.

   To maintain consistency, we validate that any new mapping being added falls
   in to one of these categories.
  /
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated &amp;&amp; &#39;line&#39; in aGenerated &amp;&amp; &#39;column&#39; in aGenerated
        &amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0
        &amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated &amp;&amp; &#39;line&#39; in aGenerated &amp;&amp; &#39;column&#39; in aGenerated
             &amp;&amp; aOriginal &amp;&amp; &#39;line&#39; in aOriginal &amp;&amp; &#39;column&#39; in aOriginal
             &amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0
             &amp;&amp; aOriginal.line &gt; 0 &amp;&amp; aOriginal.column &gt;= 0
             &amp;&amp; aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error(&#39;Invalid mapping: &#39; + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        orginal: aOriginal,
        name: aName
      }));
    }
  };

/**
   Serialize the accumulated mappings in to the stream of base 64 VLQs
   specified by the source map format.
  /
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = &#39;&#39;;
    var mapping;

    // The mappings must be guaranteed to be in sorted order before we start
    // serializing them or else the generated line numbers (which are defined
    // via the &#39;;&#39; separators) will be all messed up. Note: it might be more
    // performant to maintain the sorting as we insert them, rather than as we
    // serialize them, but the big O is the same either way.
    this._mappings.sort(util.compareByGeneratedPositions);

    for (var i = 0, len = this._mappings.length; i &lt; len; i++) {
      mapping = this._mappings[i];

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          result += &#39;;&#39;;
          previousGeneratedLine++;
        }
      }
      else {
        if (i &gt; 0) {
          if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
            continue;
          }
          result += &#39;,&#39;;
        }
      }

      result += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source) {
        result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                   - previousSource);
        previousSource = this._sources.indexOf(mapping.source);

        // lines are stored 0-based in SourceMap spec version 3
        result += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        result += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name) {
          result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                     - previousName);
          previousName = this._names.indexOf(mapping.name);
        }
      }
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                  key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
   Externalize the source map.
  /
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      file: this._file,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._sourceRoot) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
   Render the source map being generated to a string.
  /
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this);
  };

exports.SourceMapGenerator = SourceMapGenerator;</pre>

<p>});</p>

<p>},{“./array-set”:11,“./base64-vlq”:12,“./util”:18,“amdefine”:19}],17:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>var SourceMapGenerator = _dereq_(&#39;./source-map-generator&#39;).SourceMapGenerator;
var util = _dereq_(&#39;./util&#39;);

/**
   SourceNodes provide a way to abstract over interpolating/concatenating
   snippets of generated JavaScript source code while maintaining the line and
   column information associated with the original source code.

   @param aLine The original line number.
   @param aColumn The original column number.
   @param aSource The original source&#39;s filename.
   @param aChunks Optional. An array of strings which are snippets of
          generated JS, or other SourceNodes.
   @param aName The original identifier.
  /
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine === undefined ? null : aLine;
  this.column = aColumn === undefined ? null : aColumn;
  this.source = aSource === undefined ? null : aSource;
  this.name = aName === undefined ? null : aName;
  if (aChunks != null) this.add(aChunks);
}

/**
   Creates a SourceNode from generated code and a SourceMapConsumer.

   @param aGeneratedCode The generated code
   @param aSourceMapConsumer The SourceMap for the generated code
  /
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // The generated code
    // Processed fragments are removed from this array.
    var remainingLines = aGeneratedCode.split(&#39;\n&#39;);

    // We need to remember the position of &quot;remainingLines&quot;
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping === null) {
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine &lt; mapping.generatedLine) {
          node.add(remainingLines.shift() + &quot;\n&quot;);
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn &lt; mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
      } else {
        // We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:
        // First check if there is a new line in between.
        if (lastGeneratedLine &lt; mapping.generatedLine) {
          var code = &quot;&quot;;
          // Associate full lines with &quot;lastMapping&quot;
          do {
            code += remainingLines.shift() + &quot;\n&quot;;
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } while (lastGeneratedLine &lt; mapping.generatedLine);
          // When we reached the correct line, we add code until we
          // reach the correct column too.
          if (lastGeneratedColumn &lt; mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            code += nextLine.substr(0, mapping.generatedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          // Create the SourceNode.
          addMappingWithCode(lastMapping, code);
        } else {
          // There is no new line in between.
          // Associate the code between &quot;lastGeneratedColumn&quot; and
          // &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
        }
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    // Associate the remaining code in the current line with &quot;lastMapping&quot;
    // and add the remaining lines without any mapping
    addMappingWithCode(lastMapping, remainingLines.join(&quot;\n&quot;));

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content) {
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                mapping.source,
                                code,
                                mapping.name));
      }
    }
  };

/**
   Add a chunk of generated JS to this source node.

   @param aChunk A string snippet of generated JS code, another instance of
          SourceNode, or an array where each member is one of those things.
  /
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk instanceof SourceNode || typeof aChunk === &quot;string&quot;) {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      &quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; + aChunk
    );
  }
  return this;
};

/**
   Add a chunk of generated JS to the beginning of this source node.

   @param aChunk A string snippet of generated JS code, another instance of
          SourceNode, or an array where each member is one of those things.
  /
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i &gt;= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk instanceof SourceNode || typeof aChunk === &quot;string&quot;) {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      &quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; + aChunk
    );
  }
  return this;
};

/**
   Walk over the tree of JS snippets in this node and its children. The
   walking function is called once for each snippet of JS and is passed that
   snippet and the its original associated source&#39;s line/column location.

   @param aFn The traversal function.
  /
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i &lt; len; i++) {
    chunk = this.children[i];
    if (chunk instanceof SourceNode) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== &#39;&#39;) {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
   Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   each of `this.children`.

   @param aSep The separator.
  /
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len &gt; 0) {
    newChildren = [];
    for (i = 0; i &lt; len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
   Call String.prototype.replace on the very right-most source snippet. Useful
   for trimming whitespace from the end of a source node, etc.

   @param aPattern The pattern to replace.
   @param aReplacement The thing to replace the pattern with.
  /
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild instanceof SourceNode) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === &#39;string&#39;) {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(&#39;&#39;.replace(aPattern, aReplacement));
  }
  return this;
};

/**
   Set the source content for a source file. This will be added to the SourceMapGenerator
   in the sourcesContent field.

   @param aSourceFile The filename of the source file
   @param aSourceContent The content of the source file
  /
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
   Walk over the tree of SourceNodes. The walking function is called for each
   source file content and is passed the filename and source content.

   @param aFn The traversal function.
  /
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i &lt; len; i++) {
      if (this.children[i] instanceof SourceNode) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i &lt; len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
   Return the string representation of this source node. Walks over the tree
   and concatenates all the various snippets together to one string.
  /
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = &quot;&quot;;
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
   Returns the string representation of this source node along with a source
   map.
  /
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: &quot;&quot;,
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        &amp;&amp; original.line !== null
        &amp;&amp; original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    chunk.split(&#39;&#39;).forEach(function (ch) {
      if (ch === &#39;\n&#39;) {
        generated.line++;
        generated.column = 0;
      } else {
        generated.column++;
      }
    });
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;</pre>

<p>});</p>

<p>},{“./source-map-generator”:16,“./util”:18,“amdefine”:19}],18:[function(<em>dereq</em>,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */ /*</p>

<pre> Copyright 2011 Mozilla Foundation and contributors
 Licensed under the New BSD license. See LICENSE or:
 http://opensource.org/licenses/BSD-3-Clause
/</pre>

<p>if (typeof define !== &#39;function&#39;) {</p>

<pre>var define = _dereq_(&#39;amdefine&#39;)(module, _dereq_);</pre>

<p>} define(function (<em>dereq</em>, exports, module) {</p>

<pre>/**
   This is a helper function for getting values from parameter/options
   objects.

   @param args The object we are extracting values from
   @param name The name of the property we are getting.
   @param defaultValue An optional value to return if the property is missing
   from the object. If this is not specified and the property is missing, an
   error will be thrown.
  /
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error(&#39;&quot;&#39; + aName + &#39;&quot; is a required argument.&#39;);
  }
}
exports.getArg = getArg;

var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
var dataUrlRegexp = /^data:.+\,.+/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[3],
    host: match[4],
    port: match[6],
    path: match[7]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = aParsedUrl.scheme + &quot;://&quot;;
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + &quot;@&quot;
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += &quot;:&quot; + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

function join(aRoot, aPath) {
  var url;

  if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  if (aPath.charAt(0) === &#39;/&#39; &amp;&amp; (url = urlParse(aRoot))) {
    url.path = aPath;
    return urlGenerate(url);
  }

  return aRoot.replace(/\/$/, &#39;&#39;) + &#39;/&#39; + aPath;
}
exports.join = join;

/**
   Because behavior goes wacky when you set `__proto__` on objects, we
   have to prefix all the strings in our set with an arbitrary character.

   See https://github.com/mozilla/source-map/pull/31 and
   https://github.com/mozilla/source-map/issues/30

   @param String aStr
  /
function toSetString(aStr) {
  return &#39;$&#39; + aStr;
}
exports.toSetString = toSetString;

function fromSetString(aStr) {
  return aStr.substr(1);
}
exports.fromSetString = fromSetString;

function relative(aRoot, aPath) {
  aRoot = aRoot.replace(/\/$/, &#39;&#39;);

  var url = urlParse(aRoot);
  if (aPath.charAt(0) == &quot;/&quot; &amp;&amp; url &amp;&amp; url.path == &quot;/&quot;) {
    return aPath.slice(1);
  }

  return aPath.indexOf(aRoot + &#39;/&#39;) === 0
    ? aPath.substr(aRoot.length + 1)
    : aPath;
}
exports.relative = relative;

function strcmp(aStr1, aStr2) {
  var s1 = aStr1 || &quot;&quot;;
  var s2 = aStr2 || &quot;&quot;;
  return (s1 &gt; s2) - (s1 &lt; s2);
}

/**
   Comparator between two mappings where the original positions are compared.

   Optionally pass in `true` as `onlyCompareGenerated` to consider two
   mappings with the same original source/line/column, but different generated
   line and column the same. Useful when searching for a mapping with a
   stubbed out mapping.
  /
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp;

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp || onlyCompareOriginal) {
    return cmp;
  }

  cmp = strcmp(mappingA.name, mappingB.name);
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp) {
    return cmp;
  }

  return mappingA.generatedColumn - mappingB.generatedColumn;
};
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
   Comparator between two mappings where the generated positions are
   compared.

   Optionally pass in `true` as `onlyCompareGenerated` to consider two
   mappings with the same generated line and column, but different
   source/name/original line and column the same. Useful when searching for a
   mapping with a stubbed out mapping.
  /
function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
  var cmp;

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
};
exports.compareByGeneratedPositions = compareByGeneratedPositions;</pre>

<p>});</p>

<p>},{“amdefine”:19}],19:[function(<em>dereq</em>,module,exports){ (function
(process,__filename){ /** vim: et:ts=4:sw=4:sts=4</p>

<pre> @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/amdefine for details
/</pre>

<p>/*jslint node: true */ /*global module, process */ &#39;use strict&#39;;</p>

<p>/**</p>

<pre> Creates a define for node.
 @param {Object} module the &quot;module&quot; object that is defined by Node for the
 current module.
 @param {Function} [requireFn]. Node&#39;s require function for the current module.
 It only needs to be passed in Node versions before 0.5, when module.require
 did not exist.
 @returns {Function} a define function that is usable for the current node
 module.
/</pre>

<p>function amdefine(module, requireFn) {</p>

<pre>&#39;use strict&#39;;
var defineCache = {},
    loaderCache = {},
    alreadyCalled = false,
    path = _dereq_(&#39;path&#39;),
    makeRequire, stringRequire;

/**
   Trims the . and .. from an array of path segments.
   It will keep a leading path segment if a .. will become
   the first path segment, to help with module name lookups,
   which act like paths, but can be remapped. But the end result,
   all paths that use this function should look normalized.
   NOTE: this method MODIFIES the input array.
   @param {Array} ary the array of path segments.
  /
function trimDots(ary) {
    var i, part;
    for (i = 0; ary[i]; i+= 1) {
        part = ary[i];
        if (part === &#39;.&#39;) {
            ary.splice(i, 1);
            i -= 1;
        } else if (part === &#39;..&#39;) {
            if (i === 1 &amp;&amp; (ary[2] === &#39;..&#39; || ary[0] === &#39;..&#39;)) {
                //End of the line. Keep at least one non-dot
                //path segment at the front so it can be mapped
                //correctly to disk. Otherwise, there is likely
                //no path mapping for a path starting with &#39;..&#39;.
                //This can still fail, but catches the most reasonable
                //uses of ..
                break;
            } else if (i &gt; 0) {
                ary.splice(i - 1, 2);
                i -= 2;
            }
        }
    }
}

function normalize(name, baseName) {
    var baseParts;

    //Adjust any relative paths.
    if (name &amp;&amp; name.charAt(0) === &#39;.&#39;) {
        //If have a base name, try to normalize against it,
        //otherwise, assume it is a top-level require that will
        //be relative to baseUrl in the end.
        if (baseName) {
            baseParts = baseName.split(&#39;/&#39;);
            baseParts = baseParts.slice(0, baseParts.length - 1);
            baseParts = baseParts.concat(name.split(&#39;/&#39;));
            trimDots(baseParts);
            name = baseParts.join(&#39;/&#39;);
        }
    }

    return name;
}

/**
   Create the normalize() function passed to a loader plugin&#39;s
   normalize method.
  /
function makeNormalize(relName) {
    return function (name) {
        return normalize(name, relName);
    };
}

function makeLoad(id) {
    function load(value) {
        loaderCache[id] = value;
    }

    load.fromText = function (id, text) {
        //This one is difficult because the text can/probably uses
        //define, and any relative paths and requires should be relative
        //to that id was it would be found on disk. But this would require
        //bootstrapping a module/require fairly deeply from node core.
        //Not sure how best to go about that yet.
        throw new Error(&#39;amdefine does not implement load.fromText&#39;);
    };

    return load;
}

makeRequire = function (systemRequire, exports, module, relId) {
    function amdRequire(deps, callback) {
        if (typeof deps === &#39;string&#39;) {
            //Synchronous, single module require(&#39;&#39;)
            return stringRequire(systemRequire, exports, module, deps, relId);
        } else {
            //Array of dependencies with a callback.

            //Convert the dependencies to modules.
            deps = deps.map(function (depName) {
                return stringRequire(systemRequire, exports, module, depName, relId);
            });

            //Wait for next tick to call back the require call.
            process.nextTick(function () {
                callback.apply(null, deps);
            });
        }
    }

    amdRequire.toUrl = function (filePath) {
        if (filePath.indexOf(&#39;.&#39;) === 0) {
            return normalize(filePath, path.dirname(module.filename));
        } else {
            return filePath;
        }
    };

    return amdRequire;
};

//Favor explicit value, passed in if the module wants to support Node 0.4.
requireFn = requireFn || function req() {
    return module.require.apply(module, arguments);
};

function runFactory(id, deps, factory) {
    var r, e, m, result;

    if (id) {
        e = loaderCache[id] = {};
        m = {
            id: id,
            uri: __filename,
            exports: e
        };
        r = makeRequire(requireFn, e, m, id);
    } else {
        //Only support one define call per file
        if (alreadyCalled) {
            throw new Error(&#39;amdefine with no module ID cannot be called more than once per file.&#39;);
        }
        alreadyCalled = true;

        //Use the real variables from node
        //Use module.exports for exports, since
        //the exports in here is amdefine exports.
        e = module.exports;
        m = module;
        r = makeRequire(requireFn, e, m, module.id);
    }

    //If there are dependencies, they are strings, so need
    //to convert them to dependency values.
    if (deps) {
        deps = deps.map(function (depName) {
            return r(depName);
        });
    }

    //Call the factory with the right dependencies.
    if (typeof factory === &#39;function&#39;) {
        result = factory.apply(m.exports, deps);
    } else {
        result = factory;
    }

    if (result !== undefined) {
        m.exports = result;
        if (id) {
            loaderCache[id] = m.exports;
        }
    }
}

stringRequire = function (systemRequire, exports, module, id, relId) {
    //Split the ID by a ! so that
    var index = id.indexOf(&#39;!&#39;),
        originalId = id,
        prefix, plugin;

    if (index === -1) {
        id = normalize(id, relId);

        //Straight module lookup. If it is one of the special dependencies,
        //deal with it, otherwise, delegate to node.
        if (id === &#39;require&#39;) {
            return makeRequire(systemRequire, exports, module, relId);
        } else if (id === &#39;exports&#39;) {
            return exports;
        } else if (id === &#39;module&#39;) {
            return module;
        } else if (loaderCache.hasOwnProperty(id)) {
            return loaderCache[id];
        } else if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        } else {
            if(systemRequire) {
                return systemRequire(originalId);
            } else {
                throw new Error(&#39;No module with ID: &#39; + id);
            }
        }
    } else {
        //There is a plugin in play.
        prefix = id.substring(0, index);
        id = id.substring(index + 1, id.length);

        plugin = stringRequire(systemRequire, exports, module, prefix, relId);

        if (plugin.normalize) {
            id = plugin.normalize(id, makeNormalize(relId));
        } else {
            //Normalize the ID normally.
            id = normalize(id, relId);
        }

        if (loaderCache[id]) {
            return loaderCache[id];
        } else {
            plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

            return loaderCache[id];
        }
    }
};

//Create a define function specific to the module asking for amdefine.
function define(id, deps, factory) {
    if (Array.isArray(id)) {
        factory = deps;
        deps = id;
        id = undefined;
    } else if (typeof id !== &#39;string&#39;) {
        factory = id;
        id = deps = undefined;
    }

    if (deps &amp;&amp; !Array.isArray(deps)) {
        factory = deps;
        deps = undefined;
    }

    if (!deps) {
        deps = [&#39;require&#39;, &#39;exports&#39;, &#39;module&#39;];
    }

    //Set up properties for this module. If an ID, then use
    //internal cache. If no ID, then use the external variables
    //for this node module.
    if (id) {
        //Put the module in deep freeze until there is a
        //require call for it.
        defineCache[id] = [id, deps, factory];
    } else {
        runFactory(id, deps, factory);
    }
}

//define.require, which has access to all the values in the
//cache. Useful for AMD modules that all have IDs in the file,
//but need to finally export a value to node based on one of those
//IDs.
define.require = function (id) {
    if (loaderCache[id]) {
        return loaderCache[id];
    }

    if (defineCache[id]) {
        runFactory.apply(null, defineCache[id]);
        return loaderCache[id];
    }
};

define.amd = {};

return define;</pre>

<p>}</p>

<p>module.exports = amdefine;</p>

<p>}).call(this,<em>dereq</em>(&#39;_process&#39;),“/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js”)
},{“_process”:7,“path”:6}],20:[function(<em>dereq</em>,module,exports){ /**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>var docblockRe = /^s*(/**(.|r?n)*?*/)/; var ltrimRe = /^s*/; /**</p>

<pre> @param {String} contents
 @return {String}
/</pre>

<p>function extract(contents) {</p>

<pre>var match = contents.match(docblockRe);
if (match) {
  return match[0].replace(ltrimRe, &#39;&#39;) || &#39;&#39;;
}
return &#39;&#39;;</pre>

<p>}</p>

<p>var commentStartRe = /^/**?/; var commentEndRe = /*+/$/; var wsRe = /[t
]+/g; var stringStartRe = /(r?n|^) **/g; var multilineRe = /(?:^|r?n)
*(@[^rn]*?) *r?n *([^@<a href=“^@rn”>rns]</a>+?) *r?n/g; var propertyRe =
/(?:^|r?n) *@(S+) *([^rn]*)/g;</p>

<p>/**</p>

<pre> @param {String} contents
 @return {Array}
/</pre>

<p>function parse(docblock) {</p>

<pre>docblock = docblock
  .replace(commentStartRe, &#39;&#39;)
  .replace(commentEndRe, &#39;&#39;)
  .replace(wsRe, &#39; &#39;)
  .replace(stringStartRe, &#39;$1&#39;);

// Normalize multi-line directives
var prev = &#39;&#39;;
while (prev != docblock) {
  prev = docblock;
  docblock = docblock.replace(multilineRe, &quot;\n$1 $2\n&quot;);
}
docblock = docblock.trim();

var result = [];
var match;
while (match = propertyRe.exec(docblock)) {
  result.push([match[1], match[2]]);
}

return result;</pre>

<p>}</p>

<p>/**</p>

<pre> Same as parse but returns an object of prop: value instead of array of paris
 If a property appers more than once the last one will be returned

 @param {String} contents
 @return {Object}
/</pre>

<p>function parseAsObject(docblock) {</p>

<pre>var pairs = parse(docblock);
var result = {};
for (var i = 0; i &lt; pairs.length; i++) {
  result[pairs[i][0]] = pairs[i][1];
}
return result;</pre>

<p>}</p>

<p>exports.extract = extract; exports.parse = parse; exports.parseAsObject =
parseAsObject;</p>

<p>},{}],21:[function(<em>dereq</em>,module,exports){ /**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node: true*/ “use strict”;</p>

<p>var esprima = <em>dereq</em>(&#39;esprima-fb&#39;); var utils =
<em>dereq</em>(&#39;./utils&#39;);</p>

<p>var getBoundaryNode = utils.getBoundaryNode; var declareIdentInScope =
utils.declareIdentInLocalScope; var initScopeMetadata =
utils.initScopeMetadata; var Syntax = esprima.Syntax;</p>

<p>/**</p>

<pre> @param {object} node
 @param {object} parentNode
 @return {boolean}
/</pre>

<p>function _nodeIsClosureScopeBoundary(node, parentNode) {</p>

<pre>if (node.type === Syntax.Program) {
  return true;
}

var parentIsFunction =
  parentNode.type === Syntax.FunctionDeclaration
  || parentNode.type === Syntax.FunctionExpression
  || parentNode.type === Syntax.ArrowFunctionExpression;

return node.type === Syntax.BlockStatement &amp;&amp; parentIsFunction;</pre>

<p>}</p>

<p>function _nodeIsBlockScopeBoundary(node, parentNode) {</p>

<pre>if (node.type === Syntax.Program) {
  return false;
}

return node.type === Syntax.BlockStatement
       &amp;&amp; parentNode.type === Syntax.CatchClause;</pre>

<p>}</p>

<p>/**</p>

<pre> @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function traverse(node, path, state) {</p>

<pre>// Create a scope stack entry if this is the first node we&#39;ve encountered in
// its local scope
var parentNode = path[0];
if (!Array.isArray(node) &amp;&amp; state.localScope.parentNode !== parentNode) {
  if (_nodeIsClosureScopeBoundary(node, parentNode)) {
    var scopeIsStrict =
      state.scopeIsStrict
      || node.body.length &gt; 0
         &amp;&amp; node.body[0].type === Syntax.ExpressionStatement
         &amp;&amp; node.body[0].expression.type === Syntax.Literal
         &amp;&amp; node.body[0].expression.value === &#39;use strict&#39;;

    if (node.type === Syntax.Program) {
      state = utils.updateState(state, {
        scopeIsStrict: scopeIsStrict
      });
    } else {
      state = utils.updateState(state, {
        localScope: {
          parentNode: parentNode,
          parentScope: state.localScope,
          identifiers: {},
          tempVarIndex: 0
        },
        scopeIsStrict: scopeIsStrict
      });

      // All functions have an implicit &#39;arguments&#39; object in scope
      declareIdentInScope(&#39;arguments&#39;, initScopeMetadata(node), state);

      // Include function arg identifiers in the scope boundaries of the
      // function
      if (parentNode.params.length &gt; 0) {
        var param;
        for (var i = 0; i &lt; parentNode.params.length; i++) {
          param = parentNode.params[i];
          if (param.type === Syntax.Identifier) {
            declareIdentInScope(
              param.name, initScopeMetadata(parentNode), state
            );
          }
        }
      }

      // Named FunctionExpressions scope their name within the body block of
      // themselves only
      if (parentNode.type === Syntax.FunctionExpression &amp;&amp; parentNode.id) {
        var metaData =
          initScopeMetadata(parentNode, path.parentNodeslice, parentNode);
        declareIdentInScope(parentNode.id.name, metaData, state);
      }
    }

    // Traverse and find all local identifiers in this closure first to
    // account for function/variable declaration hoisting
    collectClosureIdentsAndTraverse(node, path, state);
  }

  if (_nodeIsBlockScopeBoundary(node, parentNode)) {
    state = utils.updateState(state, {
      localScope: {
        parentNode: parentNode,
        parentScope: state.localScope,
        identifiers: {}
      }
    });

    if (parentNode.type === Syntax.CatchClause) {
      declareIdentInScope(
        parentNode.param.name, initScopeMetadata(parentNode), state
      );
    }
    collectBlockIdentsAndTraverse(node, path, state);
  }
}

// Only catchup() before and after traversing a child node
function traverser(node, path, state) {
  node.range &amp;&amp; utils.catchup(node.range[0], state);
  traverse(node, path, state);
  node.range &amp;&amp; utils.catchup(node.range[1], state);
}

utils.analyzeAndTraverse(walker, traverser, node, path, state);</pre>

<p>}</p>

<p>function collectClosureIdentsAndTraverse(node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">analyzeAndTraverse</span>(
  <span class="ruby-identifier">visitLocalClosureIdentifiers</span>,
  <span class="ruby-identifier">collectClosureIdentsAndTraverse</span>,
  <span class="ruby-identifier">node</span>,
  <span class="ruby-identifier">path</span>,
  <span class="ruby-identifier">state</span>
);
</pre>

<p>}</p>

<p>function collectBlockIdentsAndTraverse(node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">analyzeAndTraverse</span>(
  <span class="ruby-identifier">visitLocalBlockIdentifiers</span>,
  <span class="ruby-identifier">collectBlockIdentsAndTraverse</span>,
  <span class="ruby-identifier">node</span>,
  <span class="ruby-identifier">path</span>,
  <span class="ruby-identifier">state</span>
);
</pre>

<p>}</p>

<p>function visitLocalClosureIdentifiers(node, path, state) {</p>

<pre>var metaData;
switch (node.type) {
  case Syntax.FunctionExpression:
    // Function expressions don&#39;t get their names (if there is one) added to
    // the closure scope they&#39;re defined in
    return false;
  case Syntax.ClassDeclaration:
  case Syntax.ClassExpression:
  case Syntax.FunctionDeclaration:
    if (node.id) {
      metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
      declareIdentInScope(node.id.name, metaData, state);
    }
    return false;
  case Syntax.VariableDeclarator:
    // Variables have function-local scope
    if (path[0].kind === &#39;var&#39;) {
      metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
      declareIdentInScope(node.id.name, metaData, state);
    }
    break;
}</pre>

<p>}</p>

<p>function visitLocalBlockIdentifiers(node, path, state) {</p>

<pre>// TODO: Support &#39;let&#39; here...maybe...one day...or something...
if (node.type === Syntax.CatchClause) {
  return false;
}</pre>

<p>}</p>

<p>function walker(node, path, state) {</p>

<pre>var visitors = state.g.visitors;
for (var i = 0; i &lt; visitors.length; i++) {
  if (visitors[i].test(node, path, state)) {
    return visitors[i](traverse, node, path, state);
  }
}</pre>

<p>}</p>

<p>var _astCache = {};</p>

<p>/**</p>

<pre> Applies all available transformations to the source
 @param {array} visitors
 @param {string} source
 @param {?object} options
 @return {object}
/</pre>

<p>function transform(visitors, source, options) {</p>

<pre>options = options || {};
var ast;
try {
  var cachedAst = _astCache[source];
  ast = cachedAst ||
    (_astCache[source] = esprima.parse(source, {
      comment: true,
      loc: true,
      range: true
    }));
  } catch (e) {
  e.message = &#39;Parse Error: &#39; + e.message;
  throw e;
}
var state = utils.createState(source, ast, options);
state.g.visitors = visitors;

if (options.sourceMap) {
  var SourceMapGenerator = _dereq_(&#39;source-map&#39;).SourceMapGenerator;
  state.g.sourceMap = new SourceMapGenerator({file: options.filename || &#39;transformed.js&#39;});
}

traverse(ast, [], state);
utils.catchup(source.length, state);

var ret = {code: state.g.buffer, extra: state.g.extra};
if (options.sourceMap) {
  ret.sourceMap = state.g.sourceMap;
  ret.sourceMapFilename =  options.filename || &#39;source.js&#39;;
}
return ret;</pre>

<p>}</p>

<p>exports.transform = transform; exports.Syntax = Syntax;</p>

<p>},{“./utils”:22,“esprima-fb”:9,“source-map”:10}],22:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node: true*/ var Syntax =
<em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var leadingIndentRegexp =
/(^|n)( {2}|t)/g; var nonWhiteRegexp = /(S)/g;</p>

<p>/**</p>

<pre> A `state` object represents the state of the parser. It has &quot;local&quot; and
 &quot;global&quot; parts. Global contains parser position, source, etc. Local contains
 scope based properties like current class name. State should contain all the
 info required for transformation. It&#39;s the only mandatory object that is
 being passed to every function in transform chain.

 @param  {string} source
 @param  {object} transformOptions
 @return {object}
/</pre>

<p>function createState(source, rootNode, transformOptions) {</p>

<pre>return {
  /**
     A tree representing the current local scope (and its lexical scope chain)
     Useful for tracking identifiers from parent scopes, etc.
     @type {Object}
    /
  localScope: {
    parentNode: rootNode,
    parentScope: null,
    identifiers: {},
    tempVarIndex: 0
  },
  /**
     The name (and, if applicable, expression) of the super class
     @type {Object}
    /
  superClass: null,
  /**
     The namespace to use when munging identifiers
     @type {String}
    /
  mungeNamespace: &#39;&#39;,
  /**
     Ref to the node for the current MethodDefinition
     @type {Object}
    /
  methodNode: null,
  /**
     Ref to the node for the FunctionExpression of the enclosing
     MethodDefinition
     @type {Object}
    /
  methodFuncNode: null,
  /**
     Name of the enclosing class
     @type {String}
    /
  className: null,
  /**
     Whether we&#39;re currently within a `strict` scope
     @type {Bool}
    /
  scopeIsStrict: null,
  /**
     Indentation offset
     @type {Number}
    /
  indentBy: 0,
  /**
     Global state (not affected by updateState)
     @type {Object}
    /
  g: {
    /**
       A set of general options that transformations can consider while doing
       a transformation:

       - minify
         Specifies that transformation steps should do their best to minify
         the output source when possible. This is useful for places where
         minification optimizations are possible with higher-level context
         info than what jsxmin can provide.

         For example, the ES6 class transform will minify munged private
         variables if this flag is set.
      /
    opts: transformOptions,
    /**
       Current position in the source code
       @type {Number}
      /
    position: 0,
    /**
       Auxiliary data to be returned by transforms
       @type {Object}
      /
    extra: {},
    /**
       Buffer containing the result
       @type {String}
      /
    buffer: &#39;&#39;,
    /**
       Source that is being transformed
       @type {String}
      /
    source: source,

    /**
       Cached parsed docblock (see getDocblock)
       @type {object}
      /
    docblock: null,

    /**
       Whether the thing was used
       @type {Boolean}
      /
    tagNamespaceUsed: false,

    /**
       If using bolt xjs transformation
       @type {Boolean}
      /
    isBolt: undefined,

    /**
       Whether to record source map (expensive) or not
       @type {SourceMapGenerator|null}
      /
    sourceMap: null,

    /**
       Filename of the file being processed. Will be returned as a source
       attribute in the source map
      /
    sourceMapFilename: &#39;source.js&#39;,

    /**
       Only when source map is used: last line in the source for which
       source map was generated
       @type {Number}
      /
    sourceLine: 1,

    /**
       Only when source map is used: last line in the buffer for which
       source map was generated
       @type {Number}
      /
    bufferLine: 1,

    /**
       The top-level Program AST for the original file.
      /
    originalProgramAST: null,

    sourceColumn: 0,
    bufferColumn: 0
  }
};</pre>

<p>}</p>

<p>/**</p>

<pre> Updates a copy of a given state with &quot;update&quot; and returns an updated state.

 @param  {object} state
 @param  {object} update
 @return {object}
/</pre>

<p>function updateState(state, update) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">ret</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">state</span>);
<span class="ruby-constant">Object</span>.<span class="ruby-identifier">keys</span>(<span class="ruby-identifier">update</span>).<span class="ruby-identifier">forEach</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">updatedKey</span>) {
  <span class="ruby-identifier">ret</span>[<span class="ruby-identifier">updatedKey</span>] = <span class="ruby-identifier">update</span>[<span class="ruby-identifier">updatedKey</span>];
});
<span class="ruby-keyword">return</span> <span class="ruby-identifier">ret</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> Given a state fill the resulting buffer from the original source up to
 the end

 @param {number} end
 @param {object} state
 @param {?function} contentTransformer Optional callback to transform newly
                                       added content.
/</pre>

<p>function catchup(end, state, contentTransformer) {</p>

<pre>if (end &lt; state.g.position) {
  // cannot move backwards
  return;
}
var source = state.g.source.substring(state.g.position, end);
var transformed = updateIndent(source, state);
if (state.g.sourceMap &amp;&amp; transformed) {
  // record where we are
  state.g.sourceMap.addMapping({
    generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
    original: { line: state.g.sourceLine, column: state.g.sourceColumn },
    source: state.g.sourceMapFilename
  });

  // record line breaks in transformed source
  var sourceLines = source.split(&#39;\n&#39;);
  var transformedLines = transformed.split(&#39;\n&#39;);
  // Add line break mappings between last known mapping and the end of the
  // added piece. So for the code piece
  //  (foo, bar);
  // &gt; var x = 2;
  // &gt; var b = 3;
  //   var c =
  // only add lines marked with &quot;&gt;&quot;: 2, 3.
  for (var i = 1; i &lt; sourceLines.length - 1; i++) {
    state.g.sourceMap.addMapping({
      generated: { line: state.g.bufferLine, column: 0 },
      original: { line: state.g.sourceLine, column: 0 },
      source: state.g.sourceMapFilename
    });
    state.g.sourceLine++;
    state.g.bufferLine++;
  }
  // offset for the last piece
  if (sourceLines.length &gt; 1) {
    state.g.sourceLine++;
    state.g.bufferLine++;
    state.g.sourceColumn = 0;
    state.g.bufferColumn = 0;
  }
  state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
  state.g.bufferColumn +=
    transformedLines[transformedLines.length - 1].length;
}
state.g.buffer +=
  contentTransformer ? contentTransformer(transformed) : transformed;
state.g.position = end;</pre>

<p>}</p>

<p>/**</p>

<pre> Returns original source for an AST node.
 @param {object} node
 @param {object} state
 @return {string}
/</pre>

<p>function getNodeSourceText(node, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">state</span>.<span class="ruby-identifier">g</span>.<span class="ruby-identifier">source</span>.<span class="ruby-identifier">substring</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>]);
</pre>

<p>}</p>

<p>function replaceNonWhite(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">nonWhiteRegexp</span>, <span class="ruby-string">&#39; &#39;</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> Removes all non-whitespace characters
/</pre>

<p>function stripNonWhite(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">nonWhiteRegexp</span>, <span class="ruby-string">&#39;&#39;</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> Catches up as `catchup` but replaces non-whitespace chars with spaces.
/</pre>

<p>function catchupWhiteOut(end, state) {</p>

<pre>catchup(end, state, replaceNonWhite);</pre>

<p>}</p>

<p>/**</p>

<pre> Catches up as `catchup` but removes all non-whitespace characters.
/</pre>

<p>function catchupWhiteSpace(end, state) {</p>

<pre>catchup(end, state, stripNonWhite);</pre>

<p>}</p>

<p>/**</p>

<pre> Removes all non-newline characters
/</pre>

<p>var reNonNewline = /[^n]/g; function stripNonNewline(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">reNonNewline</span>, <span class="ruby-identifier">function</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;&#39;</span>;
});
</pre>

<p>}</p>

<p>/**</p>

<pre> Catches up as `catchup` but removes all non-newline characters.

 Equivalent to appending as many newlines as there are in the original source
 between the current position and `end`.
/</pre>

<p>function catchupNewlines(end, state) {</p>

<pre>catchup(end, state, stripNonNewline);</pre>

<p>}</p>

<p>/**</p>

<pre> Same as catchup but does not touch the buffer

 @param  {number} end
 @param  {object} state
/</pre>

<p>function move(end, state) {</p>

<pre>// move the internal cursors
if (state.g.sourceMap) {
  if (end &lt; state.g.position) {
    state.g.position = 0;
    state.g.sourceLine = 1;
    state.g.sourceColumn = 0;
  }

  var source = state.g.source.substring(state.g.position, end);
  var sourceLines = source.split(&#39;\n&#39;);
  if (sourceLines.length &gt; 1) {
    state.g.sourceLine += sourceLines.length - 1;
    state.g.sourceColumn = 0;
  }
  state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
}
state.g.position = end;</pre>

<p>}</p>

<p>/**</p>

<pre> Appends a string of text to the buffer

 @param {string} str
 @param {object} state
/</pre>

<p>function append(str, state) {</p>

<pre>if (state.g.sourceMap &amp;&amp; str) {
  state.g.sourceMap.addMapping({
    generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
    original: { line: state.g.sourceLine, column: state.g.sourceColumn },
    source: state.g.sourceMapFilename
  });
  var transformedLines = str.split(&#39;\n&#39;);
  if (transformedLines.length &gt; 1) {
    state.g.bufferLine += transformedLines.length - 1;
    state.g.bufferColumn = 0;
  }
  state.g.bufferColumn +=
    transformedLines[transformedLines.length - 1].length;
}
state.g.buffer += str;</pre>

<p>}</p>

<p>/**</p>

<pre> Update indent using state.indentBy property. Indent is measured in
 double spaces. Updates a single line only.

 @param {string} str
 @param {object} state
 @return {string}
/</pre>

<p>function updateIndent(str, state) {</p>

<pre>var indentBy = state.indentBy;
if (indentBy &lt; 0) {
  for (var i = 0; i &lt; -indentBy; i++) {
    str = str.replace(leadingIndentRegexp, &#39;$1&#39;);
  }
} else {
  for (var i = 0; i &lt; indentBy; i++) {
    str = str.replace(leadingIndentRegexp, &#39;$1$2$2&#39;);
  }
}
return str;</pre>

<p>}</p>

<p>/**</p>

<pre> Calculates indent from the beginning of the line until &quot;start&quot; or the first
 character before start.
 @example
   &quot;  foo.bar()&quot;
         ^
       start
   indent will be &quot;  &quot;

 @param  {number} start
 @param  {object} state
 @return {string}
/</pre>

<p>function indentBefore(start, state) {</p>

<pre>var end = start;
start = start - 1;

while (start &gt; 0 &amp;&amp; state.g.source[start] != &#39;\n&#39;) {
  if (!state.g.source[start].match(/[ \t]/)) {
    end = start;
  }
  start--;
}
return state.g.source.substring(start + 1, end);</pre>

<p>}</p>

<p>function getDocblock(state) {</p>

<pre>if (!state.g.docblock) {
  var docblock = _dereq_(&#39;./docblock&#39;);
  state.g.docblock =
    docblock.parseAsObject(docblock.extract(state.g.source));
}
return state.g.docblock;</pre>

<p>}</p>

<p>function identWithinLexicalScope(identName, state, stopBeforeNode) {</p>

<pre>var currScope = state.localScope;
while (currScope) {
  if (currScope.identifiers[identName] !== undefined) {
    return true;
  }

  if (stopBeforeNode &amp;&amp; currScope.parentNode === stopBeforeNode) {
    break;
  }

  currScope = currScope.parentScope;
}
return false;</pre>

<p>}</p>

<p>function identInLocalScope(identName, state) {</p>

<pre>return state.localScope.identifiers[identName] !== undefined;</pre>

<p>}</p>

<p>/**</p>

<pre> @param {object} boundaryNode
 @param {?array} path
 @return {?object} node
/</pre>

<p>function initScopeMetadata(boundaryNode, path, node) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
  <span class="ruby-identifier">boundaryNode</span><span class="ruby-operator">:</span> <span class="ruby-identifier">boundaryNode</span>,
  <span class="ruby-identifier">bindingPath</span><span class="ruby-operator">:</span> <span class="ruby-identifier">path</span>,
  <span class="ruby-identifier">bindingNode</span><span class="ruby-operator">:</span> <span class="ruby-identifier">node</span>
};
</pre>

<p>}</p>

<p>function declareIdentInLocalScope(identName, metaData, state) {</p>

<pre class="ruby"><span class="ruby-identifier">state</span>.<span class="ruby-identifier">localScope</span>.<span class="ruby-identifier">identifiers</span>[<span class="ruby-identifier">identName</span>] = {
  <span class="ruby-identifier">boundaryNode</span><span class="ruby-operator">:</span> <span class="ruby-identifier">metaData</span>.<span class="ruby-identifier">boundaryNode</span>,
  <span class="ruby-identifier">path</span><span class="ruby-operator">:</span> <span class="ruby-identifier">metaData</span>.<span class="ruby-identifier">bindingPath</span>,
  <span class="ruby-identifier">node</span><span class="ruby-operator">:</span> <span class="ruby-identifier">metaData</span>.<span class="ruby-identifier">bindingNode</span>,
  <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">state</span>)
};
</pre>

<p>}</p>

<p>function getLexicalBindingMetadata(identName, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">state</span>.<span class="ruby-identifier">localScope</span>.<span class="ruby-identifier">identifiers</span>[<span class="ruby-identifier">identName</span>];
</pre>

<p>}</p>

<p>/**</p>

<pre> Apply the given analyzer function to the current node. If the analyzer
 doesn&#39;t return false, traverse each child of the current node using the given
 traverser function.

 @param {function} analyzer
 @param {function} traverser
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function analyzeAndTraverse(analyzer, traverser, node, path, state) {</p>

<pre>if (node.type) {
  if (analyzer(node, path, state) === false) {
    return;
  }
  path.unshift(node);
}

getOrderedChildren(node).forEach(function(child) {
  traverser(child, path, state);
});

node.type &amp;&amp; path.shift();</pre>

<p>}</p>

<p>/**</p>

<pre> It is crucial that we traverse in order, or else catchup() on a later
 node that is processed out of order can move the buffer past a node
 that we haven&#39;t handled yet, preventing us from modifying that node.

 This can happen when a node has multiple properties containing children.
 For example, XJSElement nodes have `openingElement`, `closingElement` and
 `children`. If we traverse `openingElement`, then `closingElement`, then
 when we get to `children`, the buffer has already caught up to the end of
 the closing element, after the children.

 This is basically a Schwartzian transform. Collects an array of children,
 each one represented as [child, startIndex]; sorts the array by start
 index; then traverses the children in that order.
/</pre>

<p>function getOrderedChildren(node) {</p>

<pre>var queue = [];
for (var key in node) {
  if (node.hasOwnProperty(key)) {
    enqueueNodeWithStartIndex(queue, node[key]);
  }
}
queue.sort(function(a, b) { return a[1] - b[1]; });
return queue.map(function(pair) { return pair[0]; });</pre>

<p>}</p>

<p>/**</p>

<pre> Helper function for analyzeAndTraverse which queues up all of the children
 of the given node.

 Children can also be found in arrays, so we basically want to merge all of
 those arrays together so we can sort them and then traverse the children
 in order.

 One example is the Program node. It contains `body` and `comments`, both
 arrays. Lexographically, comments are interspersed throughout the body
 nodes, but esprima&#39;s AST groups them together.
/</pre>

<p>function enqueueNodeWithStartIndex(queue, node) {</p>

<pre>if (typeof node !== &#39;object&#39; || node === null) {
  return;
}
if (node.range) {
  queue.push([node, node.range[0]]);
} else if (Array.isArray(node)) {
  for (var ii = 0; ii &lt; node.length; ii++) {
    enqueueNodeWithStartIndex(queue, node[ii]);
  }
}</pre>

<p>}</p>

<p>/**</p>

<pre> Checks whether a node or any of its sub-nodes contains
 a syntactic construct of the passed type.
 @param {object} node - AST node to test.
 @param {string} type - node type to lookup.
/</pre>

<p>function containsChildOfType(node, type) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">containsChildMatching</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">type</span>;
});
</pre>

<p>}</p>

<p>function containsChildMatching(node, matcher) {</p>

<pre>var foundMatchingChild = false;
function nodeTypeAnalyzer(node) {
  if (matcher(node) === true) {
    foundMatchingChild = true;
    return false;
  }
}
function nodeTypeTraverser(child, path, state) {
  if (!foundMatchingChild) {
    foundMatchingChild = containsChildMatching(child, matcher);
  }
}
analyzeAndTraverse(
  nodeTypeAnalyzer,
  nodeTypeTraverser,
  node,
  []
);
return foundMatchingChild;</pre>

<p>}</p>

<p>var scopeTypes = {}; <a href="Syntax.FunctionExpression">scopeTypes</a> =
true; <a href="Syntax.FunctionDeclaration">scopeTypes</a> = true; <a
href="Syntax.Program">scopeTypes</a> = true;</p>

<p>function getBoundaryNode(path) {</p>

<pre>for (var ii = 0; ii &lt; path.length; ++ii) {
  if (scopeTypes[path[ii].type]) {
    return path[ii];
  }
}
throw new Error(
  &#39;Expected to find a node with one of the following types in path:\n&#39; +
  JSON.stringify(Object.keys(scopeTypes))
);</pre>

<p>}</p>

<p>function getTempVar(tempVarIndex) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-string">&#39;$__&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">tempVarIndex</span>;
</pre>

<p>}</p>

<p>function getTempVarWithValue(tempVarIndex, tempVarValue) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">getTempVar</span>(<span class="ruby-identifier">tempVarIndex</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&#39;=&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">tempVarValue</span>;
</pre>

<p>}</p>

<p>exports.append = append; exports.catchup = catchup; exports.catchupWhiteOut
= catchupWhiteOut; exports.catchupWhiteSpace = catchupWhiteSpace;
exports.catchupNewlines = catchupNewlines; exports.containsChildMatching =
containsChildMatching; exports.containsChildOfType = containsChildOfType;
exports.createState = createState; exports.declareIdentInLocalScope =
declareIdentInLocalScope; exports.getBoundaryNode = getBoundaryNode;
exports.getDocblock = getDocblock; exports.getLexicalBindingMetadata =
getLexicalBindingMetadata; exports.initScopeMetadata = initScopeMetadata;
exports.identWithinLexicalScope = identWithinLexicalScope;
exports.identInLocalScope = identInLocalScope; exports.indentBefore =
indentBefore; exports.move = move; exports.scopeTypes = scopeTypes;
exports.updateIndent = updateIndent; exports.updateState = updateState;
exports.analyzeAndTraverse = analyzeAndTraverse; exports.getOrderedChildren
= getOrderedChildren; exports.getNodeSourceText = getNodeSourceText;
exports.getTempVar = getTempVar; exports.getTempVarWithValue =
getTempVarWithValue;</p>

<p>},{“./docblock”:20,“esprima-fb”:9}],23:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*global exports:true*/</p>

<p>/**</p>

<pre> Desugars ES6 Arrow functions to ES3 function expressions.
 If the function contains `this` expression -- automatically
 binds the function to current value of `this`.

 Single parameter, simple expression:

 [1, 2, 3].map(x =&gt; x * x);

 [1, 2, 3].map(function(x) { return x * x; });

 Several parameters, complex block:

 this.users.forEach((user, idx) =&gt; {
   return this.isActive(idx) &amp;&amp; this.send(user);
 });

 this.users.forEach(function(user, idx) {
   return this.isActive(idx) &amp;&amp; this.send(user);
 }.bind(this));

/</pre>

<p>var restParamVisitors =
<em>dereq</em>(&#39;./es6-rest-param-visitors&#39;); var
destructuringVisitors =
<em>dereq</em>(&#39;./es6-destructuring-visitors&#39;);</p>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>/**</p>

<pre> @public
/</pre>

<p>function visitArrowFunction(traverse, node, path, state) {</p>

<pre>var notInExpression = (path[0].type === Syntax.ExpressionStatement);

// Wrap a function into a grouping operator, if it&#39;s not
// in the expression position.
if (notInExpression) {
  utils.append(&#39;(&#39;, state);
}

utils.append(&#39;function&#39;, state);
renderParams(traverse, node, path, state);

// Skip arrow.
utils.catchupWhiteSpace(node.body.range[0], state);

var renderBody = node.body.type == Syntax.BlockStatement
  ? renderStatementBody
  : renderExpressionBody;

path.unshift(node);
renderBody(traverse, node, path, state);
path.shift();

// Bind the function only if `this` value is used
// inside it or inside any sub-expression.
var containsBindingSyntax =
  utils.containsChildMatching(node.body, function(node) {
    return node.type === Syntax.ThisExpression
           || (node.type === Syntax.Identifier
               &amp;&amp; node.name === &quot;super&quot;);
  });

if (containsBindingSyntax) {
  utils.append(&#39;.bind(this)&#39;, state);
}

utils.catchupWhiteSpace(node.range[1], state);

// Close wrapper if not in the expression.
if (notInExpression) {
  utils.append(&#39;)&#39;, state);
}

return false;</pre>

<p>}</p>

<p>function renderParams(traverse, node, path, state) {</p>

<pre>// To preserve inline typechecking directives, we
// distinguish between parens-free and paranthesized single param.
if (isParensFreeSingleParam(node, state) || !node.params.length) {
  utils.append(&#39;(&#39;, state);
}
if (node.params.length !== 0) {
  path.unshift(node);
  traverse(node.params, path, state);
  path.unshift();
}
utils.append(&#39;)&#39;, state);</pre>

<p>}</p>

<p>function isParensFreeSingleParam(node, state) {</p>

<pre>return node.params.length === 1 &amp;&amp;
  state.g.source[state.g.position] !== &#39;(&#39;;</pre>

<p>}</p>

<p>function renderExpressionBody(traverse, node, path, state) {</p>

<pre>// Wrap simple expression bodies into a block
// with explicit return statement.
utils.append(&#39;{&#39;, state);

// Special handling of rest param.
if (node.rest) {
  utils.append(
    restParamVisitors.renderRestParamSetup(node, state),
    state
  );
}

// Special handling of destructured params.
destructuringVisitors.renderDestructuredComponents(
  node,
  utils.updateState(state, {
    localScope: {
      parentNode: state.parentNode,
      parentScope: state.parentScope,
      identifiers: state.identifiers,
      tempVarIndex: 0
    }
  })
);

utils.append(&#39;return &#39;, state);
renderStatementBody(traverse, node, path, state);
utils.append(&#39;;}&#39;, state);</pre>

<p>}</p>

<p>function renderStatementBody(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">body</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
</pre>

<p>}</p>

<p>visitArrowFunction.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ArrowFunctionExpression</span>;
</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitArrowFunction</span>
</pre>

<p>];</p>

<p>},{“../src/utils”:22,“./es6-destructuring-visitors”:25,“./es6-rest-param-visitors”:28,“esprima-fb”:9}],24:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node:true*/</p>

<p>/**</p>

<pre> @typechecks
/</pre>

<p>&#39;use strict&#39;;</p>

<p>var base62 = <em>dereq</em>(&#39;base62&#39;); var Syntax =
<em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;); var reservedWordsHelper =
<em>dereq</em>(&#39;./reserved-words-helper&#39;);</p>

<p>var declareIdentInLocalScope = utils.declareIdentInLocalScope; var
initScopeMetadata = utils.initScopeMetadata;</p>

<p>var SUPER_PROTO_IDENT_PREFIX = &#39;____SuperProtoOf&#39;;</p>

<p>var _anonClassUUIDCounter = 0; var _mungedSymbolMaps = {};</p>

<p>function resetSymbols() {</p>

<pre class="ruby"><span class="ruby-identifier">_anonClassUUIDCounter</span> = <span class="ruby-value">0</span>;
<span class="ruby-identifier">_mungedSymbolMaps</span> = {};
</pre>

<p>}</p>

<p>/**</p>

<pre> Used to generate a unique class for use with code-gens for anonymous class
 expressions.

 @param {object} state
 @return {string}
/</pre>

<p>function _generateAnonymousClassName(state) {</p>

<pre>var mungeNamespace = state.mungeNamespace || &#39;&#39;;
return &#39;____Class&#39; + mungeNamespace + base62.encode(_anonClassUUIDCounter++);</pre>

<p>}</p>

<p>/**</p>

<pre> Given an identifier name, munge it using the current state&#39;s mungeNamespace.

 @param {string} identName
 @param {object} state
 @return {string}
/</pre>

<p>function _getMungedName(identName, state) {</p>

<pre>var mungeNamespace = state.mungeNamespace;
var shouldMinify = state.g.opts.minify;

if (shouldMinify) {
  if (!_mungedSymbolMaps[mungeNamespace]) {
    _mungedSymbolMaps[mungeNamespace] = {
      symbolMap: {},
      identUUIDCounter: 0
    };
  }

  var symbolMap = _mungedSymbolMaps[mungeNamespace].symbolMap;
  if (!symbolMap[identName]) {
    symbolMap[identName] =
      base62.encode(_mungedSymbolMaps[mungeNamespace].identUUIDCounter++);
  }
  identName = symbolMap[identName];
}
return &#39;$&#39; + mungeNamespace + identName;</pre>

<p>}</p>

<p>/**</p>

<pre> Extracts super class information from a class node.

 Information includes name of the super class and/or the expression string
 (if extending from an expression)

 @param {object} node
 @param {object} state
 @return {object}
/</pre>

<p>function _getSuperClassInfo(node, state) {</p>

<pre>var ret = {
  name: null,
  expression: null
};
if (node.superClass) {
  if (node.superClass.type === Syntax.Identifier) {
    ret.name = node.superClass.name;
  } else {
    // Extension from an expression
    ret.name = _generateAnonymousClassName(state);
    ret.expression = state.g.source.substring(
      node.superClass.range[0],
      node.superClass.range[1]
    );
  }
}
return ret;</pre>

<p>}</p>

<p>/**</p>

<pre> Used with .filter() to find the constructor method in a list of
 MethodDefinition nodes.

 @param {object} classElement
 @return {boolean}
/</pre>

<p>function _isConstructorMethod(classElement) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">classElement</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">MethodDefinition</span> <span class="ruby-operator">&amp;&amp;</span>
       <span class="ruby-identifier">classElement</span>.<span class="ruby-identifier">key</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">Identifier</span> <span class="ruby-operator">&amp;&amp;</span>
       <span class="ruby-identifier">classElement</span>.<span class="ruby-identifier">key</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;constructor&#39;</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> @param {object} node
 @param {object} state
 @return {boolean}
/</pre>

<p>function _shouldMungeIdentifier(node, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (
  <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">state</span>.<span class="ruby-identifier">methodFuncNode</span> <span class="ruby-operator">&amp;&amp;</span>
  <span class="ruby-operator">!</span><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">getDocblock</span>(<span class="ruby-identifier">state</span>).<span class="ruby-identifier">hasOwnProperty</span>(<span class="ruby-string">&#39;preventMunge&#39;</span>) <span class="ruby-operator">&amp;&amp;</span>
  <span class="ruby-regexp">/^_(?!_)/</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">name</span>)
);
</pre>

<p>}</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitClassMethod(traverse, node, path, state) {</p>

<pre>if (!state.g.opts.es5 &amp;&amp; (node.kind === &#39;get&#39; || node.kind === &#39;set&#39;)) {
  throw new Error(
    &#39;This transform does not support &#39; + node.kind + &#39;ter methods for ES6 &#39; +
    &#39;classes. (line: &#39; + node.loc.start.line + &#39;, col: &#39; +
    node.loc.start.column + &#39;)&#39;
  );
}
state = utils.updateState(state, {
  methodNode: node
});
utils.catchup(node.range[0], state);
path.unshift(node);
traverse(node.value, path, state);
path.shift();
return false;</pre>

<p>} visitClassMethod.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">MethodDefinition</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitClassFunctionExpression(traverse, node, path, state) {</p>

<pre>var methodNode = path[0];
var isGetter = methodNode.kind === &#39;get&#39;;
var isSetter = methodNode.kind === &#39;set&#39;;

state = utils.updateState(state, {
  methodFuncNode: node
});

if (methodNode.key.name === &#39;constructor&#39;) {
  utils.append(&#39;function &#39; + state.className, state);
} else {
  var methodAccessor;
  var prototypeOrStatic = methodNode[&quot;static&quot;] ? &#39;&#39; : &#39;.prototype&#39;;
  var objectAccessor = state.className + prototypeOrStatic;

  if (methodNode.key.type === Syntax.Identifier) {
    // foo() {}
    methodAccessor = methodNode.key.name;
    if (_shouldMungeIdentifier(methodNode.key, state)) {
      methodAccessor = _getMungedName(methodAccessor, state);
    }
    if (isGetter || isSetter) {
      methodAccessor = JSON.stringify(methodAccessor);
    } else if (reservedWordsHelper.isReservedWord(methodAccessor)) {
      methodAccessor = &#39;[&#39; + JSON.stringify(methodAccessor) + &#39;]&#39;;
    } else {
      methodAccessor = &#39;.&#39; + methodAccessor;
    }
  } else if (methodNode.key.type === Syntax.Literal) {
    // &#39;foo bar&#39;() {}  | get &#39;foo bar&#39;() {} | set &#39;foo bar&#39;() {}
    methodAccessor = JSON.stringify(methodNode.key.value);
    if (!(isGetter || isSetter)) {
      methodAccessor = &#39;[&#39; + methodAccessor + &#39;]&#39;;
    }
  }

  if (isSetter || isGetter) {
    utils.append(
      &#39;Object.defineProperty(&#39; +
        objectAccessor + &#39;,&#39; +
        methodAccessor + &#39;,&#39; +
        &#39;{enumerable:true,configurable:true,&#39; +
        methodNode.kind + &#39;:function&#39;,
      state
    );
  } else {
    utils.append(
      objectAccessor +
      methodAccessor + &#39;=function&#39; + (node.generator ? &#39;*&#39; : &#39;&#39;),
      state
    );
  }
}
utils.move(methodNode.key.range[1], state);
utils.append(&#39;(&#39;, state);

var params = node.params;
if (params.length &gt; 0) {
  utils.catchupNewlines(params[0].range[0], state);
  for (var i = 0; i &lt; params.length; i++) {
    utils.catchup(node.params[i].range[0], state);
    path.unshift(node);
    traverse(params[i], path, state);
    path.shift();
  }
}
utils.append(&#39;)&#39;, state);
utils.catchupWhiteSpace(node.body.range[0], state);
utils.append(&#39;{&#39;, state);
if (!state.scopeIsStrict) {
  utils.append(&#39;&quot;use strict&quot;;&#39;, state);
  state = utils.updateState(state, {
    scopeIsStrict: true
  });
}
utils.move(node.body.range[0] + &#39;{&#39;.length, state);

path.unshift(node);
traverse(node.body, path, state);
path.shift();
utils.catchup(node.body.range[1], state);

if (methodNode.key.name !== &#39;constructor&#39;) {
  if (isGetter || isSetter) {
    utils.append(&#39;})&#39;, state);
  }
  utils.append(&#39;;&#39;, state);
}
return false;</pre>

<p>} visitClassFunctionExpression.test = function(node, path, state) {</p>

<pre>return node.type === Syntax.FunctionExpression
       &amp;&amp; path[0].type === Syntax.MethodDefinition;</pre>

<p>};</p>

<p>function visitClassMethodParam(traverse, node, path, state) {</p>

<pre>var paramName = node.name;
if (_shouldMungeIdentifier(node, state)) {
  paramName = _getMungedName(node.name, state);
}
utils.append(paramName, state);
utils.move(node.range[1], state);</pre>

<p>} visitClassMethodParam.test = function(node, path, state) {</p>

<pre>if (!path[0] || !path[1]) {
  return;
}

var parentFuncExpr = path[0];
var parentClassMethod = path[1];

return parentFuncExpr.type === Syntax.FunctionExpression
       &amp;&amp; parentClassMethod.type === Syntax.MethodDefinition
       &amp;&amp; node.type === Syntax.Identifier;</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function _renderClassBody(traverse, node, path, state) {</p>

<pre>var className = state.className;
var superClass = state.superClass;

// Set up prototype of constructor on same line as `extends` for line-number
// preservation. This relies on function-hoisting if a constructor function is
// defined in the class body.
if (superClass.name) {
  // If the super class is an expression, we need to memoize the output of the
  // expression into the generated class name variable and use that to refer
  // to the super class going forward. Example:
  //
  //   class Foo extends mixin(Bar, Baz) {}
  //     --transforms to--
  //   function Foo() {} var ____Class0Blah = mixin(Bar, Baz);
  if (superClass.expression !== null) {
    utils.append(
      &#39;var &#39; + superClass.name + &#39;=&#39; + superClass.expression + &#39;;&#39;,
      state
    );
  }

  var keyName = superClass.name + &#39;____Key&#39;;
  var keyNameDeclarator = &#39;&#39;;
  if (!utils.identWithinLexicalScope(keyName, state)) {
    keyNameDeclarator = &#39;var &#39;;
    declareIdentInLocalScope(keyName, initScopeMetadata(node), state);
  }
  utils.append(
    &#39;for(&#39; + keyNameDeclarator + keyName + &#39; in &#39; + superClass.name + &#39;){&#39; +
      &#39;if(&#39; + superClass.name + &#39;.hasOwnProperty(&#39; + keyName + &#39;)){&#39; +
        className + &#39;[&#39; + keyName + &#39;]=&#39; +
          superClass.name + &#39;[&#39; + keyName + &#39;];&#39; +
      &#39;}&#39; +
    &#39;}&#39;,
    state
  );

  var superProtoIdentStr = SUPER_PROTO_IDENT_PREFIX + superClass.name;
  if (!utils.identWithinLexicalScope(superProtoIdentStr, state)) {
    utils.append(
      &#39;var &#39; + superProtoIdentStr + &#39;=&#39; + superClass.name + &#39;===null?&#39; +
      &#39;null:&#39; + superClass.name + &#39;.prototype;&#39;,
      state
    );
    declareIdentInLocalScope(superProtoIdentStr, initScopeMetadata(node), state);
  }

  utils.append(
    className + &#39;.prototype=Object.create(&#39; + superProtoIdentStr + &#39;);&#39;,
    state
  );
  utils.append(
    className + &#39;.prototype.constructor=&#39; + className + &#39;;&#39;,
    state
  );
  utils.append(
    className + &#39;.__superConstructor__=&#39; + superClass.name + &#39;;&#39;,
    state
  );
}

// If there&#39;s no constructor method specified in the class body, create an
// empty constructor function at the top (same line as the class keyword)
if (!node.body.body.filter(_isConstructorMethod).pop()) {
  utils.append(&#39;function &#39; + className + &#39;(){&#39;, state);
  if (!state.scopeIsStrict) {
    utils.append(&#39;&quot;use strict&quot;;&#39;, state);
  }
  if (superClass.name) {
    utils.append(
      &#39;if(&#39; + superClass.name + &#39;!==null){&#39; +
      superClass.name + &#39;.apply(this,arguments);}&#39;,
      state
    );
  }
  utils.append(&#39;}&#39;, state);
}

utils.move(node.body.range[0] + &#39;{&#39;.length, state);
traverse(node.body, path, state);
utils.catchupWhiteSpace(node.range[1], state);</pre>

<p>}</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitClassDeclaration(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">className</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">name</span>;
<span class="ruby-identifier">var</span> <span class="ruby-identifier">superClass</span> = <span class="ruby-identifier">_getSuperClassInfo</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">state</span> = <span class="ruby-identifier">utils</span>.<span class="ruby-identifier">updateState</span>(<span class="ruby-identifier">state</span>, {
  <span class="ruby-identifier">mungeNamespace</span><span class="ruby-operator">:</span> <span class="ruby-identifier">className</span>,
  <span class="ruby-identifier">className</span><span class="ruby-operator">:</span> <span class="ruby-identifier">className</span>,
  <span class="ruby-identifier">superClass</span><span class="ruby-operator">:</span> <span class="ruby-identifier">superClass</span>
});

<span class="ruby-identifier">_renderClassBody</span>(<span class="ruby-identifier">traverse</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitClassDeclaration.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ClassDeclaration</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitClassExpression(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">className</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">_generateAnonymousClassName</span>(<span class="ruby-identifier">state</span>);
<span class="ruby-identifier">var</span> <span class="ruby-identifier">superClass</span> = <span class="ruby-identifier">_getSuperClassInfo</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-string">&#39;(function(){&#39;</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">state</span> = <span class="ruby-identifier">utils</span>.<span class="ruby-identifier">updateState</span>(<span class="ruby-identifier">state</span>, {
  <span class="ruby-identifier">mungeNamespace</span><span class="ruby-operator">:</span> <span class="ruby-identifier">className</span>,
  <span class="ruby-identifier">className</span><span class="ruby-operator">:</span> <span class="ruby-identifier">className</span>,
  <span class="ruby-identifier">superClass</span><span class="ruby-operator">:</span> <span class="ruby-identifier">superClass</span>
});

<span class="ruby-identifier">_renderClassBody</span>(<span class="ruby-identifier">traverse</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-string">&#39;return &#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">className</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;;})()&#39;</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitClassExpression.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ClassExpression</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitPrivateIdentifier(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-identifier">_getMungedName</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">state</span>), <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">move</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
</pre>

<p>} visitPrivateIdentifier.test = function(node, path, state) {</p>

<pre>if (node.type === Syntax.Identifier &amp;&amp; _shouldMungeIdentifier(node, state)) {
  // Always munge non-computed properties of MemberExpressions
  // (a la preventing access of properties of unowned objects)
  if (path[0].type === Syntax.MemberExpression &amp;&amp; path[0].object !== node
      &amp;&amp; path[0].computed === false) {
    return true;
  }

  // Always munge identifiers that were declared within the method function
  // scope
  if (utils.identWithinLexicalScope(node.name, state, state.methodFuncNode)) {
    return true;
  }

  // Always munge private keys on object literals defined within a method&#39;s
  // scope.
  if (path[0].type === Syntax.Property
      &amp;&amp; path[1].type === Syntax.ObjectExpression) {
    return true;
  }

  // Always munge function parameters
  if (path[0].type === Syntax.FunctionExpression
      || path[0].type === Syntax.FunctionDeclaration
      || path[0].type === Syntax.ArrowFunctionExpression) {
    for (var i = 0; i &lt; path[0].params.length; i++) {
      if (path[0].params[i] === node) {
        return true;
      }
    }
  }
}
return false;</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitSuperCallExpression(traverse, node, path, state) {</p>

<pre>var superClassName = state.superClass.name;

if (node.callee.type === Syntax.Identifier) {
  if (_isConstructorMethod(state.methodNode)) {
    utils.append(superClassName + &#39;.call(&#39;, state);
  } else {
    var protoProp = SUPER_PROTO_IDENT_PREFIX + superClassName;
    if (state.methodNode.key.type === Syntax.Identifier) {
      protoProp += &#39;.&#39; + state.methodNode.key.name;
    } else if (state.methodNode.key.type === Syntax.Literal) {
      protoProp += &#39;[&#39; + JSON.stringify(state.methodNode.key.value) + &#39;]&#39;;
    }
    utils.append(protoProp + &quot;.call(&quot;, state);
  }
  utils.move(node.callee.range[1], state);
} else if (node.callee.type === Syntax.MemberExpression) {
  utils.append(SUPER_PROTO_IDENT_PREFIX + superClassName, state);
  utils.move(node.callee.object.range[1], state);

  if (node.callee.computed) {
    // [&quot;a&quot; + &quot;b&quot;]
    utils.catchup(node.callee.property.range[1] + &#39;]&#39;.length, state);
  } else {
    // .ab
    utils.append(&#39;.&#39; + node.callee.property.name, state);
  }

  utils.append(&#39;.call(&#39;, state);
  utils.move(node.callee.range[1], state);
}

utils.append(&#39;this&#39;, state);
if (node.arguments.length &gt; 0) {
  utils.append(&#39;,&#39;, state);
  utils.catchupWhiteSpace(node.arguments[0].range[0], state);
  traverse(node.arguments, path, state);
}

utils.catchupWhiteSpace(node.range[1], state);
utils.append(&#39;)&#39;, state);
return false;</pre>

<p>} visitSuperCallExpression.test = function(node, path, state) {</p>

<pre>if (state.superClass &amp;&amp; node.type === Syntax.CallExpression) {
  var callee = node.callee;
  if (callee.type === Syntax.Identifier &amp;&amp; callee.name === &#39;super&#39;
      || callee.type == Syntax.MemberExpression
         &amp;&amp; callee.object.name === &#39;super&#39;) {
    return true;
  }
}
return false;</pre>

<p>};</p>

<p>/**</p>

<pre> @param {function} traverse
 @param {object} node
 @param {array} path
 @param {object} state
/</pre>

<p>function visitSuperMemberExpression(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">superClassName</span> = <span class="ruby-identifier">state</span>.<span class="ruby-identifier">superClass</span>.<span class="ruby-identifier">name</span>;

<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-constant">SUPER_PROTO_IDENT_PREFIX</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">superClassName</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">move</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">object</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
</pre>

<p>} visitSuperMemberExpression.test = function(node, path, state) {</p>

<pre>return state.superClass
       &amp;&amp; node.type === Syntax.MemberExpression
       &amp;&amp; node.object.type === Syntax.Identifier
       &amp;&amp; node.object.name === &#39;super&#39;;</pre>

<p>};</p>

<p>exports.resetSymbols = resetSymbols;</p>

<p>exports.visitorList = [</p>

<pre>visitClassDeclaration,
visitClassExpression,
visitClassFunctionExpression,
visitClassMethod,
visitClassMethodParam,
visitPrivateIdentifier,
visitSuperCallExpression,
visitSuperMemberExpression</pre>

<p>];</p>

<p>},{“../src/utils”:22,“./reserved-words-helper”:32,“base62”:8,“esprima-fb”:9}],25:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2014 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*global exports:true*/</p>

<p>/**</p>

<pre> Implements ES6 destructuring assignment and pattern matchng.

 function init({port, ip, coords: [x, y]}) {
   return (x &amp;&amp; y) ? {id, port} : {ip};
 };

 function init($__0) {
   var
    port = $__0.port,
    ip = $__0.ip,
    $__1 = $__0.coords,
    x = $__1[0],
    y = $__1[1];
   return (x &amp;&amp; y) ? {id, port} : {ip};
 }

 var x, {ip, port} = init({ip, port});

 var x, $__0 = init({ip, port}), ip = $__0.ip, port = $__0.port;

/</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>var reservedWordsHelper =
<em>dereq</em>(&#39;./reserved-words-helper&#39;); var restParamVisitors =
<em>dereq</em>(&#39;./es6-rest-param-visitors&#39;); var
restPropertyHelpers =
<em>dereq</em>(&#39;./es7-rest-property-helpers&#39;);</p>

<p>// ——————————————————- // 1. Structured variable declarations. // // var
[a, b] = [b, a]; // var {x, y} = {y, x}; // ——————————————————-</p>

<p>function visitStructuredVariable(traverse, node, path, state) {</p>

<pre>// Allocate new temp for the pattern.
utils.append(utils.getTempVar(state.localScope.tempVarIndex) + &#39;=&#39;, state);
// Skip the pattern and assign the init to the temp.
utils.catchupWhiteSpace(node.init.range[0], state);
traverse(node.init, path, state);
utils.catchup(node.init.range[1], state);
// Render the destructured data.
utils.append(&#39;,&#39; + getDestructuredComponents(node.id, state), state);
state.localScope.tempVarIndex++;
return false;</pre>

<p>}</p>

<p>visitStructuredVariable.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">VariableDeclarator</span> <span class="ruby-operator">&amp;&amp;</span>
  <span class="ruby-identifier">isStructuredPattern</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">id</span>);
</pre>

<p>};</p>

<p>function isStructuredPattern(node) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ObjectPattern</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ArrayPattern</span>;
</pre>

<p>}</p>

<p>// Main function which does actual recursive destructuring // of nested
complex structures. function getDestructuredComponents(node, state) {</p>

<pre>var tmpIndex = state.localScope.tempVarIndex;
var components = [];
var patternItems = getPatternItems(node);

for (var idx = 0; idx &lt; patternItems.length; idx++) {
  var item = patternItems[idx];
  if (!item) {
    continue;
  }

  if (item.type === Syntax.SpreadElement) {
    // Spread/rest of an array.
    // TODO(dmitrys): support spread in the middle of a pattern
    // and also for function param patterns: [x, ...xs, y]
    components.push(item.argument.name +
      &#39;=Array.prototype.slice.call(&#39; +
      utils.getTempVar(tmpIndex) + &#39;,&#39; + idx + &#39;)&#39;
    );
    continue;
  }

  if (item.type === Syntax.SpreadProperty) {
    var restExpression = restPropertyHelpers.renderRestExpression(
      utils.getTempVar(tmpIndex),
      patternItems
    );
    components.push(item.argument.name + &#39;=&#39; + restExpression);
    continue;
  }

  // Depending on pattern type (Array or Object), we get
  // corresponding pattern item parts.
  var accessor = getPatternItemAccessor(node, item, tmpIndex, idx);
  var value = getPatternItemValue(node, item);

  // TODO(dmitrys): implement default values: {x, y=5}
  if (value.type === Syntax.Identifier) {
    // Simple pattern item.
    components.push(value.name + &#39;=&#39; + accessor);
  } else {
    // Complex sub-structure.
    components.push(
      utils.getTempVarWithValue(++state.localScope.tempVarIndex, accessor) +
      &#39;,&#39; + getDestructuredComponents(value, state)
    );
  }
}

return components.join(&#39;,&#39;);</pre>

<p>}</p>

<p>function getPatternItems(node) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">properties</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">elements</span>;
</pre>

<p>}</p>

<p>function getPatternItemAccessor(node, patternItem, tmpIndex, idx) {</p>

<pre>var tmpName = utils.getTempVar(tmpIndex);
if (node.type === Syntax.ObjectPattern) {
  if (reservedWordsHelper.isReservedWord(patternItem.key.name)) {
    return tmpName + &#39;[&quot;&#39; + patternItem.key.name + &#39;&quot;]&#39;;
  } else if (patternItem.key.type === Syntax.Literal) {
    return tmpName + &#39;[&#39; + JSON.stringify(patternItem.key.value) + &#39;]&#39;;
  } else if (patternItem.key.type === Syntax.Identifier) {
    return tmpName + &#39;.&#39; + patternItem.key.name;
  }
} else if (node.type === Syntax.ArrayPattern) {
  return tmpName + &#39;[&#39; + idx + &#39;]&#39;;
}</pre>

<p>}</p>

<p>function getPatternItemValue(node, patternItem) {</p>

<pre>return node.type === Syntax.ObjectPattern
  ? patternItem.value
  : patternItem;</pre>

<p>}</p>

<p>// ——————————————————- // 2. Assignment expression. // // [a, b] = [b, a];
// ({x, y} = {y, x}); // ——————————————————-</p>

<p>function visitStructuredAssignment(traverse, node, path, state) {</p>

<pre>var exprNode = node.expression;
utils.append(&#39;var &#39; + utils.getTempVar(state.localScope.tempVarIndex) + &#39;=&#39;, state);

utils.catchupWhiteSpace(exprNode.right.range[0], state);
traverse(exprNode.right, path, state);
utils.catchup(exprNode.right.range[1], state);

utils.append(
  &#39;;&#39; + getDestructuredComponents(exprNode.left, state) + &#39;;&#39;,
  state
);

utils.catchupWhiteSpace(node.range[1], state);
state.localScope.tempVarIndex++;
return false;</pre>

<p>}</p>

<p>visitStructuredAssignment.test = function(node, path, state) {</p>

<pre>// We consider the expression statement rather than just assignment
// expression to cover case with object patters which should be
// wrapped in grouping operator: ({x, y} = {y, x});
return node.type === Syntax.ExpressionStatement &amp;&amp;
  node.expression.type === Syntax.AssignmentExpression &amp;&amp;
  isStructuredPattern(node.expression.left);</pre>

<p>};</p>

<p>// ——————————————————- // 3. Structured parameter. // // function foo({x,
y}) { … } // ——————————————————-</p>

<p>function visitStructuredParameter(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">getTempVar</span>(<span class="ruby-identifier">getParamIndex</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">path</span>)), <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteSpace</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
</pre>

<p>}</p>

<p>function getParamIndex(paramNode, path) {</p>

<pre>var funcNode = path[0];
var tmpIndex = 0;
for (var k = 0; k &lt; funcNode.params.length; k++) {
  var param = funcNode.params[k];
  if (param === paramNode) {
    break;
  }
  if (isStructuredPattern(param)) {
    tmpIndex++;
  }
}
return tmpIndex;</pre>

<p>}</p>

<p>visitStructuredParameter.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">isStructuredPattern</span>(<span class="ruby-identifier">node</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">isFunctionNode</span>(<span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>]);
</pre>

<p>};</p>

<p>function isFunctionNode(node) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">FunctionDeclaration</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">FunctionExpression</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">MethodDefinition</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ArrowFunctionExpression</span>);
</pre>

<p>}</p>

<p>// ——————————————————- // 4. Function body for structured parameters. // //
function foo({x, y}) { x; y; } // ——————————————————-</p>

<p>function visitFunctionBodyForStructuredParameter(traverse, node, path,
state) {</p>

<pre>var funcNode = path[0];

utils.catchup(funcNode.body.range[0] + 1, state);
renderDestructuredComponents(funcNode, state);

if (funcNode.rest) {
  utils.append(
    restParamVisitors.renderRestParamSetup(funcNode, state),
    state
  );
}

return true;</pre>

<p>}</p>

<p>function renderDestructuredComponents(funcNode, state) {</p>

<pre>var destructuredComponents = [];

for (var k = 0; k &lt; funcNode.params.length; k++) {
  var param = funcNode.params[k];
  if (isStructuredPattern(param)) {
    destructuredComponents.push(
      getDestructuredComponents(param, state)
    );
    state.localScope.tempVarIndex++;
  }
}

if (destructuredComponents.length) {
  utils.append(&#39;var &#39; + destructuredComponents.join(&#39;,&#39;) + &#39;;&#39;, state);
}</pre>

<p>}</p>

<p>visitFunctionBodyForStructuredParameter.test = function(node, path, state)
{</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">BlockStatement</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">isFunctionNode</span>(<span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>]);
</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre>visitStructuredVariable,
visitStructuredAssignment,
visitStructuredParameter,
visitFunctionBodyForStructuredParameter</pre>

<p>];</p>

<p>exports.renderDestructuredComponents = renderDestructuredComponents;</p>

<p>},{“../src/utils”:22,“./es6-rest-param-visitors”:28,“./es7-rest-property-helpers”:30,“./reserved-words-helper”:32,“esprima-fb”:9}],26:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node:true*/</p>

<p>/**</p>

<pre> Desugars concise methods of objects to function expressions.

 var foo = {
   method(x, y) { ... }
 };

 var foo = {
   method: function(x, y) { ... }
 };

/</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;); var reservedWordsHelper =
<em>dereq</em>(&#39;./reserved-words-helper&#39;);</p>

<p>function visitObjectConciseMethod(traverse, node, path, state) {</p>

<pre>var isGenerator = node.value.generator;
if (isGenerator) {
  utils.catchupWhiteSpace(node.range[0] + 1, state);
}
if (node.computed) { // [&lt;expr&gt;]() { ...}
  utils.catchup(node.key.range[1] + 1, state);
} else if (reservedWordsHelper.isReservedWord(node.key.name)) {
  utils.catchup(node.key.range[0], state);
  utils.append(&#39;&quot;&#39;, state);
  utils.catchup(node.key.range[1], state);
  utils.append(&#39;&quot;&#39;, state);
}

utils.catchup(node.key.range[1], state);
utils.append(
  &#39;:function&#39; + (isGenerator ? &#39;*&#39; : &#39;&#39;),
  state
);
path.unshift(node);
traverse(node.value, path, state);
path.shift();
return false;</pre>

<p>}</p>

<p>visitObjectConciseMethod.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">Property</span> <span class="ruby-operator">&amp;&amp;</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">FunctionExpression</span> <span class="ruby-operator">&amp;&amp;</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">method</span> <span class="ruby-operator">===</span> <span class="ruby-keyword">true</span>;
</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitObjectConciseMethod</span>
</pre>

<p>];</p>

<p>},{“../src/utils”:22,“./reserved-words-helper”:32,“esprima-fb”:9}],27:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node: true*/</p>

<p>/**</p>

<pre> Desugars ES6 Object Literal short notations into ES3 full notation.

 // Easier return values.
 function foo(x, y) {
   return {x, y}; // {x: x, y: y}
 };

 // Destructuring.
 function init({port, ip, coords: {x, y}}) { ... }

/</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>/**</p>

<pre> @public
/</pre>

<p>function visitObjectLiteralShortNotation(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-string">&#39;:&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>}</p>

<p>visitObjectLiteralShortNotation.test = function(node, path, state) {</p>

<pre>return node.type === Syntax.Property &amp;&amp;
  node.kind === &#39;init&#39; &amp;&amp;
  node.shorthand === true &amp;&amp;
  path[0].type !== Syntax.ObjectPattern;</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitObjectLiteralShortNotation</span>
</pre>

<p>];</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],28:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node:true*/</p>

<p>/**</p>

<pre> Desugars ES6 rest parameters into an ES3 arguments array.

 function printf(template, ...args) {
   args.forEach(...);
 }

 We could use `Array.prototype.slice.call`, but that usage of arguments causes
 functions to be deoptimized in V8, so instead we use a for-loop.

 function printf(template) {
   for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 &lt; $__1; $__0++)
     args.push(arguments[$__0]);
   args.forEach(...);
 }

/</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>function _nodeIsFunctionWithRestParam(node) {</p>

<pre>return (node.type === Syntax.FunctionDeclaration
        || node.type === Syntax.FunctionExpression
        || node.type === Syntax.ArrowFunctionExpression)
       &amp;&amp; node.rest;</pre>

<p>}</p>

<p>function visitFunctionParamsWithRestParam(traverse, node, path, state) {</p>

<pre>if (node.parametricType) {
  utils.catchup(node.parametricType.range[0], state);
  path.unshift(node);
  traverse(node.parametricType, path, state);
  path.shift();
}

// Render params.
if (node.params.length) {
  path.unshift(node);
  traverse(node.params, path, state);
  path.shift();
} else {
  // -3 is for ... of the rest.
  utils.catchup(node.rest.range[0] - 3, state);
}
utils.catchupWhiteSpace(node.rest.range[1], state);

path.unshift(node);
traverse(node.body, path, state);
path.shift();

return false;</pre>

<p>}</p>

<p>visitFunctionParamsWithRestParam.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">_nodeIsFunctionWithRestParam</span>(<span class="ruby-identifier">node</span>);
</pre>

<p>};</p>

<p>function renderRestParamSetup(functionNode, state) {</p>

<pre>var idx = state.localScope.tempVarIndex++;
var len = state.localScope.tempVarIndex++;

return &#39;for (var &#39; + functionNode.rest.name + &#39;=[],&#39; +
  utils.getTempVarWithValue(idx, functionNode.params.length) + &#39;,&#39; +
  utils.getTempVarWithValue(len, &#39;arguments.length&#39;) + &#39;;&#39; +
  utils.getTempVar(idx) + &#39;&lt;&#39; +  utils.getTempVar(len) + &#39;;&#39; +
  utils.getTempVar(idx) + &#39;++) &#39; +
  functionNode.rest.name + &#39;.push(arguments[&#39; + utils.getTempVar(idx) + &#39;]);&#39;;</pre>

<p>}</p>

<p>function visitFunctionBodyWithRestParam(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">var</span> <span class="ruby-identifier">parentNode</span> = <span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>];
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">append</span>(<span class="ruby-identifier">renderRestParamSetup</span>(<span class="ruby-identifier">parentNode</span>, <span class="ruby-identifier">state</span>), <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
</pre>

<p>}</p>

<p>visitFunctionBodyWithRestParam.test = function(node, path, state) {</p>

<pre>return node.type === Syntax.BlockStatement
       &amp;&amp; _nodeIsFunctionWithRestParam(path[0]);</pre>

<p>};</p>

<p>exports.renderRestParamSetup = renderRestParamSetup; exports.visitorList =
[</p>

<pre>visitFunctionParamsWithRestParam,
visitFunctionBodyWithRestParam</pre>

<p>];</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],29:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node:true*/</p>

<p>/**</p>

<pre> @typechecks
/</pre>

<p>&#39;use strict&#39;;</p>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>/**</p>

<pre> http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.1.9
/</pre>

<p>function visitTemplateLiteral(traverse, node, path, state) {</p>

<pre>var templateElements = node.quasis;

utils.append(&#39;(&#39;, state);
for (var ii = 0; ii &lt; templateElements.length; ii++) {
  var templateElement = templateElements[ii];
  if (templateElement.value.raw !== &#39;&#39;) {
    utils.append(getCookedValue(templateElement), state);
    if (!templateElement.tail) {
      // + between element and substitution
      utils.append(&#39; + &#39;, state);
    }
    // maintain line numbers
    utils.move(templateElement.range[0], state);
    utils.catchupNewlines(templateElement.range[1], state);
  } else {  // templateElement.value.raw === &#39;&#39;
    // Concatenat adjacent substitutions, e.g. `${x}${y}`. Empty templates
    // appear before the first and after the last element - nothing to add in
    // those cases.
    if (ii &gt; 0 &amp;&amp; !templateElement.tail) {
      // + between substitution and substitution
      utils.append(&#39; + &#39;, state);
    }
  }

  utils.move(templateElement.range[1], state);
  if (!templateElement.tail) {
    var substitution = node.expressions[ii];
    if (substitution.type === Syntax.Identifier ||
        substitution.type === Syntax.MemberExpression ||
        substitution.type === Syntax.CallExpression) {
      utils.catchup(substitution.range[1], state);
    } else {
      utils.append(&#39;(&#39;, state);
      traverse(substitution, path, state);
      utils.catchup(substitution.range[1], state);
      utils.append(&#39;)&#39;, state);
    }
    // if next templateElement isn&#39;t empty...
    if (templateElements[ii + 1].value.cooked !== &#39;&#39;) {
      utils.append(&#39; + &#39;, state);
    }
  }
}
utils.move(node.range[1], state);
utils.append(&#39;)&#39;, state);
return false;</pre>

<p>}</p>

<p>visitTemplateLiteral.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">TemplateLiteral</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.2.6
/</pre>

<p>function visitTaggedTemplateExpression(traverse, node, path, state) {</p>

<pre>var template = node.quasi;
var numQuasis = template.quasis.length;

// print the tag
utils.move(node.tag.range[0], state);
traverse(node.tag, path, state);
utils.catchup(node.tag.range[1], state);

// print array of template elements
utils.append(&#39;(function() { var siteObj = [&#39;, state);
for (var ii = 0; ii &lt; numQuasis; ii++) {
  utils.append(getCookedValue(template.quasis[ii]), state);
  if (ii !== numQuasis - 1) {
    utils.append(&#39;, &#39;, state);
  }
}
utils.append(&#39;]; siteObj.raw = [&#39;, state);
for (ii = 0; ii &lt; numQuasis; ii++) {
  utils.append(getRawValue(template.quasis[ii]), state);
  if (ii !== numQuasis - 1) {
    utils.append(&#39;, &#39;, state);
  }
}
utils.append(
  &#39;]; Object.freeze(siteObj.raw); Object.freeze(siteObj); return siteObj; }()&#39;,
  state
);

// print substitutions
if (numQuasis &gt; 1) {
  for (ii = 0; ii &lt; template.expressions.length; ii++) {
    var expression = template.expressions[ii];
    utils.append(&#39;, &#39;, state);

    // maintain line numbers by calling catchupWhiteSpace over the whole
    // previous TemplateElement
    utils.move(template.quasis[ii].range[0], state);
    utils.catchupNewlines(template.quasis[ii].range[1], state);

    utils.move(expression.range[0], state);
    traverse(expression, path, state);
    utils.catchup(expression.range[1], state);
  }
}

// print blank lines to push the closing ) down to account for the final
// TemplateElement.
utils.catchupNewlines(node.range[1], state);

utils.append(&#39;)&#39;, state);

return false;</pre>

<p>}</p>

<p>visitTaggedTemplateExpression.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">TaggedTemplateExpression</span>;
</pre>

<p>};</p>

<p>function getCookedValue(templateElement) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">stringify</span>(<span class="ruby-identifier">templateElement</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">cooked</span>);
</pre>

<p>}</p>

<p>function getRawValue(templateElement) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">stringify</span>(<span class="ruby-identifier">templateElement</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">raw</span>);
</pre>

<p>}</p>

<p>exports.visitorList = [</p>

<pre>visitTemplateLiteral,
visitTaggedTemplateExpression</pre>

<p>];</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],30:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>/*jslint node:true*/</p>

<p>/**</p>

<pre class="ruby"> <span class="ruby-constant">Desugars</span> <span class="ruby-constant">ES7</span> <span class="ruby-identifier">rest</span> <span class="ruby-identifier">properties</span> <span class="ruby-identifier">into</span> <span class="ruby-constant">ES5</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">iteration</span>.
<span class="ruby-operator">/</span>
</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>// TODO: This is a pretty massive helper, it should only be defined once,
in the // transform&#39;s runtime environment. We don&#39;t currently have
a runtime though. var restFunction =</p>

<pre class="ruby"><span class="ruby-string">&#39;(function(source, exclusion) {&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;var rest = {};&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;var hasOwn = Object.prototype.hasOwnProperty;&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;if (source == null) {&#39;</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">&#39;throw new TypeError();&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;}&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;for (var key in source) {&#39;</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">&#39;if (hasOwn.call(source, key) &amp;&amp; !hasOwn.call(exclusion, key)) {&#39;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&#39;rest[key] = source[key];&#39;</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">&#39;}&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;}&#39;</span> <span class="ruby-operator">+</span>
  <span class="ruby-string">&#39;return rest;&#39;</span> <span class="ruby-operator">+</span>
<span class="ruby-string">&#39;})&#39;</span>;
</pre>

<p>function getPropertyNames(properties) {</p>

<pre>var names = [];
for (var i = 0; i &lt; properties.length; i++) {
  var property = properties[i];
  if (property.type === Syntax.SpreadProperty) {
    continue;
  }
  if (property.type === Syntax.Identifier) {
    names.push(property.name);
  } else {
    names.push(property.key.name);
  }
}
return names;</pre>

<p>}</p>

<p>function getRestFunctionCall(source, exclusion) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">restFunction</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;(&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">exclusion</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;)&#39;</span>;
</pre>

<p>}</p>

<p>function getSimpleShallowCopy(accessorExpression) {</p>

<pre>// This could be faster with &#39;Object.assign({}, &#39; + accessorExpression + &#39;)&#39;
// but to unify code paths and avoid a ES6 dependency we use the same
// helper as for the exclusion case.
return getRestFunctionCall(accessorExpression, &#39;{}&#39;);</pre>

<p>}</p>

<p>function renderRestExpression(accessorExpression, excludedProperties) {</p>

<pre>var excludedNames = getPropertyNames(excludedProperties);
if (!excludedNames.length) {
  return getSimpleShallowCopy(accessorExpression);
}
return getRestFunctionCall(
  accessorExpression,
  &#39;{&#39; + excludedNames.join(&#39;:1,&#39;) + &#39;:1}&#39;
);</pre>

<p>}</p>

<p>exports.renderRestExpression = renderRestExpression;</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],31:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2004-present Facebook. All Rights Reserved.
/</pre>

<p>/*global exports:true*/</p>

<p>/**</p>

<pre> Implements ES7 object spread property.
 https://gist.github.com/sebmarkbage/aa849c7973cb4452c547

 { ...a, x: 1 }

 Object.assign({}, a, {x: 1 })

/</pre>

<p>var Syntax = <em>dereq</em>(&#39;esprima-fb&#39;).Syntax; var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>function visitObjectLiteralSpread(traverse, node, path, state) {</p>

<pre>utils.catchup(node.range[0], state);

utils.append(&#39;Object.assign({&#39;, state);

// Skip the original {
utils.move(node.range[0] + 1, state);

var previousWasSpread = false;

for (var i = 0; i &lt; node.properties.length; i++) {
  var property = node.properties[i];
  if (property.type === Syntax.SpreadProperty) {

    // Close the previous object or initial object
    if (!previousWasSpread) {
      utils.append(&#39;}&#39;, state);
    }

    if (i === 0) {
      // Normally there will be a comma when we catch up, but not before
      // the first property.
      utils.append(&#39;,&#39;, state);
    }

    utils.catchup(property.range[0], state);

    // skip ...
    utils.move(property.range[0] + 3, state);

    traverse(property.argument, path, state);

    utils.catchup(property.range[1], state);

    previousWasSpread = true;

  } else {

    utils.catchup(property.range[0], state);

    if (previousWasSpread) {
      utils.append(&#39;{&#39;, state);
    }

    traverse(property, path, state);

    utils.catchup(property.range[1], state);

    previousWasSpread = false;

  }
}

// Strip any non-whitespace between the last item and the end.
// We only catch up on whitespace so that we ignore any trailing commas which
// are stripped out for IE8 support. Unfortunately, this also strips out any
// trailing comments.
utils.catchupWhiteSpace(node.range[1] - 1, state);

// Skip the trailing }
utils.move(node.range[1], state);

if (!previousWasSpread) {
  utils.append(&#39;}&#39;, state);
}

utils.append(&#39;)&#39;, state);
return false;</pre>

<p>}</p>

<p>visitObjectLiteralSpread.test = function(node, path, state) {</p>

<pre>if (node.type !== Syntax.ObjectExpression) {
  return false;
}
// Tight loop optimization
var hasAtLeastOneSpreadProperty = false;
for (var i = 0; i &lt; node.properties.length; i++) {
  var property = node.properties[i];
  if (property.type === Syntax.SpreadProperty) {
    hasAtLeastOneSpreadProperty = true;
  } else if (property.kind !== &#39;init&#39;) {
    return false;
  }
}
return hasAtLeastOneSpreadProperty;</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitObjectLiteralSpread</span>
</pre>

<p>];</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],32:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2014 Facebook, Inc.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
/</pre>

<p>var KEYWORDS = [</p>

<pre>&#39;break&#39;, &#39;do&#39;, &#39;in&#39;, &#39;typeof&#39;, &#39;case&#39;, &#39;else&#39;, &#39;instanceof&#39;, &#39;var&#39;, &#39;catch&#39;,
&#39;export&#39;, &#39;new&#39;, &#39;void&#39;, &#39;class&#39;, &#39;extends&#39;, &#39;return&#39;, &#39;while&#39;, &#39;const&#39;,
&#39;finally&#39;, &#39;super&#39;, &#39;with&#39;, &#39;continue&#39;, &#39;for&#39;, &#39;switch&#39;, &#39;yield&#39;, &#39;debugger&#39;,
&#39;function&#39;, &#39;this&#39;, &#39;default&#39;, &#39;if&#39;, &#39;throw&#39;, &#39;delete&#39;, &#39;import&#39;, &#39;try&#39;</pre>

<p>];</p>

<p>var FUTURE_RESERVED_WORDS = [</p>

<pre>&#39;enum&#39;, &#39;await&#39;, &#39;implements&#39;, &#39;package&#39;, &#39;protected&#39;, &#39;static&#39;, &#39;interface&#39;,
&#39;private&#39;, &#39;public&#39;</pre>

<p>];</p>

<p>var LITERALS = [</p>

<pre>&#39;null&#39;,
&#39;true&#39;,
&#39;false&#39;</pre>

<p>];</p>

<p>// <a
href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-reserved-words">people.mozilla.org/~jorendorff/es6-draft.html#sec-reserved-words</a>
var RESERVED_WORDS = [].concat(</p>

<pre>KEYWORDS,
FUTURE_RESERVED_WORDS,
LITERALS</pre>

<p>);</p>

<p>var reservedWordsMap = Object.create(null);
RESERVED_WORDS.forEach(function(k) {</p>

<pre class="ruby"><span class="ruby-identifier">reservedWordsMap</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-keyword">true</span>;
</pre>

<p>});</p>

<p>exports.isReservedWord = function(word) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">reservedWordsMap</span>[<span class="ruby-identifier">word</span>];
</pre>

<p>};</p>

<p>},{}],33:[function(<em>dereq</em>,module,exports){ var esprima =
<em>dereq</em>(&#39;esprima-fb&#39;); var utils =
<em>dereq</em>(&#39;../src/utils&#39;);</p>

<p>var Syntax = esprima.Syntax;</p>

<p>function _isFunctionNode(node) {</p>

<pre>return node.type === Syntax.FunctionDeclaration
       || node.type === Syntax.FunctionExpression
       || node.type === Syntax.ArrowFunctionExpression;</pre>

<p>}</p>

<p>function visitClassProperty(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitClassProperty.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">ClassProperty</span>;
</pre>

<p>};</p>

<p>function visitTypeAlias(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitTypeAlias.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">TypeAlias</span>;
</pre>

<p>};</p>

<p>function visitInterfaceDeclaration(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitInterfaceDeclaration.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">InterfaceDeclaration</span>;
</pre>

<p>};</p>

<p>function visitDeclare(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitDeclare.test = function(node, path, state) {</p>

<pre>switch (node.type) {
case Syntax.DeclareVariable:
case Syntax.DeclareFunction:
case Syntax.DeclareClass:
case Syntax.DeclareModule: return true
}
return false;</pre>

<p>}</p>

<p>function visitFunctionParametricAnnotation(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitFunctionParametricAnnotation.test = function(node, path, state) {</p>

<pre>return node.type === Syntax.TypeParameterDeclaration
       &amp;&amp; path[0]
       &amp;&amp; _isFunctionNode(path[0])
       &amp;&amp; node === path[0].typeParameters;</pre>

<p>};</p>

<p>function visitFunctionReturnAnnotation(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitFunctionReturnAnnotation.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">_isFunctionNode</span>(<span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">path</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">returnType</span>;
</pre>

<p>};</p>

<p>function visitOptionalFunctionParameterAnnotation(traverse, node, path,
state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">length</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitOptionalFunctionParameterAnnotation.test = function(node, path,
state) {</p>

<pre>return node.type === Syntax.Identifier
       &amp;&amp; node.optional
       &amp;&amp; path[0]
       &amp;&amp; _isFunctionNode(path[0]);</pre>

<p>};</p>

<p>function visitTypeAnnotatedIdentifier(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">typeAnnotation</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">typeAnnotation</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitTypeAnnotatedIdentifier.test = function(node, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">Identifier</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">typeAnnotation</span>;
</pre>

<p>};</p>

<p>function visitTypeAnnotatedObjectOrArrayPattern(traverse, node, path,
state) {</p>

<pre class="ruby"><span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchup</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">typeAnnotation</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">utils</span>.<span class="ruby-identifier">catchupWhiteOut</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">typeAnnotation</span>.<span class="ruby-identifier">range</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">state</span>);
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>} visitTypeAnnotatedObjectOrArrayPattern.test = function(node, path, state)
{</p>

<pre>var rightType = node.type === Syntax.ObjectPattern
              || node.type === Syntax.ArrayPattern;
return rightType &amp;&amp; node.typeAnnotation;</pre>

<p>};</p>

<p>/**</p>

<pre> Methods cause trouble, since esprima parses them as a key/value pair, where
 the location of the value starts at the method body. For example
 { bar(x:number,...y:Array&lt;number&gt;):number {} }
 is parsed as
 { bar: function(x: number, ...y:Array&lt;number&gt;): number {} }
 except that the location of the FunctionExpression value is 40-something,
 which is the location of the function body. This means that by the time we
 visit the params, rest param, and return type organically, we&#39;ve already
 catchup()&#39;d passed them.
/</pre>

<p>function visitMethod(traverse, node, path, state) {</p>

<pre class="ruby"><span class="ruby-identifier">path</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">node</span>);
<span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">path</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>);
<span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">params</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">rest</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">rest</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">returnType</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">returnType</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);
<span class="ruby-identifier">traverse</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">body</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">state</span>);

<span class="ruby-identifier">path</span>.<span class="ruby-identifier">shift</span>();

<span class="ruby-identifier">path</span>.<span class="ruby-identifier">shift</span>();
<span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>}</p>

<p>visitMethod.test = function(node, path, state) {</p>

<pre>return (node.type === &quot;Property&quot; &amp;&amp; (node.method || node.kind === &quot;set&quot; || node.kind === &quot;get&quot;))
    || (node.type === &quot;MethodDefinition&quot;);</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre>visitClassProperty,
visitDeclare,
visitInterfaceDeclaration,
visitFunctionParametricAnnotation,
visitFunctionReturnAnnotation,
visitMethod,
visitOptionalFunctionParameterAnnotation,
visitTypeAlias,
visitTypeAnnotatedIdentifier,
visitTypeAnnotatedObjectOrArrayPattern</pre>

<p>];</p>

<p>},{“../src/utils”:22,“esprima-fb”:9}],34:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013-2014, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
/</pre>

<p>/*global exports:true*/ “use strict”;</p>

<p>var Syntax = <em>dereq</em>(&#39;jstransform&#39;).Syntax; var utils =
<em>dereq</em>(&#39;jstransform/src/utils&#39;);</p>

<p>var FALLBACK_TAGS = <em>dereq</em>(&#39;./xjs&#39;).knownTags; var
renderXJSExpressionContainer =</p>

<pre class="ruby"><span class="ruby-identifier">_dereq_</span>(<span class="ruby-string">&#39;./xjs&#39;</span>).<span class="ruby-identifier">renderXJSExpressionContainer</span>;
</pre>

<p>var renderXJSLiteral = <em>dereq</em>(&#39;./xjs&#39;).renderXJSLiteral;
var quoteAttrName = <em>dereq</em>(&#39;./xjs&#39;).quoteAttrName;</p>

<p>var trimLeft = <em>dereq</em>(&#39;./xjs&#39;).trimLeft;</p>

<p>/**</p>

<pre> Customized desugar processor for React JSX. Currently:

 &lt;X&gt; &lt;/X&gt; =&gt; React.createElement(X, null)
 &lt;X prop=&quot;1&quot; /&gt; =&gt; React.createElement(X, {prop: &#39;1&#39;}, null)
 &lt;X prop=&quot;2&quot;&gt;&lt;Y /&gt;&lt;/X&gt; =&gt; React.createElement(X, {prop:&#39;2&#39;},
   React.createElement(Y, null)
 )
 &lt;div /&gt; =&gt; React.createElement(&quot;div&quot;, null)
/</pre>

<p>/**</p>

<pre> Removes all non-whitespace/parenthesis characters
/</pre>

<p>var reNonWhiteParen = /([^s()])/g; function stripNonWhiteParen(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">reNonWhiteParen</span>, <span class="ruby-string">&#39;&#39;</span>);
</pre>

<p>}</p>

<p>var tagConvention = /^[a-z]|-/; function isTagName(name) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">tagConvention</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">name</span>);
</pre>

<p>}</p>

<p>function visitReactTag(traverse, object, path, state) {</p>

<pre>var openingElement = object.openingElement;
var nameObject = openingElement.name;
var attributesObject = openingElement.attributes;

utils.catchup(openingElement.range[0], state, trimLeft);

if (nameObject.type === Syntax.XJSNamespacedName &amp;&amp; nameObject.namespace) {
  throw new Error(&#39;Namespace tags are not supported. ReactJSX is not XML.&#39;);
}

// We assume that the React runtime is already in scope
utils.append(&#39;React.createElement(&#39;, state);

// Identifiers with lower case or hypthens are fallback tags (strings).
// XJSMemberExpressions are not.
if (nameObject.type === Syntax.XJSIdentifier &amp;&amp; isTagName(nameObject.name)) {
  // This is a temporary error message to assist upgrades
  if (!FALLBACK_TAGS.hasOwnProperty(nameObject.name)) {
    throw new Error(
      &#39;Lower case component names (&#39; + nameObject.name + &#39;) are no longer &#39; +
      &#39;supported in JSX: See http://fb.me/react-jsx-lower-case&#39;
    );
  }

  utils.append(&#39;&quot;&#39; + nameObject.name + &#39;&quot;&#39;, state);
  utils.move(nameObject.range[1], state);
} else {
  // Use utils.catchup in this case so we can easily handle
  // XJSMemberExpressions which look like Foo.Bar.Baz. This also handles
  // XJSIdentifiers that aren&#39;t fallback tags.
  utils.move(nameObject.range[0], state);
  utils.catchup(nameObject.range[1], state);
}

utils.append(&#39;, &#39;, state);

var hasAttributes = attributesObject.length;

var hasAtLeastOneSpreadProperty = attributesObject.some(function(attr) {
  return attr.type === Syntax.XJSSpreadAttribute;
});

// if we don&#39;t have any attributes, pass in null
if (hasAtLeastOneSpreadProperty) {
  utils.append(&#39;React.__spread({&#39;, state);
} else if (hasAttributes) {
  utils.append(&#39;{&#39;, state);
} else {
  utils.append(&#39;null&#39;, state);
}

// keep track of if the previous attribute was a spread attribute
var previousWasSpread = false;

// write attributes
attributesObject.forEach(function(attr, index) {
  var isLast = index === attributesObject.length - 1;

  if (attr.type === Syntax.XJSSpreadAttribute) {
    // Close the previous object or initial object
    if (!previousWasSpread) {
      utils.append(&#39;}, &#39;, state);
    }

    // Move to the expression start, ignoring everything except parenthesis
    // and whitespace.
    utils.catchup(attr.range[0], state, stripNonWhiteParen);
    // Plus 1 to skip `{`.
    utils.move(attr.range[0] + 1, state);
    utils.catchup(attr.argument.range[0], state, stripNonWhiteParen);

    traverse(attr.argument, path, state);

    utils.catchup(attr.argument.range[1], state);

    // Move to the end, ignoring parenthesis and the closing `}`
    utils.catchup(attr.range[1] - 1, state, stripNonWhiteParen);

    if (!isLast) {
      utils.append(&#39;, &#39;, state);
    }

    utils.move(attr.range[1], state);

    previousWasSpread = true;

    return;
  }

  // If the next attribute is a spread, we&#39;re effective last in this object
  if (!isLast) {
    isLast = attributesObject[index + 1].type === Syntax.XJSSpreadAttribute;
  }

  if (attr.name.namespace) {
    throw new Error(
       &#39;Namespace attributes are not supported. ReactJSX is not XML.&#39;);
  }
  var name = attr.name.name;

  utils.catchup(attr.range[0], state, trimLeft);

  if (previousWasSpread) {
    utils.append(&#39;{&#39;, state);
  }

  utils.append(quoteAttrName(name), state);
  utils.append(&#39;: &#39;, state);

  if (!attr.value) {
    state.g.buffer += &#39;true&#39;;
    state.g.position = attr.name.range[1];
    if (!isLast) {
      utils.append(&#39;, &#39;, state);
    }
  } else {
    utils.move(attr.name.range[1], state);
    // Use catchupNewlines to skip over the &#39;=&#39; in the attribute
    utils.catchupNewlines(attr.value.range[0], state);
    if (attr.value.type === Syntax.Literal) {
      renderXJSLiteral(attr.value, isLast, state);
    } else {
      renderXJSExpressionContainer(traverse, attr.value, isLast, path, state);
    }
  }

  utils.catchup(attr.range[1], state, trimLeft);

  previousWasSpread = false;

});

if (!openingElement.selfClosing) {
  utils.catchup(openingElement.range[1] - 1, state, trimLeft);
  utils.move(openingElement.range[1], state);
}

if (hasAttributes &amp;&amp; !previousWasSpread) {
  utils.append(&#39;}&#39;, state);
}

if (hasAtLeastOneSpreadProperty) {
  utils.append(&#39;)&#39;, state);
}

// filter out whitespace
var childrenToRender = object.children.filter(function(child) {
  return !(child.type === Syntax.Literal
           &amp;&amp; typeof child.value === &#39;string&#39;
           &amp;&amp; child.value.match(/^[ \t]*[\r\n][ \t\r\n]*$/));
});
if (childrenToRender.length &gt; 0) {
  var lastRenderableIndex;

  childrenToRender.forEach(function(child, index) {
    if (child.type !== Syntax.XJSExpressionContainer ||
        child.expression.type !== Syntax.XJSEmptyExpression) {
      lastRenderableIndex = index;
    }
  });

  if (lastRenderableIndex !== undefined) {
    utils.append(&#39;, &#39;, state);
  }

  childrenToRender.forEach(function(child, index) {
    utils.catchup(child.range[0], state, trimLeft);

    var isLast = index &gt;= lastRenderableIndex;

    if (child.type === Syntax.Literal) {
      renderXJSLiteral(child, isLast, state);
    } else if (child.type === Syntax.XJSExpressionContainer) {
      renderXJSExpressionContainer(traverse, child, isLast, path, state);
    } else {
      traverse(child, path, state);
      if (!isLast) {
        utils.append(&#39;, &#39;, state);
      }
    }

    utils.catchup(child.range[1], state, trimLeft);
  });
}

if (openingElement.selfClosing) {
  // everything up to /&gt;
  utils.catchup(openingElement.range[1] - 2, state, trimLeft);
  utils.move(openingElement.range[1], state);
} else {
  // everything up to &lt;/ sdflksjfd&gt;
  utils.catchup(object.closingElement.range[0], state, trimLeft);
  utils.move(object.closingElement.range[1], state);
}

utils.append(&#39;)&#39;, state);
return false;</pre>

<p>}</p>

<p>visitReactTag.test = function(object, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">object</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">XJSElement</span>;
</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitReactTag</span>
</pre>

<p>];</p>

<p>},{“./xjs”:36,“jstransform”:21,“jstransform/src/utils”:22}],35:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013-2014, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
/</pre>

<p>/*global exports:true*/ “use strict”;</p>

<p>var Syntax = <em>dereq</em>(&#39;jstransform&#39;).Syntax; var utils =
<em>dereq</em>(&#39;jstransform/src/utils&#39;);</p>

<p>function addDisplayName(displayName, object, state) {</p>

<pre>if (object &amp;&amp;
    object.type === Syntax.CallExpression &amp;&amp;
    object.callee.type === Syntax.MemberExpression &amp;&amp;
    object.callee.object.type === Syntax.Identifier &amp;&amp;
    object.callee.object.name === &#39;React&#39; &amp;&amp;
    object.callee.property.type === Syntax.Identifier &amp;&amp;
    object.callee.property.name === &#39;createClass&#39; &amp;&amp;
    object[&#39;arguments&#39;].length === 1 &amp;&amp;
    object[&#39;arguments&#39;][0].type === Syntax.ObjectExpression) {
  // Verify that the displayName property isn&#39;t already set
  var properties = object[&#39;arguments&#39;][0].properties;
  var safe = properties.every(function(property) {
    var value = property.key.type === Syntax.Identifier ?
      property.key.name :
      property.key.value;
    return value !== &#39;displayName&#39;;
  });

  if (safe) {
    utils.catchup(object[&#39;arguments&#39;][0].range[0] + 1, state);
    utils.append(&#39;displayName: &quot;&#39; + displayName + &#39;&quot;,&#39;, state);
  }
}</pre>

<p>}</p>

<p>/**</p>

<pre> Transforms the following:

 var MyComponent = React.createClass({
    render: ...
 });

 into:

 var MyComponent = React.createClass({
    displayName: &#39;MyComponent&#39;,
    render: ...
 });

 Also catches:

 MyComponent = React.createClass(...);
 exports.MyComponent = React.createClass(...);
 module.exports = {MyComponent: React.createClass(...)};
/</pre>

<p>function visitReactDisplayName(traverse, object, path, state) {</p>

<pre>var left, right;

if (object.type === Syntax.AssignmentExpression) {
  left = object.left;
  right = object.right;
} else if (object.type === Syntax.Property) {
  left = object.key;
  right = object.value;
} else if (object.type === Syntax.VariableDeclarator) {
  left = object.id;
  right = object.init;
}

if (left &amp;&amp; left.type === Syntax.MemberExpression) {
  left = left.property;
}
if (left &amp;&amp; left.type === Syntax.Identifier) {
  addDisplayName(left.name, right, state);
}</pre>

<p>}</p>

<p>visitReactDisplayName.test = function(object, path, state) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (
  <span class="ruby-identifier">object</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">AssignmentExpression</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">object</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">Property</span> <span class="ruby-operator">||</span>
  <span class="ruby-identifier">object</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Syntax</span>.<span class="ruby-constant">VariableDeclarator</span>
);
</pre>

<p>};</p>

<p>exports.visitorList = [</p>

<pre class="ruby"><span class="ruby-identifier">visitReactDisplayName</span>
</pre>

<p>];</p>

<p>},{“jstransform”:21,“jstransform/src/utils”:22}],36:[function(<em>dereq</em>,module,exports){
/**</p>

<pre> Copyright 2013-2014, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
/</pre>

<p>/*global exports:true*/ “use strict”; var Syntax =
<em>dereq</em>(&#39;jstransform&#39;).Syntax; var utils =
<em>dereq</em>(&#39;jstransform/src/utils&#39;);</p>

<p>var knownTags = {</p>

<pre>a: true,
abbr: true,
address: true,
applet: true,
area: true,
article: true,
aside: true,
audio: true,
b: true,
base: true,
bdi: true,
bdo: true,
big: true,
blockquote: true,
body: true,
br: true,
button: true,
canvas: true,
caption: true,
circle: true,
cite: true,
code: true,
col: true,
colgroup: true,
command: true,
data: true,
datalist: true,
dd: true,
defs: true,
del: true,
details: true,
dfn: true,
dialog: true,
div: true,
dl: true,
dt: true,
ellipse: true,
em: true,
embed: true,
fieldset: true,
figcaption: true,
figure: true,
footer: true,
form: true,
g: true,
h1: true,
h2: true,
h3: true,
h4: true,
h5: true,
h6: true,
head: true,
header: true,
hgroup: true,
hr: true,
html: true,
i: true,
iframe: true,
img: true,
input: true,
ins: true,
kbd: true,
keygen: true,
label: true,
legend: true,
li: true,
line: true,
linearGradient: true,
link: true,
main: true,
map: true,
mark: true,
marquee: true,
mask: false,
menu: true,
menuitem: true,
meta: true,
meter: true,
nav: true,
noscript: true,
object: true,
ol: true,
optgroup: true,
option: true,
output: true,
p: true,
param: true,
path: true,
pattern: false,
picture: true,
polygon: true,
polyline: true,
pre: true,
progress: true,
q: true,
radialGradient: true,
rect: true,
rp: true,
rt: true,
ruby: true,
s: true,
samp: true,
script: true,
section: true,
select: true,
small: true,
source: true,
span: true,
stop: true,
strong: true,
style: true,
sub: true,
summary: true,
sup: true,
svg: true,
table: true,
tbody: true,
td: true,
text: true,
textarea: true,
tfoot: true,
th: true,
thead: true,
time: true,
title: true,
tr: true,
track: true,
tspan: true,
u: true,
ul: true,
&#39;var&#39;: true,
video: true,
wbr: true</pre>

<p>};</p>

<p>function renderXJSLiteral(object, isLast, state, start, end) {</p>

<pre>var lines = object.value.split(/\r\n|\n|\r/);

if (start) {
  utils.append(start, state);
}

var lastNonEmptyLine = 0;

lines.forEach(function (line, index) {
  if (line.match(/[^ \t]/)) {
    lastNonEmptyLine = index;
  }
});

lines.forEach(function (line, index) {
  var isFirstLine = index === 0;
  var isLastLine = index === lines.length - 1;
  var isLastNonEmptyLine = index === lastNonEmptyLine;

  // replace rendered whitespace tabs with spaces
  var trimmedLine = line.replace(/\t/g, &#39; &#39;);

  // trim whitespace touching a newline
  if (!isFirstLine) {
    trimmedLine = trimmedLine.replace(/^[ ]+/, &#39;&#39;);
  }
  if (!isLastLine) {
    trimmedLine = trimmedLine.replace(/[ ]+$/, &#39;&#39;);
  }

  if (!isFirstLine) {
    utils.append(line.match(/^[ \t]*/)[0], state);
  }

  if (trimmedLine || isLastNonEmptyLine) {
    utils.append(
      JSON.stringify(trimmedLine) +
      (!isLastNonEmptyLine ? &quot; + &#39; &#39; +&quot; : &#39;&#39;),
      state);

    if (isLastNonEmptyLine) {
      if (end) {
        utils.append(end, state);
      }
      if (!isLast) {
        utils.append(&#39;, &#39;, state);
      }
    }

    // only restore tail whitespace if line had literals
    if (trimmedLine &amp;&amp; !isLastLine) {
      utils.append(line.match(/[ \t]*$/)[0], state);
    }
  }

  if (!isLastLine) {
    utils.append(&#39;\n&#39;, state);
  }
});

utils.move(object.range[1], state);</pre>

<p>}</p>

<p>function renderXJSExpressionContainer(traverse, object, isLast, path,
state) {</p>

<pre>// Plus 1 to skip `{`.
utils.move(object.range[0] + 1, state);
traverse(object.expression, path, state);

if (!isLast &amp;&amp; object.expression.type !== Syntax.XJSEmptyExpression) {
  // If we need to append a comma, make sure to do so after the expression.
  utils.catchup(object.expression.range[1], state, trimLeft);
  utils.append(&#39;, &#39;, state);
}

// Minus 1 to skip `}`.
utils.catchup(object.range[1] - 1, state, trimLeft);
utils.move(object.range[1], state);
return false;</pre>

<p>}</p>

<p>function quoteAttrName(attr) {</p>

<pre>// Quote invalid JS identifiers.
if (!/^[a-z_$][a-z\d_$]*$/i.test(attr)) {
  return &#39;&quot;&#39; + attr + &#39;&quot;&#39;;
}
return attr;</pre>

<p>}</p>

<p>function trimLeft(value) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-regexp">/^[ ]+/</span>, <span class="ruby-string">&#39;&#39;</span>);
</pre>

<p>}</p>

<p>exports.knownTags = knownTags; exports.renderXJSExpressionContainer =
renderXJSExpressionContainer; exports.renderXJSLiteral = renderXJSLiteral;
exports.quoteAttrName = quoteAttrName; exports.trimLeft = trimLeft;</p>

<p>},{“jstransform”:21,“jstransform/src/utils”:22}],37:[function(<em>dereq</em>,module,exports){
/*global exports:true*/ var es6ArrowFunctions =
<em>dereq</em>(&#39;jstransform/visitors/es6-arrow-function-visitors&#39;);
var es6Classes =
<em>dereq</em>(&#39;jstransform/visitors/es6-class-visitors&#39;); var
es6Destructuring =
<em>dereq</em>(&#39;jstransform/visitors/es6-destructuring-visitors&#39;);
var es6ObjectConciseMethod =
<em>dereq</em>(&#39;jstransform/visitors/es6-object-concise-method-visitors&#39;);
var es6ObjectShortNotation =
<em>dereq</em>(&#39;jstransform/visitors/es6-object-short-notation-visitors&#39;);
var es6RestParameters =
<em>dereq</em>(&#39;jstransform/visitors/es6-rest-param-visitors&#39;); var
es6Templates =
<em>dereq</em>(&#39;jstransform/visitors/es6-template-visitors&#39;); var
es7SpreadProperty =
<em>dereq</em>(&#39;jstransform/visitors/es7-spread-property-visitors&#39;);
var react = <em>dereq</em>(&#39;./transforms/react&#39;); var
reactDisplayName = <em>dereq</em>(&#39;./transforms/reactDisplayName&#39;);</p>

<p>/**</p>

<pre class="ruby"> <span class="ruby-constant">Map</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">transformName</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">orderedListOfVisitors</span>.
<span class="ruby-operator">/</span>
</pre>

<p>var transformVisitors = {</p>

<pre>&#39;es6-arrow-functions&#39;: es6ArrowFunctions.visitorList,
&#39;es6-classes&#39;: es6Classes.visitorList,
&#39;es6-destructuring&#39;: es6Destructuring.visitorList,
&#39;es6-object-concise-method&#39;: es6ObjectConciseMethod.visitorList,
&#39;es6-object-short-notation&#39;: es6ObjectShortNotation.visitorList,
&#39;es6-rest-params&#39;: es6RestParameters.visitorList,
&#39;es6-templates&#39;: es6Templates.visitorList,
&#39;es7-spread-property&#39;: es7SpreadProperty.visitorList,
&#39;react&#39;: react.visitorList.concat(reactDisplayName.visitorList)</pre>

<p>};</p>

<p>var transformSets = {</p>

<pre>&#39;harmony&#39;: [
  &#39;es6-arrow-functions&#39;,
  &#39;es6-object-concise-method&#39;,
  &#39;es6-object-short-notation&#39;,
  &#39;es6-classes&#39;,
  &#39;es6-rest-params&#39;,
  &#39;es6-templates&#39;,
  &#39;es6-destructuring&#39;,
  &#39;es7-spread-property&#39;
],
&#39;react&#39;: [
  &#39;react&#39;
]</pre>

<p>};</p>

<p>/**</p>

<pre> Specifies the order in which each transform should run.
/</pre>

<p>var transformRunOrder = [</p>

<pre>&#39;es6-arrow-functions&#39;,
&#39;es6-object-concise-method&#39;,
&#39;es6-object-short-notation&#39;,
&#39;es6-classes&#39;,
&#39;es6-rest-params&#39;,
&#39;es6-templates&#39;,
&#39;es6-destructuring&#39;,
&#39;es7-spread-property&#39;,
&#39;react&#39;</pre>

<p>];</p>

<p>/**</p>

<pre> Given a list of transform names, return the ordered list of visitors to be
 passed to the transform() function.

 @param {array?} excludes
 @return {array}
/</pre>

<p>function getAllVisitors(excludes) {</p>

<pre>var ret = [];
for (var i = 0, il = transformRunOrder.length; i &lt; il; i++) {
  if (!excludes || excludes.indexOf(transformRunOrder[i]) === -1) {
    ret = ret.concat(transformVisitors[transformRunOrder[i]]);
  }
}
return ret;</pre>

<p>}</p>

<p>/**</p>

<pre> Given a list of visitor set names, return the ordered list of visitors to be
 passed to jstransform.

 @param {array}
 @return {array}
/</pre>

<p>function getVisitorsBySet(sets) {</p>

<pre>var visitorsToInclude = sets.reduce(function(visitors, set) {
  if (!transformSets.hasOwnProperty(set)) {
    throw new Error(&#39;Unknown visitor set: &#39; + set);
  }
  transformSets[set].forEach(function(visitor) {
    visitors[visitor] = true;
  });
  return visitors;
}, {});

var visitorList = [];
for (var i = 0; i &lt; transformRunOrder.length; i++) {
  if (visitorsToInclude.hasOwnProperty(transformRunOrder[i])) {
    visitorList = visitorList.concat(transformVisitors[transformRunOrder[i]]);
  }
}

return visitorList;</pre>

<p>}</p>

<p>exports.getVisitorsBySet = getVisitorsBySet; exports.getAllVisitors =
getAllVisitors; exports.transformVisitors = transformVisitors;</p>

<p>},{“./transforms/react”:34,“./transforms/reactDisplayName”:35,“jstransform/visitors/es6-arrow-function-visitors”:23,“jstransform/visitors/es6-class-visitors”:24,“jstransform/visitors/es6-destructuring-visitors”:25,“jstransform/visitors/es6-object-concise-method-visitors”:26,“jstransform/visitors/es6-object-short-notation-visitors”:27,“jstransform/visitors/es6-rest-param-visitors”:28,“jstransform/visitors/es6-template-visitors”:29,“jstransform/visitors/es7-spread-property-visitors”:31}]},{},[1])(1)
});</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

